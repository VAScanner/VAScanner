{
    "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)": {
        "isVulRoot": true,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.LastHttpContent readTrailingHeaders(io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.HttpObjectDecoder$State readHeaders(io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.LastHttpContent readTrailingHeaders(io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.HttpObjectDecoder$State readHeaders(io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.HttpClientCodec$Decoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelInactiveNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageCodec:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.memcache.binary.AbstractBinaryMemcacheDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelReadNow(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelInactiveNow(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker$4:void run()",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.memcache.binary.AbstractBinaryMemcacheDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.memcache.binary.BinaryMemcacheClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelReadNow(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.DefaultChannelHandlerInvoker$7:void run()",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()"
        ]
    },
    "io.netty.handler.codec.memcache.binary.BinaryMemcacheClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelInactiveNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.MessageAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.ReadTimeoutHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.IdleStateHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.ssl.SslHandler:void unwrapNonAppData(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageCodec:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ReplayingDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.local.LocalServerChannel:void doBeginRead()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelReadNow(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.ReadTimeoutHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void unwrapNonAppData(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void access$200(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ReplayingDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ReplayingDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioChannel$1:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void doRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioChannel$1:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void access$500(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalChannel:void doPeerClose(io.netty.channel.local.LocalChannel,boolean)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.local.LocalChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalServerChannel:void access$000(io.netty.channel.local.LocalServerChannel,io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ReplayingDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$200(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$5:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void remove0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void replace0(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeysOptimized(java.nio.channels.SelectionKey[])",
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeysPlain(java.util.Set)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void access$500(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel$5:void run()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.local.LocalChannel:void doClose()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doPeerClose(io.netty.channel.local.LocalChannel,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void access$400(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel,boolean)",
            "io.netty.channel.local.LocalChannel:void doClose()"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void access$000(io.netty.channel.local.LocalServerChannel,io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalServerChannel$2:void run()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void access$500(io.netty.handler.ssl.SslHandler,io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void remove0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$2:void run()",
            "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void replace0(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void access$000(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeysOptimized(java.nio.channels.SelectionKey[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeysPlain(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeReadNow(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.local.LocalChannel$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void access$400(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel$4:void run()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void access$500(io.netty.handler.ssl.SslHandler,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$3:void run()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void access$400(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$000(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$3:void run()"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator:void run()"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeReadNow(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeRead(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeRead(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelHandlerInvoker$15:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void flush0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollOutReady()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void flush0()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void forceFlush()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$600(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.local.LocalChannel$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void access$400(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$7:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void access$300(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void destroy()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeRead(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeRead(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$15:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollOutReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollOutReady()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void forceFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$100(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$600(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void access$300(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$6:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void destroy()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeExceptionCaughtNow(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelRegisteredNow(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$4:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void addFirst0(java.lang.String,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void addAfter0(java.lang.String,io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void addBefore0(java.lang.String,io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void replace0(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void addLast0(java.lang.String,io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeFlushNow(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollOutReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeDisconnectNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$100(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$1:void run()",
            "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.local.LocalChannel$2:void run()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.local.LocalServerChannel$1:void run()",
            "io.netty.channel.local.LocalChannel:void doPeerClose(io.netty.channel.local.LocalChannel,boolean)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeExceptionCaughtNow(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker$5:void run()",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeExceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeExceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void notifyHandlerException(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelRegisteredNow(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelHandlerInvoker$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void addFirst0(java.lang.String,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandlerInvoker,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void addAfter0(java.lang.String,io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.channel.ChannelHandlerInvoker,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void addBefore0(java.lang.String,io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.channel.ChannelHandlerInvoker,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void addLast0(java.lang.String,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandlerInvoker,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.spdy.SpdyFrameCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelReadCompleteNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()",
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeReadNow(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeFlushNow(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelHandlerInvoker$16:void run()",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeFlush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeDisconnectNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeDisconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker$12:void run()",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeDisconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,io.netty.channel.ChannelHandler[])",
            "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeCloseNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.channel.local.LocalChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$300(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.local.LocalServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeExceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeExceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void notifyHandlerException(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeReadNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelUnregisteredNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelInactiveNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelActiveNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelReadCompleteNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelRegisteredNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeUserEventTriggeredNow(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeFlushNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelWritabilityChangedNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelReadNow(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandlerInvoker,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandlerInvoker,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.channel.ChannelHandlerInvoker,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.channel.ChannelHandlerInvoker,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandlerInvoker,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandlerInvoker,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.spdy.SpdyFrameCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelReadCompleteNow(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelHandlerInvoker$8:void run()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.local.LocalServerChannel:void doBeginRead()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()",
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeFlush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$16:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeFlush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeDisconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$12:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeDisconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture register()",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId)",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollChannelConfig:void autoReadCleared()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeCloseNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeClose(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker$13:void run()",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeClose(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$300(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollOutReady()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeConnectNow(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelUnregisteredNow(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelHandlerInvoker$2:void run()",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelActiveNow(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelHandlerInvoker$3:void run()"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeUserEventTriggeredNow(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeUserEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeUserEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.DefaultChannelHandlerInvoker$6:void run()"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelWritabilityChangedNow(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker$9:void run()",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandlerInvoker,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandlerInvoker,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$3:void run()",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)",
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.sctp.SctpServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.rxtx.RxtxChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.sctp.SctpChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture register()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect()"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind()",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentCompressor:io.netty.handler.codec.http.HttpContentEncoder$Result beginEncode(io.netty.handler.codec.http.HttpResponse,java.lang.String)",
            "io.netty.handler.codec.http.HttpContentDecompressor:io.netty.channel.embedded.EmbeddedChannel newContentDecoder(java.lang.String)",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>()",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressionChannel(io.netty.handler.codec.compression.ZlibWrapper)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:io.netty.channel.embedded.EmbeddedChannel newContentDecompressor(java.lang.CharSequence)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeClose(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$13:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeClose(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.ScheduledFutureTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$3:void run()",
            "io.netty.util.concurrent.DefaultPromise:void notifyLateListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners()",
            "io.netty.util.concurrent.DefaultPromise:void notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise$LateListeners:void run()",
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners0(io.netty.util.concurrent.Future,io.netty.util.concurrent.DefaultFutureListeners)",
            "io.netty.util.concurrent.DefaultPromise$2:void run()"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeBindNow(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeConnectNow(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker$11:void run()",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeConnect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeConnect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$9:void run()",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.marshalling.CompatibleMarshallingDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeExceptionCaughtNow(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeExceptionCaughtNow(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeExceptionCaughtNow(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeUserEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeUserEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$9:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeChannelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeChannelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.traffic.AbstractTrafficShapingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.IdleStateHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.ReadTimeoutHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelRegisteredNow(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.embedded.EmbeddedChannel$1:void initChannel(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.udt.DefaultUdtChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.sctp.DefaultSctpChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.DefaultChannelConfig:boolean setOptions(java.util.Map)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtServerChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.sctp.SctpServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.rxtx.RxtxChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollDatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollDomainSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.oio.OioServerSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.oio.OioSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.sctp.SctpChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeFlushNow(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JdkZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeDisconnectNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.InetAddress,int)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.lang.String,int)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.channel.ChannelFuture connectChannel(io.netty.bootstrap.Bootstrap)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.channel.ChannelFuture newChannel(io.netty.channel.ChannelFactory,java.net.InetSocketAddress)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(int)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.InetAddress,int)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.lang.String,int)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentCompressor:io.netty.handler.codec.http.HttpContentEncoder$Result beginEncode(io.netty.handler.codec.http.HttpResponse,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentDecompressor:io.netty.channel.embedded.EmbeddedChannel newContentDecoder(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressionChannel(io.netty.handler.codec.compression.ZlibWrapper)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newContentCompressor(java.lang.CharSequence)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:io.netty.channel.embedded.EmbeddedChannel newContentDecompressor(java.lang.CharSequence)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void initDecompressor(int,io.netty.handler.codec.http2.Http2Headers,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener$1:void run()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder$3:void run()",
            "io.netty.handler.codec.compression.JZlibEncoder$3:void run()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyLateListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListeners()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:boolean trySuccess(java.lang.Object)",
            "io.netty.util.concurrent.DefaultPromise:boolean cancel(boolean)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.util.concurrent.DefaultPromise:boolean tryFailure(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$LateListeners:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$LateListenerNotifier:void run()",
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListeners0(io.netty.util.concurrent.Future,io.netty.util.concurrent.DefaultFutureListeners)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners()",
            "io.netty.util.concurrent.DefaultPromise:void access$000(io.netty.util.concurrent.Future,io.netty.util.concurrent.DefaultFutureListeners)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeBindNow(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeBind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeBind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker$10:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$11:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeConnect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeConnect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise:void access$000(io.netty.channel.VoidChannelPromise,java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$9:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.marshalling.CompatibleMarshallingDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.traffic.AbstractTrafficShapingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.ReadTimeoutHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel$1:void initChannel(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelReadCompleteNow(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelConfig:boolean setOptions(java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollDatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollDomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.oio.OioServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.oio.OioSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])",
            "io.netty.channel.nio.AbstractNioByteChannel$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JdkZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeCloseNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeCloseNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder$1:void run()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.InetAddress,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.lang.String,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.channel.ChannelFuture connectChannel(io.netty.bootstrap.Bootstrap)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.channel.ChannelFuture newChannel(io.netty.channel.ChannelFactory,java.net.InetSocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,java.net.InetSocketAddress,io.netty.resolver.dns.DnsServerAddresses)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.InetAddress,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.lang.String,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newContentCompressor(java.lang.CharSequence)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressor(io.netty.handler.codec.http2.Http2Headers,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void initDecompressor(int,io.netty.handler.codec.http2.Http2Headers,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void processGoAwayWriteResult(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void fail(io.netty.channel.ChannelHandlerContext,java.lang.String,java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void execute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.pool.FixedChannelPool$AcquireTask:void <init>(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean trySuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Void)",
            "io.netty.handler.ssl.SslHandler:void setHandshakeSuccess()",
            "io.netty.channel.DefaultChannelPromise:boolean trySuccess()",
            "io.netty.channel.DefaultChannelProgressivePromise:boolean trySuccess()",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:void shutdown()",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()",
            "io.netty.channel.ThreadPerChannelEventLoopGroup$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.util.concurrent.PromiseTask:boolean trySuccessInternal(java.lang.Object)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean cancel(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancelWithoutRemove(boolean)",
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void setSuccess0()",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)",
            "io.netty.resolver.DefaultNameResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setSuccessInternal(java.lang.Object)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.MultithreadEventExecutorGroup$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$1:void run()",
            "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)",
            "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.PromiseTask:boolean tryFailureInternal(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryFailure(java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundBuffer:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()",
            "io.netty.handler.ssl.SslHandler:void notifyHandshakeFailure(java.lang.Throwable)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel:void doClose()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel:void doClose()",
            "io.netty.resolver.dns.DnsQueryContext$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void setFailure0(io.netty.channel.group.ChannelGroupException)",
            "io.netty.resolver.DefaultNameResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setFailureInternal(java.lang.Throwable)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$LateListenerNotifier:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void access$000(io.netty.util.concurrent.Future,io.netty.util.concurrent.DefaultFutureListeners)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$1:void run()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeBind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeBind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$10:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:void access$000(io.netty.channel.VoidChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelUnregisteredNow(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelActiveNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.IdleStateHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.WebSocketClientProtocolHandshakeHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.ReadTimeoutHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.sctp.SctpNotificationHandler:void fireEvent(com.sun.nio.sctp.Notification)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeUserEventTriggeredNow(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer$2:void run()",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeChannelWritabilityChangedNow(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,java.net.InetSocketAddress,io.netty.resolver.dns.DnsServerAddresses)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,java.lang.Class,java.net.InetSocketAddress,io.netty.resolver.dns.DnsServerAddresses)",
            "io.netty.resolver.dns.DnsNameResolverGroup:io.netty.resolver.NameResolver newResolver(io.netty.util.concurrent.EventExecutor)",
            "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddresses)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageCodec$1:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressor(io.netty.handler.codec.http2.Http2Headers,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void processGoAwayWriteResult(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$900(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void fail(io.netty.channel.ChannelHandlerContext,java.lang.String,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,java.lang.String)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void checkCloseConnection(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void execute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyLateListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:void access$400(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)",
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners()",
            "io.netty.util.concurrent.DefaultPromise:void notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:void notifyProgressiveListeners(long,long)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:void access$300(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$AcquireTask:void <init>(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.bootstrap.Bootstrap$3:void run()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise unvoid()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.EventLoop nextChild()",
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:boolean setHandshakeSuccessIfStillHandshaking()",
            "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:boolean trySuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$CloseFuture:boolean setClosed()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetSuccess(io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundBuffer:void safeSuccess(io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:boolean trySuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void safeSuccess(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:boolean trySuccessInternal(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.ScheduledFutureTask:boolean cancelWithoutRemove(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.resolver.dns.DnsCacheEntry:void cancelExpiration()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void setSuccess0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void access$400(io.netty.channel.group.DefaultChannelGroupFuture)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Map,io.netty.util.concurrent.EventExecutor)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Collection,io.netty.util.concurrent.EventExecutor)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise doneAllocatingPromises()",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)"
        ]
    },
    "io.netty.resolver.DefaultNameResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.DefaultNameResolver:void doResolve(java.net.SocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setSuccessInternal(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$000(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void finish(io.netty.channel.AddressedEnvelope)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$200(io.netty.channel.pool.SimpleChannelPool,io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void access$100(io.netty.handler.proxy.ProxyHandler,java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.proxy.ProxyHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void access$300(io.netty.resolver.dns.DnsQueryContext,java.lang.String,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsQueryContext:void onQueryWriteCompletion(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:boolean tryFailureInternal(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsQueryContext$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.ChannelOutboundBuffer:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)",
            "io.netty.channel.ChannelOutboundBuffer:void close(java.nio.channels.ClosedChannelException)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void notifyHandshakeFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void access$700(io.netty.handler.ssl.SslHandler,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractServerChannel$DefaultServerUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:boolean ensureOpen(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$200(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeDeregisterNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeBindNow(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeDisconnectNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeCloseNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeConnectNow(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeWriteNow(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void doClose()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void setFailure0(io.netty.channel.group.ChannelGroupException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void access$300(io.netty.channel.group.DefaultChannelGroupFuture,io.netty.channel.group.ChannelGroupException)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$TimeoutTask:void run()"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setFailureInternal(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$3:void run()",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap$2:void run()",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void safeExecuteOutbound(java.lang.Runnable,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void safeExecuteOutbound(java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeConnectNow(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.VoidChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.WebSocketClientProtocolHandshakeHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.ReadTimeoutHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:void fireEvent(com.sun.nio.sctp.Notification)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.PeerAddressChangeNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.AssociationChangeNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.SendFailedNotification,java.lang.Object)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)",
            "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder$HeadersFrame:void send(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void access$000(io.netty.resolver.dns.DnsQueryContext,io.netty.handler.codec.dns.DnsQuery)",
            "io.netty.resolver.dns.DnsQueryContext:void sendQuery(io.netty.handler.codec.dns.DnsQuery)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future access$201(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire()",
            "io.netty.channel.pool.FixedChannelPool:void runTaskQueue()"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,java.lang.Class,java.net.InetSocketAddress,io.netty.resolver.dns.DnsServerAddresses)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,java.lang.Class,io.netty.resolver.dns.DnsServerAddresses)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverGroup:io.netty.resolver.NameResolver newResolver(io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddresses)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageToMessageCodec$1:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$900(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)",
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close()",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.resolver.dns.DnsNameResolver:void close()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void checkCloseConnection(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$800(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void access$400(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$LateListeners:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyProgressiveListeners(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:boolean tryProgress(long,long)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:void access$300(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$3:void run()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.channel.ChannelFuture newChannel(io.netty.channel.ChannelFactory,java.net.InetSocketAddress)",
            "io.netty.resolver.dns.DnsQueryContext:void sendQuery(io.netty.handler.codec.dns.DnsQuery)",
            "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap$2:void run()",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.handler.codec.compression.JZlibEncoder$1:void run()",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void doGracefulShutdown(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)",
            "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise unvoid()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.EventLoop nextChild()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])",
            "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void followCname(java.net.InetSocketAddress,java.lang.String,java.lang.String)",
            "io.netty.resolver.dns.DnsNameResolverContext:void access$500(io.netty.resolver.dns.DnsNameResolverContext,java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)",
            "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve()",
            "io.netty.resolver.dns.DnsNameResolverContext:void resolve()",
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Void)",
            "io.netty.channel.DefaultChannelPromise:boolean trySuccess()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:boolean setHandshakeSuccessIfStillHandshaking()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel$CloseFuture:boolean setClosed()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetSuccess(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$DefaultUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$100(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void safeSuccess(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove()"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsCacheEntry:void cancelExpiration()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void access$300(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$400(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void access$400(io.netty.channel.group.DefaultChannelGroupFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Map,io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Collection,io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise doneAllocatingPromises()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$3:void run()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise doneAllocatingPromises()",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.DefaultNameResolver:void doResolve(java.net.SocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$000(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void finish(io.netty.channel.AddressedEnvelope)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void access$100(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$200(io.netty.channel.pool.SimpleChannelPool,io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess()",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void access$100(io.netty.handler.proxy.ProxyHandler,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler$2:void run()",
            "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsQueryContext:void access$300(io.netty.resolver.dns.DnsQueryContext,java.lang.String,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$3:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void onQueryWriteCompletion(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void access$200(io.netty.resolver.dns.DnsQueryContext,io.netty.channel.ChannelFuture)",
            "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)",
            "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void close(java.nio.channels.ClosedChannelException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()",
            "io.netty.channel.ChannelOutboundBuffer$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void access$700(io.netty.handler.ssl.SslHandler,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$5:void run()"
        ]
    },
    "io.netty.channel.AbstractServerChannel$DefaultServerUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:boolean ensureOpen(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$200(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeDeregisterNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeDeregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeDeregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker$14:void run()"
        ]
    },
    "io.netty.channel.ChannelHandlerInvokerUtil:void invokeWriteNow(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker$WriteTask:void run()",
            "io.netty.channel.embedded.EmbeddedEventLoop:void invokeWrite(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeWrite(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsQueryContext$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void access$300(io.netty.channel.group.DefaultChannelGroupFuture,io.netty.channel.group.ChannelGroupException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$TimeoutTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel$2:void run()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void access$100(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void safeExecuteOutbound(java.lang.Runnable,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeDisconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeDeregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeClose(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeBind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeConnect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel$2:void run()",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$1:void run()",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$1:void run()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void safeExecuteOutbound(java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeWrite(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$2:void run()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannel$1:void run()",
            "io.netty.channel.epoll.EpollSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollSocketChannel$2:void run()"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void safeExecuteOutbound(java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeContinuationFrames(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpChannel$2:void run()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel$1:void run()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpChannel$1:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion)"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeBindNow(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$3:void run()"
        ]
    },
    "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.PeerAddressChangeNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.AssociationChangeNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.SendFailedNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$HeadersFrame:void send(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void access$000(io.netty.resolver.dns.DnsQueryContext,io.netty.handler.codec.dns.DnsQuery)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void sendQuery(io.netty.handler.codec.dns.DnsQuery)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void query()"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future access$201(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$2:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:void runTaskQueue()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void decrementAndRunTaskQueue()",
            "io.netty.channel.pool.FixedChannelPool:void access$1000(io.netty.channel.pool.FixedChannelPool)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,java.lang.Class,io.netty.resolver.dns.DnsServerAddresses)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Exception)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.embedded.EmbeddedChannel:boolean finish()",
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$800(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamLocal(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamRemote(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$BaseDecoder$1:boolean visit(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:boolean tryProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void progress(long)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture access$000(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void doGracefulShutdown(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])",
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void followCname(java.net.InetSocketAddress,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,java.util.Map,boolean)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void access$500(io.netty.resolver.dns.DnsNameResolverContext,java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void resolve()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAllUncached(java.lang.String,int,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:void doResolveUncached(java.lang.String,int,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$1:void run()",
            "io.netty.handler.ssl.SslHandler:void closeOutboundAndChannel(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$DefaultUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$100(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.embedded.EmbeddedChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.sctp.oio.OioSctpChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)",
            "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)",
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion,int)",
            "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$300(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$5:void run()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$400(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$6:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object,io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void release(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,int)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$100(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$3:void run()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess()"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void access$200(io.netty.resolver.dns.DnsQueryContext,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeWriteNow(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeDeregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeDeregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$14:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$WriteTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:void invokeWrite(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker:void invokeWrite(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$100(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$2:void run()",
            "io.netty.channel.socket.nio.NioSocketChannel$1:void run()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void send(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeContinuationFrames(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$2:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$3:void run()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)",
            "io.netty.channel.ChannelOutboundBuffer:boolean remove()",
            "io.netty.channel.ChannelOutboundBuffer:void addFlush()",
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)",
            "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void query()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$2:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$TimeoutTask:void run()"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void decrementAndRunTaskQueue()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void access$600(io.netty.channel.pool.FixedChannelPool)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void access$1000(io.netty.channel.pool.FixedChannelPool)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.MessageToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finish()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void cleanup()",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:void cleanup(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.embedded.EmbeddedChannel)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void cleanup(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)",
            "io.netty.handler.codec.http.HttpContentEncoder:void finishEncode(java.util.List)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamLocal(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void writeComplete()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamRemote(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$BaseDecoder$1:boolean visit(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams:io.netty.handler.codec.http2.Http2Stream forEachActiveStream(io.netty.handler.codec.http2.Http2StreamVisitor)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void progress(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)",
            "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion,int)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture access$000(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)",
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider)"
        ]
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,java.util.Map,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseAorAAAA(io.netty.handler.codec.dns.DnsRecordType,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope)",
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveAllUncached(java.lang.String,int,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveUncached(java.lang.String,int,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void closeOutboundAndChannel(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeDeregisterNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.epoll.IovArray,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,int)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$6:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void release(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean)",
            "io.netty.handler.codec.MessageToByteEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void send(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void addFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker$WriteTask:io.netty.channel.DefaultChannelHandlerInvoker$WriteTask newInstance(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void access$600(io.netty.channel.pool.FixedChannelPool)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void cleanup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:void cleanup(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.embedded.EmbeddedChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void cleanup(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void access$000(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener,io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void finishEncode(java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void writeComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams:io.netty.handler.codec.http2.Http2Stream forEachActiveStream(io.netty.handler.codec.http2.Http2StreamVisitor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2Connection:io.netty.handler.codec.http2.Http2Stream forEachActiveStream(io.netty.handler.codec.http2.Http2StreamVisitor)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponseAorAAAA(io.netty.handler.codec.dns.DnsRecordType,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.net.SocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.net.SocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.epoll.IovArray,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeDeregisterNow(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean)",
            "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.MessageToByteEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelHandlerInvokerUtil:void invokeWriteNow(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$WriteTask:io.netty.channel.DefaultChannelHandlerInvoker$WriteTask newInstance(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker$WriteTask:io.netty.channel.DefaultChannelHandlerInvoker$WriteTask access$000(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void access$000(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener,io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPushPromiseFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readContinuationFrame(io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2Connection:io.netty.handler.codec.http2.Http2Stream forEachActiveStream(io.netty.handler.codec.http2.Http2StreamVisitor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:boolean initialWindowSize(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer)",
            "io.netty.handler.codec.http2.PriorityStreamByteDistributor$WriteVisitor:void writeAllocatedBytes(io.netty.handler.codec.http2.StreamByteDistributor$Writer)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void initialWindowSize(int)",
            "io.netty.handler.codec.http2.DefaultHttp2Connection:void goAwaySent(int,long,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkAllWritabilityChanged()",
            "io.netty.handler.codec.http2.DefaultHttp2Connection:void goAwayReceived(int,long,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$BaseDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>(int)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.net.SocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.net.SocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ByteToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelHandlerInvoker$WriteTask:io.netty.channel.DefaultChannelHandlerInvoker$WriteTask access$000(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelHandlerInvoker:void invokeWrite(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPushPromiseFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readContinuationFrame(io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPushPromiseFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readContinuationFrame(io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettings(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:boolean initialWindowSize(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void initialWindowSize(int)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultWritabilityMonitor:void initialWindowSize(int)"
        ]
    },
    "io.netty.handler.codec.http2.PriorityStreamByteDistributor$WriteVisitor:void writeAllocatedBytes(io.netty.handler.codec.http2.StreamByteDistributor$Writer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.PriorityStreamByteDistributor:boolean distribute(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void localSettings(io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void applyLocalSettings(io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:void initialWindowSize(int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2Connection:void goAwaySent(int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkAllWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void channelWritabilityChange()",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void incrementWindowSize(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$AbstractState,int)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void initialWindowSize(int)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkConnectionThenStreamWritabilityChanged(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$AbstractState)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2Connection:void goAwayReceived(int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void onGoAwayRead0(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$BaseDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettings(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettingsHeader(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void initialWindowSize(int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultWritabilityMonitor:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void initialWindowSize(int)"
        ]
    },
    "io.netty.handler.codec.http2.PriorityStreamByteDistributor:boolean distribute(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:void writePendingBytes(io.netty.handler.codec.http2.StreamByteDistributor$Writer)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void localSettings(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void applyLocalSettings(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void channelWritabilityChange()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelWritabilityChanged()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void incrementWindowSize(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$AbstractState,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void incrementWindowSize(io.netty.handler.codec.http2.Http2Stream,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkConnectionThenStreamWritabilityChanged(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$AbstractState)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void enqueueFrame(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$AbstractState,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void stateCancelled(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$AbstractState)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void onGoAwayRead0(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettingsHeader(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:void prepareUpgradeResponse(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest,io.netty.handler.codec.http.FullHttpResponse)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:void writePendingBytes(io.netty.handler.codec.http2.StreamByteDistributor$Writer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:boolean initialWindowSize(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void writePendingBytes()",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultWritabilityMonitor:void writePendingBytes()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelHandlerContext(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void incrementWindowSize(io.netty.handler.codec.http2.Http2Stream,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void enqueueFrame(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$AbstractState,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void stateCancelled(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$AbstractState)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamHalfClosed(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamClosed(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:void prepareUpgradeResponse(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest,io.netty.handler.codec.http.FullHttpResponse)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onHttpServerUpgrade(io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DecoratingHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void writePendingBytes()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void writePendingBytes()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultWritabilityMonitor:void writePendingBytes()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void writePendingBytes()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelHandlerContext(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readWindowUpdateFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamHalfClosed(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamClosed(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onHttpServerUpgrade(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:void prepareUpgradeResponse(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest,io.netty.handler.codec.http.FullHttpResponse)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void writePendingBytes()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelHandlerContext(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readWindowUpdateFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readWindowUpdateFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readWindowUpdateFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onHttpServerUpgrade(io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DecoratingHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    }
}