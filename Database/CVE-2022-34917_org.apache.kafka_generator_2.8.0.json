{
    "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)": {
        "isVulRoot": true,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$4(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$6(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$null$4(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassReader$5(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysFalseCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$null$6(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassReader$5(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.VersionConditional:void generateAlwaysFalseCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.VersionConditional:void generate(org.apache.kafka.message.CodeBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassWriter$23(java.util.TreeMap,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthWriter$28(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.FieldType)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassReader$8(org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$26(org.apache.kafka.message.Versions,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.JsonConverterGenerator:void generateWrite(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassMessageSize$35(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthFieldSize$44(boolean,org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassWriter$17(org.apache.kafka.message.FieldSpec,java.util.TreeMap,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthArrayElementSize(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassReader$5(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.JsonConverterGenerator:void generateRead(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void generateClassMessageSize(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.JsonConverterGenerator:void lambda$generateWrite$14(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Target,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$15(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void generateClassReader(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthFieldSize$53(boolean,org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void generateClassWriter(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthWriter$31(org.apache.kafka.message.FieldType,java.lang.String,boolean,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.ApiMessageTypeGenerator:void generateHeaderVersion(java.lang.String)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassWriter$23(java.util.TreeMap,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthWriter$28(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.FieldType)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.IsNullConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassReader$8(org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$null$26(org.apache.kafka.message.Versions,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void generateWrite(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.JsonConverterGenerator:void generateConverters(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassMessageSize$35(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthFieldSize$44(boolean,org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.IsNullConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateClassWriter$17(org.apache.kafka.message.FieldSpec,java.util.TreeMap,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthArrayElementSize(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthFieldSize$53(boolean,org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void generateRead(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.JsonConverterGenerator:void generateConverters(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateClassMessageSize(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void generateClass(java.util.Optional,java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void lambda$generateWrite$14(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Target,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$null$15(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysFalseCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateClassReader(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void generateClass(java.util.Optional,java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthFieldSize$53(boolean,org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.IsNullConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateClassWriter(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void generateClass(java.util.Optional,java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthWriter$31(org.apache.kafka.message.FieldType,java.lang.String,boolean,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.IsNullConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.ApiMessageTypeGenerator:void generateHeaderVersion(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.ApiMessageTypeGenerator:void generate()"
        ]
    },
    "org.apache.kafka.message.IsNullConditional:void generate(org.apache.kafka.message.CodeBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void generateFieldDuplicate(org.apache.kafka.message.Target)",
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthFieldSize(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions,boolean)",
            "org.apache.kafka.message.JsonConverterGenerator:void generateTargetToJson(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$22(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.JsonConverterGenerator:void generateTargetFromJson(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthWriter(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,boolean)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void generateConverters(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.JsonConverterGenerator:void generateAndWrite(org.apache.kafka.message.MessageSpec,java.io.BufferedWriter)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateClass(java.util.Optional,java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void generateSubclasses(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions,boolean)",
            "org.apache.kafka.message.MessageDataGenerator:void generateClass(java.util.Optional,java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void generate(org.apache.kafka.message.MessageSpec)"
        ]
    },
    "org.apache.kafka.message.ApiMessageTypeGenerator:void generate()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.ApiMessageTypeGenerator:void generateAndWrite(java.io.BufferedWriter)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateFieldDuplicate(org.apache.kafka.message.Target)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateFieldDuplicate$62(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Target)",
            "org.apache.kafka.message.MessageDataGenerator:void generateClassDuplicate(java.lang.String,org.apache.kafka.message.StructSpec)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthFieldSize(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void generateFieldSize(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions,boolean)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void generateTargetToJson(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.JsonConverterGenerator:void lambda$null$13(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.JsonConverterGenerator:void lambda$null$12(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Target,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.JsonConverterGenerator:void generateVariableLengthTargetToJson(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$null$22(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void generateTargetFromJson(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.JsonConverterGenerator:void generateVariableLengthTargetFromJson(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.JsonConverterGenerator:void lambda$generateRead$4(org.apache.kafka.message.FieldSpec,java.lang.String,java.lang.String,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthWriter(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$20(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$14(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$generateVariableLengthWriter$31(org.apache.kafka.message.FieldType,java.lang.String,boolean,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void generateAndWrite(org.apache.kafka.message.MessageSpec,java.io.BufferedWriter)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateSubclasses(java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void generateClass(java.util.Optional,java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generate(org.apache.kafka.message.MessageSpec)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void generateAndWrite(org.apache.kafka.message.MessageSpec,java.io.BufferedWriter)"
        ]
    },
    "org.apache.kafka.message.ApiMessageTypeGenerator:void generateAndWrite(java.io.BufferedWriter)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$generateFieldDuplicate$62(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Target)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.IsNullConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateClassDuplicate(java.lang.String,org.apache.kafka.message.StructSpec)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void generateClass(java.util.Optional,java.lang.String,org.apache.kafka.message.StructSpec,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateFieldSize(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$34(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$33(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void lambda$null$13(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysFalseCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void lambda$null$12(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Target,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void generateVariableLengthTargetToJson(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.JsonConverterGenerator:void lambda$generateTargetToJson$18(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void generateVariableLengthTargetFromJson(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.JsonConverterGenerator:void lambda$generateTargetFromJson$8(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void lambda$generateRead$4(org.apache.kafka.message.FieldSpec,java.lang.String,java.lang.String,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$null$20(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.IsNullConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$null$14(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysFalseCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.MessageDataGenerator:void lambda$null$15(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void generateAndWrite(org.apache.kafka.message.MessageSpec,java.io.BufferedWriter)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$null$34(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysFalseCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.MessageDataGenerator:void lambda$null$33(org.apache.kafka.message.FieldSpec,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.VersionConditional:void generateFullRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateUpperRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateLowerRangeCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)",
            "org.apache.kafka.message.VersionConditional:void generateAlwaysTrueCheck(org.apache.kafka.message.Versions,org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void lambda$generateTargetToJson$18(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.IsNullConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    },
    "org.apache.kafka.message.JsonConverterGenerator:void lambda$generateTargetFromJson$8(org.apache.kafka.message.Target,org.apache.kafka.message.Versions)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.message.MessageDataGenerator:void generateVariableLengthReader(org.apache.kafka.message.Versions,java.lang.String,org.apache.kafka.message.FieldType,org.apache.kafka.message.Versions,org.apache.kafka.message.Versions,java.lang.String,java.lang.String,boolean,boolean)"
        ],
        "vulCaller": [
            "org.apache.kafka.message.IsNullConditional:void generate(org.apache.kafka.message.CodeBuffer)"
        ]
    }
}