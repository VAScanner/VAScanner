{
    "org.apache.hadoop.mapreduce.JobSubmitter:org.apache.hadoop.mapreduce.JobStatus submitJobInternal(org.apache.hadoop.mapreduce.Job,org.apache.hadoop.mapreduce.Cluster)": {
        "isVulRoot": true,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.JobSubmitter:org.apache.hadoop.mapreduce.JobStatus submitJobInternal(org.apache.hadoop.mapreduce.Job,org.apache.hadoop.mapreduce.Cluster)"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.Job$10:org.apache.hadoop.mapreduce.JobStatus run()"
        ]
    },
    "org.apache.hadoop.mapreduce.Job$10:org.apache.hadoop.mapreduce.JobStatus run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.JobSubmitter:org.apache.hadoop.mapreduce.JobStatus submitJobInternal(org.apache.hadoop.mapreduce.Job,org.apache.hadoop.mapreduce.Cluster)"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.Job$10:java.lang.Object run()"
        ]
    },
    "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()": {
        "isVulRoot": true,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.CryptoUtils:java.io.InputStream wrapIfNecessary(org.apache.hadoop.conf.Configuration,java.io.InputStream,long)",
            "org.apache.hadoop.mapreduce.CryptoUtils:org.apache.hadoop.fs.FSDataInputStream wrapIfNecessary(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FSDataInputStream)",
            "org.apache.hadoop.mapreduce.CryptoUtils:org.apache.hadoop.fs.FSDataOutputStream wrapIfNecessary(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FSDataOutputStream)"
        ]
    },
    "org.apache.hadoop.mapreduce.CryptoUtils:java.io.InputStream wrapIfNecessary(org.apache.hadoop.conf.Configuration,java.io.InputStream,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.Fetcher:org.apache.hadoop.mapreduce.TaskAttemptID[] copyMapOutput(org.apache.hadoop.mapreduce.task.reduce.MapHost,java.io.DataInputStream,java.util.Set,boolean)"
        ]
    },
    "org.apache.hadoop.mapreduce.CryptoUtils:org.apache.hadoop.fs.FSDataInputStream wrapIfNecessary(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FSDataInputStream)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:boolean copyMapOutput(org.apache.hadoop.mapreduce.TaskAttemptID)",
            "org.apache.hadoop.mapred.Merger$Segment:void init(org.apache.hadoop.mapred.Counters$Counter)"
        ]
    },
    "org.apache.hadoop.mapreduce.CryptoUtils:org.apache.hadoop.fs.FSDataOutputStream wrapIfNecessary(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FSDataOutputStream)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void spillSingleRecord(java.lang.Object,java.lang.Object,int)",
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl$InMemoryMerger:void merge(java.util.List)",
            "org.apache.hadoop.mapred.BackupStore$FileCache:org.apache.hadoop.mapred.IFile$Writer createSpillFile()",
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl:org.apache.hadoop.mapred.RawKeyValueIterator finalMerge(org.apache.hadoop.mapred.JobConf,org.apache.hadoop.fs.FileSystem,java.util.List,java.util.List)",
            "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void sortAndSpill()",
            "org.apache.hadoop.mapred.Merger$MergeQueue:org.apache.hadoop.mapred.RawKeyValueIterator merge(java.lang.Class,java.lang.Class,int,int,org.apache.hadoop.fs.Path,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)",
            "org.apache.hadoop.mapreduce.task.reduce.OnDiskMapOutput:void <init>(org.apache.hadoop.mapreduce.TaskAttemptID,org.apache.hadoop.mapreduce.TaskAttemptID,org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl,long,org.apache.hadoop.mapred.JobConf,org.apache.hadoop.mapred.MapOutputFile,int,boolean,org.apache.hadoop.fs.FileSystem,org.apache.hadoop.fs.Path)",
            "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void mergeParts()",
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl$OnDiskMerger:void merge(java.util.List)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:boolean copyMapOutput(org.apache.hadoop.mapreduce.TaskAttemptID)": {
        "isVulRoot": true,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:boolean copyMapOutput(org.apache.hadoop.mapreduce.TaskAttemptID)",
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:void doCopy(java.util.Set)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:void doCopy(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:boolean copyMapOutput(org.apache.hadoop.mapreduce.TaskAttemptID)",
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:void run()"
        ]
    },
    "org.apache.hadoop.mapred.Task:void readFields(java.io.DataInput)": {
        "isVulRoot": true,
        "srcRoot": [
            "org.apache.hadoop.mapred.Task:void readFields(java.io.DataInput)"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.JvmTask:void readFields(java.io.DataInput)",
            "org.apache.hadoop.mapred.ReduceTask:void readFields(java.io.DataInput)",
            "org.apache.hadoop.mapred.MapTask:void readFields(java.io.DataInput)"
        ]
    },
    "org.apache.hadoop.mapred.JvmTask:void readFields(java.io.DataInput)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapred.Task:void readFields(java.io.DataInput)"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.ReduceTask:void readFields(java.io.DataInput)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapred.Task:void readFields(java.io.DataInput)"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.JvmTask:void readFields(java.io.DataInput)"
        ]
    },
    "org.apache.hadoop.mapred.MapTask:void readFields(java.io.DataInput)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapred.Task:void readFields(java.io.DataInput)"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.JvmTask:void readFields(java.io.DataInput)"
        ]
    },
    "org.apache.hadoop.mapred.Task:void write(java.io.DataOutput)": {
        "isVulRoot": true,
        "srcRoot": [
            "org.apache.hadoop.mapred.Task:void write(java.io.DataOutput)"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.MapTask:void write(java.io.DataOutput)",
            "org.apache.hadoop.mapred.ReduceTask:void write(java.io.DataOutput)",
            "org.apache.hadoop.mapred.JvmTask:void write(java.io.DataOutput)"
        ]
    },
    "org.apache.hadoop.mapred.MapTask:void write(java.io.DataOutput)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapred.Task:void write(java.io.DataOutput)"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.JvmTask:void write(java.io.DataOutput)"
        ]
    },
    "org.apache.hadoop.mapred.ReduceTask:void write(java.io.DataOutput)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapred.Task:void write(java.io.DataOutput)"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.JvmTask:void write(java.io.DataOutput)"
        ]
    },
    "org.apache.hadoop.mapred.JvmTask:void write(java.io.DataOutput)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapred.Task:void write(java.io.DataOutput)"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapreduce.Job$10:java.lang.Object run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.JobSubmitter:org.apache.hadoop.mapreduce.JobStatus submitJobInternal(org.apache.hadoop.mapreduce.Job,org.apache.hadoop.mapreduce.Cluster)"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapreduce.task.reduce.Fetcher:org.apache.hadoop.mapreduce.TaskAttemptID[] copyMapOutput(org.apache.hadoop.mapreduce.task.reduce.MapHost,java.io.DataInputStream,java.util.Set,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.Fetcher:void copyFromHost(org.apache.hadoop.mapreduce.task.reduce.MapHost)"
        ]
    },
    "org.apache.hadoop.mapred.Merger$Segment:void init(org.apache.hadoop.mapred.Counters$Counter)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.Merger$Segment:void reinitReader(int)"
        ]
    },
    "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void spillSingleRecord(java.lang.Object,java.lang.Object,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void collect(java.lang.Object,java.lang.Object,int)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl$InMemoryMerger:void merge(java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.BackupStore$FileCache:org.apache.hadoop.mapred.IFile$Writer createSpillFile()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.BackupStore$FileCache:void activate()",
            "org.apache.hadoop.mapred.BackupStore$FileCache:void write(org.apache.hadoop.io.DataInputBuffer,org.apache.hadoop.io.DataInputBuffer)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl:org.apache.hadoop.mapred.RawKeyValueIterator finalMerge(org.apache.hadoop.mapred.JobConf,org.apache.hadoop.fs.FileSystem,java.util.List,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl:org.apache.hadoop.mapred.RawKeyValueIterator close()"
        ]
    },
    "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void sortAndSpill()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void access$900(org.apache.hadoop.mapred.MapTask$MapOutputBuffer)",
            "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void flush()"
        ]
    },
    "org.apache.hadoop.mapred.Merger$MergeQueue:org.apache.hadoop.mapred.RawKeyValueIterator merge(java.lang.Class,java.lang.Class,int,int,org.apache.hadoop.fs.Path,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,java.util.List,int,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,boolean,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)",
            "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,org.apache.hadoop.io.compress.CompressionCodec,java.util.List,int,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,boolean,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)",
            "org.apache.hadoop.mapred.Merger$MergeQueue:org.apache.hadoop.mapred.RawKeyValueIterator merge(java.lang.Class,java.lang.Class,int,org.apache.hadoop.fs.Path,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.OnDiskMapOutput:void <init>(org.apache.hadoop.mapreduce.TaskAttemptID,org.apache.hadoop.mapreduce.TaskAttemptID,org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl,long,org.apache.hadoop.mapred.JobConf,org.apache.hadoop.mapred.MapOutputFile,int,boolean,org.apache.hadoop.fs.FileSystem,org.apache.hadoop.fs.Path)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.OnDiskMapOutput:void <init>(org.apache.hadoop.mapreduce.TaskAttemptID,org.apache.hadoop.mapreduce.TaskAttemptID,org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl,long,org.apache.hadoop.mapred.JobConf,org.apache.hadoop.mapred.MapOutputFile,int,boolean)"
        ]
    },
    "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void mergeParts()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void flush()"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl$OnDiskMerger:void merge(java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:boolean copyMapOutput(org.apache.hadoop.mapreduce.TaskAttemptID)",
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapreduce.task.reduce.Fetcher:void copyFromHost(org.apache.hadoop.mapreduce.task.reduce.MapHost)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.Fetcher:void run()"
        ]
    },
    "org.apache.hadoop.mapred.Merger$Segment:void reinitReader(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void collect(java.lang.Object,java.lang.Object,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.BackupStore$FileCache:void activate()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.BackupStore:java.io.DataOutputStream getOutputStream(int)",
            "org.apache.hadoop.mapred.BackupStore:void write(org.apache.hadoop.io.DataInputBuffer,org.apache.hadoop.io.DataInputBuffer)"
        ]
    },
    "org.apache.hadoop.mapred.BackupStore$FileCache:void write(org.apache.hadoop.io.DataInputBuffer,org.apache.hadoop.io.DataInputBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.BackupStore:void write(org.apache.hadoop.io.DataInputBuffer,org.apache.hadoop.io.DataInputBuffer)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl:org.apache.hadoop.mapred.RawKeyValueIterator close()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.Shuffle:org.apache.hadoop.mapred.RawKeyValueIterator run()"
        ]
    },
    "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void access$900(org.apache.hadoop.mapred.MapTask$MapOutputBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.MapTask$MapOutputBuffer$SpillThread:void run()"
        ]
    },
    "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,java.util.List,int,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,boolean,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,org.apache.hadoop.io.compress.CompressionCodec,java.util.List,int,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,boolean,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl:org.apache.hadoop.mapred.RawKeyValueIterator finalMerge(org.apache.hadoop.mapred.JobConf,org.apache.hadoop.fs.FileSystem,java.util.List,java.util.List)"
        ]
    },
    "org.apache.hadoop.mapred.Merger$MergeQueue:org.apache.hadoop.mapred.RawKeyValueIterator merge(java.lang.Class,java.lang.Class,int,org.apache.hadoop.fs.Path,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,org.apache.hadoop.io.compress.CompressionCodec,java.util.List,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,boolean,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress,org.apache.hadoop.mapreduce.TaskType)",
            "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,java.util.List,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,boolean,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)",
            "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,org.apache.hadoop.io.compress.CompressionCodec,org.apache.hadoop.fs.Path[],boolean,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)",
            "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,org.apache.hadoop.io.compress.CompressionCodec,org.apache.hadoop.fs.Path[],boolean,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.OnDiskMapOutput:void <init>(org.apache.hadoop.mapreduce.TaskAttemptID,org.apache.hadoop.mapreduce.TaskAttemptID,org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl,long,org.apache.hadoop.mapred.JobConf,org.apache.hadoop.mapred.MapOutputFile,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl:org.apache.hadoop.mapreduce.task.reduce.MapOutput reserve(org.apache.hadoop.mapreduce.TaskAttemptID,long,int)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.Fetcher:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.BackupStore:java.io.DataOutputStream getOutputStream(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.ReduceContextImpl$ValueIterator:void mark()"
        ]
    },
    "org.apache.hadoop.mapred.BackupStore:void write(org.apache.hadoop.io.DataInputBuffer,org.apache.hadoop.io.DataInputBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.ReduceContextImpl:boolean nextKeyValue()"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.Shuffle:org.apache.hadoop.mapred.RawKeyValueIterator run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.MapTask$MapOutputBuffer$SpillThread:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,org.apache.hadoop.io.compress.CompressionCodec,java.util.List,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,boolean,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress,org.apache.hadoop.mapreduce.TaskType)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.MapTask$MapOutputBuffer:void mergeParts()"
        ]
    },
    "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,java.util.List,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,boolean,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,java.util.List,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)"
        ]
    },
    "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,org.apache.hadoop.io.compress.CompressionCodec,org.apache.hadoop.fs.Path[],boolean,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,org.apache.hadoop.io.compress.CompressionCodec,org.apache.hadoop.fs.Path[],boolean,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl$OnDiskMerger:void merge(java.util.List)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl:org.apache.hadoop.mapreduce.task.reduce.MapOutput reserve(org.apache.hadoop.mapreduce.TaskAttemptID,long,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.LocalFetcher:boolean copyMapOutput(org.apache.hadoop.mapreduce.TaskAttemptID)",
            "org.apache.hadoop.mapreduce.task.reduce.Fetcher:org.apache.hadoop.mapreduce.TaskAttemptID[] copyMapOutput(org.apache.hadoop.mapreduce.task.reduce.MapHost,java.io.DataInputStream,java.util.Set,boolean)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.ReduceContextImpl$ValueIterator:void mark()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapreduce.task.ReduceContextImpl:boolean nextKeyValue()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.ReduceContextImpl$ValueIterator:java.lang.Object next()",
            "org.apache.hadoop.mapreduce.lib.reduce.WrappedReducer$Context:boolean nextKeyValue()",
            "org.apache.hadoop.mapreduce.task.ReduceContextImpl:boolean nextKey()"
        ]
    },
    "org.apache.hadoop.mapred.Merger:org.apache.hadoop.mapred.RawKeyValueIterator merge(org.apache.hadoop.conf.Configuration,org.apache.hadoop.fs.FileSystem,java.lang.Class,java.lang.Class,java.util.List,int,org.apache.hadoop.fs.Path,org.apache.hadoop.io.RawComparator,org.apache.hadoop.util.Progressable,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.mapred.Counters$Counter,org.apache.hadoop.util.Progress)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl$InMemoryMerger:void merge(java.util.List)",
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl:org.apache.hadoop.mapred.RawKeyValueIterator finalMerge(org.apache.hadoop.mapred.JobConf,org.apache.hadoop.fs.FileSystem,java.util.List,java.util.List)",
            "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl$IntermediateMemoryToMemoryMerger:void merge(java.util.List)"
        ]
    },
    "org.apache.hadoop.mapreduce.task.ReduceContextImpl$ValueIterator:java.lang.Object next()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.Reducer:void reduce(java.lang.Object,java.lang.Iterable,org.apache.hadoop.mapreduce.Reducer$Context)"
        ]
    },
    "org.apache.hadoop.mapreduce.lib.reduce.WrappedReducer$Context:boolean nextKeyValue()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapreduce.task.ReduceContextImpl:boolean nextKey()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.lib.reduce.WrappedReducer$Context:boolean nextKey()"
        ]
    },
    "org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl$IntermediateMemoryToMemoryMerger:void merge(java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    },
    "org.apache.hadoop.mapreduce.Reducer:void reduce(java.lang.Object,java.lang.Iterable,org.apache.hadoop.mapreduce.Reducer$Context)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.Reducer:void run(org.apache.hadoop.mapreduce.Reducer$Context)"
        ]
    },
    "org.apache.hadoop.mapreduce.lib.reduce.WrappedReducer$Context:boolean nextKey()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.Reducer:void run(org.apache.hadoop.mapreduce.Reducer$Context)"
        ]
    },
    "org.apache.hadoop.mapreduce.Reducer:void run(org.apache.hadoop.mapreduce.Reducer$Context)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": [
            "org.apache.hadoop.mapreduce.lib.chain.Chain$ReduceRunner:void run()"
        ]
    },
    "org.apache.hadoop.mapreduce.lib.chain.Chain$ReduceRunner:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.hadoop.mapreduce.CryptoUtils:byte[] getEncryptionKey()"
        ],
        "vulCaller": []
    }
}