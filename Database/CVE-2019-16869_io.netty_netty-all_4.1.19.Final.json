{
    "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)": {
        "isVulRoot": true,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.LastHttpContent readTrailingHeaders(io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.HttpObjectDecoder$State readHeaders(io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.LastHttpContent readTrailingHeaders(io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.HttpObjectDecoder$State readHeaders(io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http.HttpServerCodec$HttpServerRequestDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeRemovalReentryProtection(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpClientCodec$Decoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeRemovalReentryProtection(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpServerCodec$HttpServerRequestDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeRemovalReentryProtection(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void decodeRemovalReentryProtection(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ReplayingDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ReplayingDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ReplayingDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void sendPreface(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.handler.codec.ByteToMessageCodec:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.memcache.binary.AbstractBinaryMemcacheDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$7:void run()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void sendPreface(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void <init>(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void sendPreface(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$500(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$300(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()"
        ]
    },
    "io.netty.handler.codec.memcache.binary.AbstractBinaryMemcacheDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.memcache.binary.BinaryMemcacheClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CodecOutputList,int)",
            "io.netty.handler.codec.MessageToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2Frame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Frame)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.ssl.SslHandler:int unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.kqueue.AbstractKQueueServerChannel$KQueueServerSocketUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.KQueueDatagramChannel$KQueueDatagramChannelUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReadyFd()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void doRead0(io.netty.handler.codec.http2.Http2Frame,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.local.LocalServerChannel:void doBeginRead()",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.local.LocalChannel$1:void run()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void <init>(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$500(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$6:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$300(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$4:void run()"
        ]
    },
    "io.netty.handler.codec.memcache.binary.BinaryMemcacheClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CodecOutputList,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.MessageToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.MessageToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageCodec:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeRemovalReentryProtection(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CodecOutputList,int)",
            "io.netty.handler.codec.MessageToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2Frame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Frame)",
            "io.netty.handler.ssl.SslHandler:int unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2Frame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Frame)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtensionHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.HttpServerKeepAliveHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.websocketx.extensions.WebSocketServerExtensionHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.HttpServerExpectContinueHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.websocketx.Utf8FrameValidator:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:int unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decodeNonJdkCompatible(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.ssl.SslHandler:void decodeJdkCompatible(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.ssl.SslHandler:void unwrapNonAppData(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioChannel$1:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueServerChannel$KQueueServerSocketUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel$KQueueDatagramChannelUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void access$300(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalServerChannel:void access$000(io.netty.channel.local.LocalServerChannel,io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$1:void run()",
            "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReadyFd()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void doRead0(io.netty.handler.codec.http2.Http2Frame,io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void beginRead()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.handler.codec.http2.Http2MultiplexCodec$ReadState fireChildRead(io.netty.handler.codec.http2.Http2Frame)"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void doRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioChannel$1:void run()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)"
        ]
    },
    "io.netty.channel.local.LocalChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void handlerAdded(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void shutdownInput(boolean)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fireEventAndClose(java.lang.Object)",
            "io.netty.handler.codec.http.HttpObjectAggregator:java.lang.Object continueResponse(io.netty.handler.codec.http.HttpMessage,int,io.netty.channel.ChannelPipeline)",
            "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.sctp.SctpNotificationHandler:void fireEvent(com.sun.nio.sctp.Notification)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeOutboundBufferForShutdown(io.netty.channel.ChannelPipeline,io.netty.channel.ChannelOutboundBuffer,java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput(boolean)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fireEventAndClose(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2StreamStateChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void onUpgradeEvent(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpServerUpgradeHandler$UpgradeEvent)",
            "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2StreamWritabilityChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream,boolean)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelInactive()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelInactive()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ByteToMessageCodec:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void access$000(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void access$400(io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void onGoAwayRead0(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void onUnknownFrame0(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void handle(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.Http2FrameListener,io.netty.handler.codec.http.FullHttpMessage)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void handle(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.Http2FrameListener,io.netty.handler.codec.http.FullHttpMessage)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtensionHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpServerKeepAliveHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.WebSocketServerExtensionHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpServerExpectContinueHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.Utf8FrameValidator:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void decodeNonJdkCompatible(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void decodeJdkCompatible(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void unwrapNonAppData(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeysPlain(java.util.Set)",
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeysOptimized()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void beginRead()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void access$300(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel$5:void run()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.local.LocalChannel:void doClose()"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void access$000(io.netty.channel.local.LocalServerChannel,io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalServerChannel$2:void run()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$1:void run()"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void beginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.handler.codec.http2.Http2MultiplexCodec$ReadState fireChildRead(io.netty.handler.codec.http2.Http2Frame)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamFrame(io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel,io.netty.handler.codec.http2.Http2StreamFrame)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$200(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void shutdownInput(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void readEOF()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fireEventAndClose(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void shutdownInput(boolean)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectAggregator:java.lang.Object continueResponse(io.netty.handler.codec.http.HttpMessage,int,io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectAggregator:java.lang.Object newContinueResponse(io.netty.handler.codec.http.HttpMessage,int,io.netty.channel.ChannelPipeline)"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.channel.sctp.SctpNotificationHandler:void fireEvent(com.sun.nio.sctp.Notification)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.PeerAddressChangeNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.AssociationChangeNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.SendFailedNotification,java.lang.Object)"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeOutboundBufferForShutdown(io.netty.channel.ChannelPipeline,io.netty.channel.ChannelOutboundBuffer,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void shutdownOutput(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPipeline,io.netty.channel.ChannelOutboundBuffer,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fireEventAndClose(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput(boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2StreamStateChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void onStreamActive0(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.Http2FrameCodec$ConnectionListener:void onStreamHalfClosed(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.Http2FrameCodec$ConnectionListener:void onStreamClosed(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.DatagramPacketDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void onUpgradeEvent(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpServerUpgradeHandler$UpgradeEvent)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2StreamWritabilityChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$Http2RemoteFlowControllerListener:void writabilityChanged(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.spdy.SpdyHttpDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.MessageAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.handler.timeout.IdleStateHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelInactive()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void closeForcibly()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void access$300(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$6:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void run()",
            "io.netty.channel.DefaultChannelPipeline$7:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$000(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$3:void run()",
            "io.netty.channel.DefaultChannelPipeline$2:void run()",
            "io.netty.channel.DefaultChannelPipeline$7:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void run()",
            "io.netty.channel.DefaultChannelPipeline$5:void run()",
            "io.netty.channel.DefaultChannelPipeline$4:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void removeOutboundHandler()",
            "io.netty.channel.CombinedChannelDuplexHandler:void removeInboundHandler()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void access$400(io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext$1:void run()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readWindowUpdateFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void onGoAwayRead0(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void onUnknownFrame0(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void handle(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.Http2FrameListener,io.netty.handler.codec.http.FullHttpMessage)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeRemovalReentryProtection(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:int unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeysPlain(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeysOptimized()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void beginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$200(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.local.LocalChannel$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:void doShutdownOutput()",
            "io.netty.channel.local.LocalChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamFrame(io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel,io.netty.handler.codec.http2.Http2StreamFrame)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2Frame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Frame)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$200(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$3:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void readEOF()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpObjectAggregator:java.lang.Object newContinueResponse(io.netty.handler.codec.http.HttpMessage,int,io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectAggregator:java.lang.Object newContinueResponse(java.lang.Object,int,io.netty.channel.ChannelPipeline)"
        ]
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.PeerAddressChangeNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.AssociationChangeNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.SendFailedNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void shutdownOutput(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPipeline,io.netty.channel.ChannelOutboundBuffer,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4$1:void run()"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void onStreamActive0(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void access$900(io.netty.handler.codec.http2.Http2FrameCodec,io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$ConnectionListener:void onStreamHalfClosed(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$ConnectionListener:void onStreamClosed(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$Http2RemoteFlowControllerListener:void writabilityChanged(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void notifyWritabilityChanged(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)"
        ]
    },
    "io.netty.handler.codec.spdy.SpdyHttpDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.DatagramPacketDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()"
        ]
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void closeForcibly()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2FrameStreamException(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStreamException)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:void streamClosed()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void firstWriteComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void beginRead()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void registerDone(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void destroy()",
            "io.netty.channel.DefaultChannelPipeline:void access$200(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$300(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$9:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.ChannelInitializer:void remove(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpServerCodec:void upgradeFrom(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void removeOutboundHandler()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.HttpProxyHandler:void removeEncoder(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void removeInboundHandler()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.HttpProxyHandler:void removeDecoder(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readWindowUpdateFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readWindowUpdateFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readWindowUpdateFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readUnknownFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readUnknownFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void startHandshakeProcessing()",
            "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void access$900(io.netty.handler.ssl.SslHandler,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)",
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$NonNotifyRunnable:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1400(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$200(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void flush0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollOutReady()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void flush0()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void forceFlush()",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void writeReady()"
        ]
    },
    "io.netty.channel.AbstractChannel:void doShutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void shutdownOutput(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void run()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void registerDone(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$900(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2Frame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Frame)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onPingAckRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelActive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelActive()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$3:void run()",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectAggregator:java.lang.Object newContinueResponse(java.lang.Object,int,io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageAggregator:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$2:void run()",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$3:void run()",
            "io.netty.channel.socket.nio.NioSocketChannel$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$4$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void access$900(io.netty.handler.codec.http2.Http2FrameCodec,io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$ConnectionListener:void onStreamActive(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListenersNow()",
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners0(io.netty.util.concurrent.DefaultFutureListeners)",
            "io.netty.util.concurrent.DefaultPromise:void access$100(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:void notifyListenerWithStackOverFlowProtection(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void notifyWritabilityChanged(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkConnectionThenStreamWritabilityChanged(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkStateWritability(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void access$1300(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor,io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1100(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2FrameStreamException(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStreamException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:void streamClosed()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamStateChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void firstWriteComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void access$1900(io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void registerDone(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void access$000(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamStateChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void destroy()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void access$700(io.netty.channel.DefaultChannelPipeline)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$200(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$8:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$9:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void invokeHandlerAddedIfNeeded()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void remove(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.HttpServerCodec:void upgradeFrom(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void setup(boolean,io.netty.channel.ChannelHandler[])",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$2:void initChannel(io.netty.channel.Channel)"
        ]
    },
    "io.netty.handler.proxy.HttpProxyHandler:void removeEncoder(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:boolean safeRemoveEncoder()"
        ]
    },
    "io.netty.handler.proxy.HttpProxyHandler:void removeDecoder(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:boolean safeRemoveDecoder()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onGoAwayRead(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onUnknownFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readUnknownFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readUnknownFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPushPromiseFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readContinuationFrame(io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void startHandshakeProcessing()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void access$900(io.netty.handler.ssl.SslHandler,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$3:void run()"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.util.concurrent.FastThreadLocalRunnable:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()"
        ]
    },
    "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:void doStartThread()",
            "io.netty.util.concurrent.DefaultPromise:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$NonNotifyRunnable:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageAggregator:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker read()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void readIfNeeded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1400(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$15:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void flush()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollOutReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void forceFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void writeReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void closeForcibly()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void registerDone(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$900(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.IdleStateHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.WebSocketClientProtocolHandshakeHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelActive()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void finishConnect()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void finishConnect()",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.MessageAggregator:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpClientUpgradeHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)",
            "io.netty.handler.codec.http.HttpServerUpgradeHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$ConnectionListener:void onStreamActive(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListenersNow()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners()",
            "io.netty.util.concurrent.DefaultPromise:void access$000(io.netty.util.concurrent.DefaultPromise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListeners0(io.netty.util.concurrent.DefaultFutureListeners)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListenersNow()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void access$100(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$2:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListenerWithStackOverFlowProtection(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkConnectionThenStreamWritabilityChanged(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void enqueueFrame(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void stateCancelled(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkStateWritability(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void incrementWindowSize(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState,int)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void windowSize(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void access$1300(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor,io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor$1:boolean visit(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener$1:void run()",
            "io.netty.handler.codec.compression.JdkZlibEncoder$3:void run()",
            "io.netty.handler.codec.compression.JZlibEncoder$3:void run()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1100(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$13:void run()",
            "io.netty.channel.AbstractChannelHandlerContext$12:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamStateChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void onStreamActive0(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.Http2FrameCodec$ConnectionListener:void onStreamHalfClosed(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.Http2FrameCodec$ConnectionListener:void onStreamClosed(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void access$1900(io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void access$000(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1200(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$700(io.netty.channel.DefaultChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void invokeHandlerAddedIfNeeded()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInitializer:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void setup(boolean,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,boolean,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelConfig,io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$2:void initChannel(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:boolean safeRemoveEncoder()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:boolean safeRemoveDecoder()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettings(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPushPromiseFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readContinuationFrame(io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPushPromiseFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readContinuationFrame(io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void doStartThread()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:void startThread()",
            "io.netty.util.concurrent.SingleThreadEventExecutor:void shutdown()",
            "io.netty.util.concurrent.SingleThreadEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners()",
            "io.netty.util.concurrent.DefaultPromise:void notifyListenerWithStackOverFlowProtection(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:void notifyProgressiveListeners(long,long)"
        ]
    },
    "io.netty.handler.codec.MessageAggregator:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker read()",
            "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void readIfNeeded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.handler.codec.spdy.SpdyFrameCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete0(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelOutboundInvoker read()",
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.DatagramPacketEncoder:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void readIfNeeded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)",
            "io.netty.handler.ssl.SslHandler:int unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$15:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamStateChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream)",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:void open0(io.netty.channel.ChannelHandlerContext,io.netty.util.concurrent.Promise)",
            "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void setup(boolean,io.netty.channel.ChannelHandler[])",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamStateChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream)",
            "io.netty.channel.embedded.EmbeddedChannel:void register()",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:void open0(io.netty.channel.ChannelHandlerContext,io.netty.util.concurrent.Promise)",
            "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$2:void run()",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fireEventAndClose(java.lang.Object)",
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput(boolean)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fireEventAndClose(java.lang.Object)",
            "io.netty.channel.local.LocalServerChannel$1:void run()",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$3:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.local.LocalChannel:void tryClose(boolean)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void clearReadFilter0()",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$2:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()",
            "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReadyFd()",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void shutdownInput(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$2:void run()",
            "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$3:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()"
        ]
    },
    "io.netty.handler.codec.http.websocketx.WebSocketClientProtocolHandshakeHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void finishConnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollOutReady()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()",
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void finishConnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void shutdownInput(boolean)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void writeReady()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.HttpClientUpgradeHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpClientUpgradeHandler:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpServerUpgradeHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpServerUpgradeHandler:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListeners()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:boolean trySuccess(java.lang.Object)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:boolean cancel(boolean)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.util.concurrent.DefaultPromise:boolean tryFailure(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void access$000(io.netty.util.concurrent.DefaultPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$1:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)",
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$NonNotifyRunnable:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void enqueueFrame(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void stateCancelled(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState:void cancel(java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void incrementWindowSize(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void incrementWindowSize(io.netty.handler.codec.http2.Http2Stream,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void windowSize(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamActive(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void <init>(io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.StreamByteDistributor,io.netty.handler.codec.http2.Http2RemoteFlowController$Listener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor$1:boolean visit(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams:io.netty.handler.codec.http2.Http2Stream forEachActiveStream(io.netty.handler.codec.http2.Http2StreamVisitor)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http.HttpObjectAggregator$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close()",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void fail(io.netty.channel.ChannelHandlerContext,java.lang.String,java.lang.Exception)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void processGoAwayWriteResult(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2GoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2GoAwayFrame)",
            "io.netty.handler.codec.http.HttpObjectAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpMessage)",
            "io.netty.handler.codec.http.HttpObjectAggregator$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener$1:void run()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.DatagramPacketEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$13:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$12:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.DatagramPacketEncoder:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec$1:boolean visit(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1200(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$12:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,boolean,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,boolean,io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelConfig,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:io.netty.channel.embedded.EmbeddedChannel newContentDecompressor(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)",
            "io.netty.handler.codec.http.HttpContentCompressor:io.netty.handler.codec.http.HttpContentEncoder$Result beginEncode(io.netty.handler.codec.http.HttpResponse,java.lang.String)",
            "io.netty.handler.codec.http.HttpContentDecompressor:io.netty.channel.embedded.EmbeddedChannel newContentDecoder(java.lang.String)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressionChannel(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.compression.ZlibWrapper)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void access$100(io.netty.handler.proxy.ProxyHandler,java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.proxy.ProxyHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.DecoratingHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettings(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettingsHeader(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void startThread()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void shutdown()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyProgressiveListeners(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:boolean tryProgress(long,long)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$700(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.spdy.SpdyFrameCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete0(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelOutboundInvoker read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.Channel read()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelOutboundInvoker read()",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void readIfIsAutoRead()",
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture register()",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:void open0(io.netty.channel.ChannelHandlerContext,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap$1:void run()",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:io.netty.util.concurrent.Future open(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:void register()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$300(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.local.LocalServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void tryClose(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void access$200(io.netty.channel.local.LocalChannel,boolean)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void clearReadFilter0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$2:void run()",
            "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReadyFd()",
            "io.netty.channel.kqueue.AbstractKQueueServerChannel$KQueueServerSocketUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.KQueueDatagramChannel$KQueueDatagramChannelUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.AbstractKQueueChannel:void clearReadFilter()",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void readReadyFinally(io.netty.channel.ChannelConfig)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()",
            "io.netty.channel.epoll.AbstractEpollChannel$2:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.local.LocalChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1000(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()"
        ]
    },
    "io.netty.util.concurrent.ScheduledFutureTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()"
        ]
    },
    "io.netty.handler.codec.http.HttpClientUpgradeHandler:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpServerUpgradeHandler:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.DatagramPacketDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.channel.socket.DatagramPacket,java.util.List)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdown()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean trySuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:void shutdown()",
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:java.util.List shutdownNow()",
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess(java.lang.Void)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.DefaultChannelPromise:boolean trySuccess()",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:void shutdown()",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()",
            "io.netty.resolver.dns.DnsNameResolver$ListResolverContext:boolean finishResolve(java.lang.Class,java.util.List,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object)",
            "io.netty.handler.ssl.SslHandler:void notifyClosePromise(java.lang.Throwable)",
            "io.netty.util.concurrent.PromiseTask:boolean trySuccessInternal(java.lang.Object)",
            "io.netty.handler.ssl.SslHandler:void setHandshakeSuccess()",
            "io.netty.util.internal.PromiseNotificationUtil:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.resolver.dns.InflightNameResolver:void transferResult(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.channel.DefaultChannelProgressivePromise:boolean trySuccess()",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()",
            "io.netty.channel.ThreadPerChannelEventLoopGroup$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.pool.FixedChannelPool$AcquireTask:void <init>(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void applyHandshakeTimeout(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler$8:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void doSearchDomainQuery(java.lang.String,io.netty.util.concurrent.FutureListener)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean cancel(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean cancel(boolean)",
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancelWithoutRemove(boolean)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.internal.PromiseNotificationUtil:void tryCancel(io.netty.util.concurrent.Promise,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.RoundRobinInetAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void setSuccess0()",
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)",
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.InetSocketAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setSuccessInternal(java.lang.Object)",
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.util.concurrent.MultithreadEventExecutorGroup$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.resolver.DefaultNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.RoundRobinInetAddressResolver$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)",
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)",
            "io.netty.resolver.DefaultNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$2:void run()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.proxy.ProxyHandler:void failPendingWritesAndClose(java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void notifyClosePromise(java.lang.Throwable)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioChannel:void doClose()",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.resolver.dns.InflightNameResolver:void transferResult(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean tryFailure(java.lang.Throwable)",
            "io.netty.channel.local.LocalChannel:void doClose()",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$2:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel:void doClose()",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)",
            "io.netty.util.concurrent.PromiseTask:boolean tryFailureInternal(java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.SingleThreadEventExecutor:void shutdown()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void notifyHandshakeFailure(java.lang.Throwable,boolean)",
            "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.SingleThreadEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)",
            "io.netty.resolver.dns.DnsNameResolver:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setFailureInternal(java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:void open0(io.netty.channel.ChannelHandlerContext,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.channel.ChannelPromise,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:io.netty.util.concurrent.Future open(io.netty.util.concurrent.Promise)",
            "io.netty.resolver.RoundRobinInetAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void setFailure0(io.netty.channel.group.ChannelGroupException)",
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.resolver.InetSocketAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.DefaultNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.resolver.RoundRobinInetAddressResolver$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.resolver.DefaultNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)",
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$NonNotifyRunnable:void run()"
        ]
    },
    "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState:void cancel(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState:void cancel()",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState:int writeAllocatedBytes(int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void incrementWindowSize(io.netty.handler.codec.http2.Http2Stream,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onWindowUpdateRead(io.netty.channel.ChannelHandlerContext,int,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamActive(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void <init>(io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.StreamByteDistributor,io.netty.handler.codec.http2.Http2RemoteFlowController$Listener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void <init>(io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.Http2RemoteFlowController$Listener)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void <init>(io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.StreamByteDistributor)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams:io.netty.handler.codec.http2.Http2Stream forEachActiveStream(io.netty.handler.codec.http2.Http2StreamVisitor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2Connection:io.netty.handler.codec.http2.Http2Stream forEachActiveStream(io.netty.handler.codec.http2.Http2StreamVisitor)"
        ]
    },
    "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectAggregator$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectAggregator$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectAggregator$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void fail(io.netty.channel.ChannelHandlerContext,java.lang.String,java.lang.Exception)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void processGoAwayWriteResult(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2GoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2GoAwayFrame)",
            "io.netty.handler.codec.http.HttpObjectAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpMessage)",
            "io.netty.handler.codec.http.HttpObjectAggregator$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void fail(io.netty.channel.ChannelHandlerContext,java.lang.String,java.lang.Exception)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,java.lang.String)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void processGoAwayWriteResult(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$1100(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2GoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2GoAwayFrame)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2Frame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Frame)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpMessage)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectAggregator$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectAggregator$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture close()",
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void checkCloseConnection(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void writeHeaders(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2ConnectionEncoder,int,io.netty.handler.codec.http.HttpHeaders,io.netty.handler.codec.http2.Http2Headers,boolean,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()",
            "io.netty.handler.codec.http2.Http2FrameCodec:void tryExpandConnectionFlowControlWindow(io.netty.handler.codec.http2.Http2Connection)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$1:boolean visit(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams:io.netty.handler.codec.http2.Http2Stream forEachActiveStream(io.netty.handler.codec.http2.Http2StreamVisitor)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$100(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$000(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,boolean,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:io.netty.channel.embedded.EmbeddedChannel newContentDecompressor(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void initDecompressor(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,boolean)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentCompressor:io.netty.handler.codec.http.HttpContentEncoder$Result beginEncode(io.netty.handler.codec.http.HttpResponse,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentDecompressor:io.netty.channel.embedded.EmbeddedChannel newContentDecoder(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressionChannel(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.compression.ZlibWrapper)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newContentCompressor(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void access$100(io.netty.handler.proxy.ProxyHandler,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler$2:void run()",
            "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DecoratingHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettingsHeader(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:boolean prepareUpgradeResponse(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest,io.netty.handler.codec.http.HttpHeaders)"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void execute(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.nio.AbstractNioChannel:void clearReadPending()",
            "io.netty.channel.nio.AbstractNioChannel:void setReadPending(boolean)",
            "io.netty.channel.local.LocalChannel:void runFinishPeerReadTask(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()",
            "io.netty.channel.oio.AbstractOioChannel:void setReadPending(boolean)",
            "io.netty.util.concurrent.DefaultPromise:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.nio.NioEventLoop:void rebuildSelector()",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.util.concurrent.SingleThreadEventExecutor:void removeShutdownHook(java.lang.Runnable)",
            "io.netty.channel.local.LocalChannel:void doClose()",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void addToSpliceQueue(io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInTask)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.epoll.AbstractEpollChannel:void doClose()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundBuffer:void close(java.lang.Throwable,boolean)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void executeEpollInReadyRunnable(io.netty.channel.ChannelConfig)",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:io.netty.util.concurrent.Future open(io.netty.util.concurrent.Promise)",
            "io.netty.channel.nio.AbstractNioByteChannel:void incompleteWrite(boolean)",
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void executeReadReadyRunnable(io.netty.channel.ChannelConfig)",
            "io.netty.channel.oio.AbstractOioChannel:void doBeginRead()",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.kqueue.AbstractKQueueChannel:void doClose()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(io.netty.util.concurrent.ScheduledFutureTask)",
            "io.netty.channel.pool.FixedChannelPool:void close()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.bootstrap.Bootstrap:void doConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.SingleThreadEventExecutor:void addShutdownHook(java.lang.Runnable)",
            "io.netty.channel.oio.AbstractOioChannel:void clearReadPending()",
            "io.netty.bootstrap.AbstractBootstrap:void doBind0(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueChannel:void clearReadFilter()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:void removeScheduled(io.netty.util.concurrent.ScheduledFutureTask)",
            "io.netty.channel.local.LocalChannel:void doRegister()",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.SingleThreadEventExecutor:void doStartThread()",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.AbstractEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:boolean tryProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$700(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$8:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.Channel read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void readIfIsAutoRead()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelOutboundInvoker read()",
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelOutboundInvoker read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void readIfIsAutoRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.sctp.SctpServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.rxtx.RxtxChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)",
            "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.sctp.SctpChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:int unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture register()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsCache,io.netty.resolver.dns.DnsCache,io.netty.resolver.dns.DnsQueryLifecycleObserverFactory,long,io.netty.resolver.ResolvedAddressTypes,boolean,int,boolean,int,boolean,io.netty.resolver.HostsFileEntriesResolver,io.netty.resolver.dns.DnsServerAddressStreamProvider,java.lang.String[],int,boolean)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind()",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect()"
        ]
    },
    "io.netty.handler.codec.http2.Http2StreamChannelBootstrap$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:io.netty.util.concurrent.Future open(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:io.netty.util.concurrent.Future open()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$1500(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$300(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void access$200(io.netty.channel.local.LocalChannel,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel$4:void run()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel:void clearReadFilter()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void readReadyFinally(io.netty.channel.ChannelConfig)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReadyFd()",
            "io.netty.channel.kqueue.AbstractKQueueServerChannel$KQueueServerSocketUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.KQueueDatagramChannel$KQueueDatagramChannelUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollInFinally(io.netty.channel.ChannelConfig)",
            "io.netty.channel.epoll.EpollChannelConfig:void autoReadCleared()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput(boolean)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1000(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$11:void run()"
        ]
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.channel.socket.DatagramPacket,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.DatagramPacketDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:java.util.List shutdownNow()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess(java.lang.Object)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$000(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseCombiner:void finish(io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean access$400(io.netty.util.concurrent.PromiseCombiner)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:boolean trySuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess()",
            "io.netty.channel.AbstractChannel$CloseFuture:boolean setClosed()",
            "io.netty.channel.local.LocalChannel$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetSuccess(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver$ListResolverContext:boolean finishResolve(java.lang.Class,java.util.List,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise,java.lang.Throwable)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:boolean doResolveCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.dns.DnsNameResolver:boolean doResolveAllCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.dns.DnsNameResolver:void access$400(io.netty.util.concurrent.Promise,java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void notifyClosePromise(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:int unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:boolean trySuccessInternal(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:boolean setHandshakeSuccessIfStillHandshaking()",
            "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:int unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)"
        ]
    },
    "io.netty.util.internal.PromiseNotificationUtil:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object,io.netty.util.internal.logging.InternalLogger)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.ChannelOutboundBuffer:void safeSuccess(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void finish(io.netty.channel.AddressedEnvelope)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:void transferResult(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)",
            "io.netty.resolver.dns.InflightNameResolver:void access$000(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnaryPromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:boolean trySuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess()"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Void)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:void access$300(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$AcquireTask:void <init>(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolveAll(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.bootstrap.Bootstrap$3:void run()",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractCoalescingBufferQueue:io.netty.buffer.ByteBuf remove(io.netty.buffer.ByteBufAllocator,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise unvoid()",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.channel.AbstractCoalescingBufferQueue:io.netty.buffer.ByteBuf removeFirst(io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void applyHandshakeTimeout(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void startHandshakeProcessing()",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler$8:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$8:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void doSearchDomainQuery(java.lang.String,io.netty.util.concurrent.FutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void resolve(io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void access$100(io.netty.resolver.dns.DnsNameResolverContext,java.lang.String,io.netty.util.concurrent.FutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.EventLoop nextChild()",
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])",
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.AddressResolverGroup:io.netty.resolver.AddressResolver getResolver(io.netty.util.concurrent.EventExecutor)",
            "io.netty.resolver.dns.DnsQueryContext:void sendQuery(io.netty.handler.codec.dns.DnsQuery,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:boolean cancel(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean cancel(boolean)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.internal.PromiseNotificationUtil:void tryCancel(io.netty.util.concurrent.Promise,io.netty.util.internal.logging.InternalLogger)"
        ]
    },
    "io.netty.util.concurrent.ScheduledFutureTask:boolean cancelWithoutRemove(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.internal.PromiseNotificationUtil:void tryCancel(io.netty.util.concurrent.Promise,io.netty.util.internal.logging.InternalLogger)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2StreamChannelBootstrap$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void finishConnect()",
            "io.netty.channel.nio.AbstractNioChannel:void doClose()",
            "io.netty.resolver.dns.DefaultDnsCache$DefaultDnsCacheEntry:void cancelExpiration()",
            "io.netty.channel.epoll.AbstractEpollChannel:void doClose()",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$3:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe$3:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void finishConnect()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$200(io.netty.channel.pool.SimpleChannelPool,io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.RoundRobinInetAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void setSuccess0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void access$400(io.netty.channel.group.DefaultChannelGroupFuture)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Map,io.netty.util.concurrent.EventExecutor)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Collection,io.netty.util.concurrent.EventExecutor)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setSuccessInternal(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.DefaultNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.RoundRobinInetAddressResolver$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$400(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.resolver.DefaultNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture access$000(io.netty.bootstrap.Bootstrap,io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void failPendingWritesAndClose(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractServerChannel$DefaultServerUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:boolean ensureOpen(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$200(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void doClose()",
            "io.netty.channel.AbstractChannel:void doShutdownOutput()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean tryFailure(java.lang.Throwable)",
            "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()",
            "io.netty.channel.AbstractChannel:void doShutdownOutput()",
            "io.netty.channel.epoll.EpollServerDomainSocketChannel:void doClose()",
            "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()",
            "io.netty.channel.epoll.AbstractEpollChannel:boolean doConnect0(java.net.SocketAddress)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:void doClose()"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void access$300(io.netty.resolver.dns.DnsQueryContext,java.lang.String,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsQueryContext:void onQueryWriteCompletion(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:boolean tryFailureInternal(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void notifyHandshakeFailure(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean,boolean)",
            "io.netty.handler.ssl.SslHandler:void access$1100(io.netty.handler.ssl.SslHandler,java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.AbstractChannelHandlerContext:void notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundBuffer:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:boolean doResolveCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.dns.DnsNameResolver:boolean doResolveAllCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setFailureInternal(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.channel.ChannelPromise,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)"
        ]
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)",
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void setFailure0(io.netty.channel.group.ChannelGroupException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void access$300(io.netty.channel.group.DefaultChannelGroupFuture,io.netty.channel.group.ChannelGroupException)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$TimeoutTask:void run()"
        ]
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)",
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void firstWriteComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void shutdownOutput(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractCoalescingBufferQueue:io.netty.buffer.ByteBuf remove(io.netty.buffer.ByteBufAllocator,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeWindowUpdate(int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)",
            "io.netty.bootstrap.AbstractBootstrap$2:void run()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void writeComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void run()",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void deregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void notifyHeaderWritePromise(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable)"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void access$100(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState:void cancel()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamHalfClosed(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamClosed(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState:int writeAllocatedBytes(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor$1:void write(io.netty.handler.codec.http2.Http2Stream,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void <init>(io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.Http2RemoteFlowController$Listener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void <init>(io.netty.handler.codec.http2.Http2Connection)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void <init>(io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.StreamByteDistributor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2Connection:io.netty.handler.codec.http2.Http2Stream forEachActiveStream(io.netty.handler.codec.http2.Http2StreamVisitor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void initialWindowSize(int)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void forEachActiveStream(io.netty.handler.codec.http2.Http2FrameStreamVisitor)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:void initialWindowSize(int)",
            "io.netty.handler.codec.http2.DefaultHttp2Connection:void goAwaySent(int,long,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkAllWritabilityChanged()",
            "io.netty.handler.codec.http2.DefaultHttp2Connection:void goAwayReceived(int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void notifyHandlerException(java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$400(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectAggregator$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeRemovalReentryProtection(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$1100(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$4:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2GoAwayFrame,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageAggregator:void invokeHandleOversizedMessage(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectAggregator$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void registerDone(io.netty.channel.ChannelFuture)",
            "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void runFinishPeerReadTask(io.netty.channel.local.LocalChannel)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)",
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void registerDone(io.netty.channel.ChannelFuture)",
            "io.netty.channel.local.LocalChannel:void doClose()",
            "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)",
            "io.netty.resolver.dns.DnsNameResolver:void close()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void checkCloseConnection(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$800(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeRemovalReentryProtection(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void writeHeaders(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2ConnectionEncoder,int,io.netty.handler.codec.http.HttpHeaders,io.netty.handler.codec.http2.Http2Headers,boolean,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void handleServerHeaderDecodeSizeError(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void flush0(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void tryExpandConnectionFlowControlWindow(io.netty.handler.codec.http2.Http2Connection)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1900(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$100(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$2:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$000(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$1:void run()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId)",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void initDecompressor(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newContentCompressor(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressor(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Headers,boolean)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:boolean prepareUpgradeResponse(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest,io.netty.handler.codec.http.HttpHeaders)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.AbstractNioChannel:void clearReadPending()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:void access$100(io.netty.channel.sctp.nio.NioSctpServerChannel)",
            "io.netty.channel.socket.nio.NioSocketChannel:void access$600(io.netty.channel.socket.nio.NioSocketChannel)",
            "io.netty.channel.sctp.nio.NioSctpChannel:void access$100(io.netty.channel.sctp.nio.NioSctpChannel)",
            "io.netty.channel.socket.nio.NioDatagramChannel:void clearReadPending0()",
            "io.netty.channel.socket.nio.NioServerSocketChannel:void access$100(io.netty.channel.socket.nio.NioServerSocketChannel)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:void setReadPending(boolean)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void runFinishPeerReadTask(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioServerSocketChannel:void setReadPending(boolean)",
            "io.netty.channel.socket.oio.OioSocketChannel:void setReadPending(boolean)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel$2:void run()"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void rebuildSelector()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void select(boolean)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel$2:void run()",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void removeShutdownHook(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doDeregister()",
            "io.netty.channel.local.LocalServerChannel:void doDeregister()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)",
            "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void addToSpliceQueue(io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownInput()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void close(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void close(java.nio.channels.ClosedChannelException)",
            "io.netty.channel.ChannelOutboundBuffer$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeOutboundBufferForShutdown(io.netty.channel.ChannelPipeline,io.netty.channel.ChannelOutboundBuffer,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void executeEpollInReadyRunnable(io.netty.channel.ChannelConfig)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollInFinally(io.netty.channel.ChannelConfig)",
            "io.netty.channel.epoll.AbstractEpollChannel:void doBeginRead()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel:void incompleteWrite(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpChannel$2:void run()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void executeReadReadyRunnable(io.netty.channel.ChannelConfig)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel:void doBeginRead()",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void readReadyFinally(io.netty.channel.ChannelConfig)"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:void doClose()",
            "io.netty.channel.kqueue.KQueueServerDomainSocketChannel:void doClose()",
            "io.netty.channel.kqueue.AbstractKQueueChannel:boolean doConnect0(java.net.SocketAddress)",
            "io.netty.channel.AbstractChannel:void doShutdownOutput()",
            "io.netty.channel.kqueue.AbstractKQueueChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(io.netty.util.concurrent.ScheduledFutureTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$1:void run()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.bootstrap.Bootstrap:void doConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap:void access$100(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel$1:void run()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void addShutdownHook(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doRegister()",
            "io.netty.channel.local.LocalServerChannel:void doRegister()"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel:void clearReadPending()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel:void access$100(io.netty.channel.sctp.oio.OioSctpServerChannel)",
            "io.netty.channel.sctp.oio.OioSctpChannel:void access$100(io.netty.channel.sctp.oio.OioSctpChannel)",
            "io.netty.channel.socket.oio.OioServerSocketChannel:void clearReadPending0()",
            "io.netty.channel.socket.oio.OioSocketChannel:void clearReadPending0()"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:void doBind0(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:void access$000(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput()"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$2:void run()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$1100(io.netty.channel.AbstractChannel$AbstractUnsafe,java.lang.Runnable)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput()"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:void removeScheduled(io.netty.util.concurrent.ScheduledFutureTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor$3:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doRegister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpChannel$1:void run()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])",
            "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void beginRead()",
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.kqueue.AbstractKQueueServerChannel$KQueueServerSocketUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.KQueueDatagramChannel$KQueueDatagramChannelUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReadyFd()",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.local.LocalServerChannel:void doBeginRead()",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture flushInbound(boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.local.LocalChannel$1:void run()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:void fireChildReadComplete()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageAggregator:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelOutboundInvoker read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()"
        ]
    },
    "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.udt.DefaultUdtChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.sctp.DefaultSctpChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.kqueue.KQueueChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.DefaultChannelConfig:boolean setOptions(java.util.Map)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.sctp.SctpServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtServerChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioDatagramChannelConfig:io.netty.channel.socket.oio.OioDatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.rxtx.RxtxChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollDatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollDomainSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.oio.OioServerSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.kqueue.KQueueChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueDatagramChannelConfig:io.netty.channel.kqueue.KQueueDatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueSocketChannelConfig:io.netty.channel.kqueue.KQueueSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueServerChannelConfig:io.netty.channel.kqueue.KQueueServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:io.netty.channel.kqueue.KQueueDomainSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.sctp.SctpChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.oio.OioSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void handleUnwrapThrowable(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsCache,io.netty.resolver.dns.DnsCache,io.netty.resolver.dns.DnsQueryLifecycleObserverFactory,long,io.netty.resolver.ResolvedAddressTypes,boolean,int,boolean,int,boolean,io.netty.resolver.HostsFileEntriesResolver,io.netty.resolver.dns.DnsServerAddressStreamProvider,java.lang.String[],int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverBuilder:io.netty.resolver.dns.DnsNameResolver build()"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.InetAddress,int)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(int)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.lang.String,int)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.InetAddress,int)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.lang.String,int)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.channel.ChannelFuture connectChannel(io.netty.bootstrap.Bootstrap)"
        ]
    },
    "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:io.netty.util.concurrent.Future open()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1500(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$16:void run()",
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void forceFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker flush()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollInFinally(io.netty.channel.ChannelConfig)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.DatagramPacketEncoder:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$11:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.internal.PromiseNotificationUtil:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess(java.lang.Void)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$000(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:void finish(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:boolean access$400(io.netty.util.concurrent.PromiseCombiner)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseCombiner$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess()"
        ]
    },
    "io.netty.channel.AbstractChannel$CloseFuture:boolean setClosed()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetSuccess(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$100(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:boolean doResolveCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:boolean doResolveAllCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void access$400(io.netty.util.concurrent.Promise,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver$SingleResolverContext:boolean finishResolve(java.lang.Class,java.util.List,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:boolean setHandshakeSuccessIfStillHandshaking()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:int unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void safeSuccess(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove()"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void finish(io.netty.channel.AddressedEnvelope)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.InflightNameResolver:void access$000(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.UnaryPromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean tryFailure(java.lang.Throwable)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void access$300(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$3:void run()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String)",
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.bootstrap.Bootstrap$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:io.netty.buffer.ByteBuf remove(io.netty.buffer.ByteBufAllocator,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.CoalescingBufferQueue:io.netty.buffer.ByteBuf remove(int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void sendPreface(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()",
            "io.netty.bootstrap.AbstractBootstrap$2:void run()",
            "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http.HttpServerUpgradeHandler:boolean upgrade(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamStateChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.handler.codec.compression.JZlibEncoder$1:void run()",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)",
            "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2StreamChannelBootstrap:void open0(io.netty.channel.ChannelHandlerContext,io.netty.util.concurrent.Promise)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http.HttpObjectAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpMessage)",
            "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsCache,io.netty.resolver.dns.DnsCache,io.netty.resolver.dns.DnsQueryLifecycleObserverFactory,long,io.netty.resolver.ResolvedAddressTypes,boolean,int,boolean,int,boolean,io.netty.resolver.HostsFileEntriesResolver,io.netty.resolver.dns.DnsServerAddressStreamProvider,java.lang.String[],int,boolean)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.MessageAggregator:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void doGracefulShutdown(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise unvoid()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise unvoid()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:io.netty.buffer.ByteBuf removeFirst(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler$8:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void resolve(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAllUncached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.dns.DnsNameResolver:void doResolveUncached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void access$100(io.netty.resolver.dns.DnsNameResolverContext,java.lang.String,io.netty.util.concurrent.FutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.EventLoop nextChild()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.SocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:boolean handleRedirect(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void followCname(java.lang.String,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.AddressResolverGroup:io.netty.resolver.AddressResolver getResolver(io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void sendQuery(io.netty.handler.codec.dns.DnsQuery,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void query(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.SocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2StreamChannelBootstrap$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.DefaultDnsCache$DefaultDnsCacheEntry:void cancelExpiration()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$200(io.netty.channel.pool.SimpleChannelPool,io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void access$300(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void access$400(io.netty.channel.group.DefaultChannelGroupFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Map,io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher,boolean)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher,boolean)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close(io.netty.channel.group.ChannelMatcher)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Collection,io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise doneAllocatingPromises()",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void firstWriteComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeWindowUpdate(int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void shutdownOutput(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void writeComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void run()",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setSuccess()",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void deregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void notifyHeaderWritePromise(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$400(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$6:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess()",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture access$000(io.netty.bootstrap.Bootstrap,io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$3:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractServerChannel$DefaultServerUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:boolean ensureOpen(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$200(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future access$201(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire()",
            "io.netty.channel.pool.FixedChannelPool:void runTaskQueue()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()",
            "io.netty.channel.epoll.AbstractEpollChannel:boolean doConnect0(java.net.SocketAddress)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollServerDomainSocketChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:void doShutdownOutput()",
            "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:boolean doConnect0(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:void doShutdownOutput()",
            "io.netty.channel.epoll.AbstractEpollChannel:boolean doConnect0(java.net.SocketAddress)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void access$300(io.netty.resolver.dns.DnsQueryContext,java.lang.String,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$4:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void onQueryWriteCompletion(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void access$200(io.netty.resolver.dns.DnsQueryContext,io.netty.channel.ChannelFuture)",
            "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void access$1100(io.netty.handler.ssl.SslHandler,java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$5:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)",
            "io.netty.channel.ChannelOutboundBuffer:void close(java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable)"
        ]
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void access$300(io.netty.channel.group.DefaultChannelGroupFuture,io.netty.channel.group.ChannelGroupException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$TimeoutTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.channel.ChannelPromise,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder$HeadersFrame:void send(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void writeHeaders(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2ConnectionEncoder,int,io.netty.handler.codec.http.HttpHeaders,io.netty.handler.codec.http2.Http2Headers,boolean,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void access$300(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:void access$300(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void access$200(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$300(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:void access$000(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownInput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$100(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void access$100(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushOutbound()",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel:void checkException()",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture flushInbound(boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void send(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownInput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void access$000(io.netty.channel.kqueue.AbstractKQueueStreamChannel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void writeWindowUpdate(int,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void release(java.lang.Throwable)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void writeComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void access$2000(io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState:void writeWindowUpdate()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void sendPreface(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.channel.ChannelPromise,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void notifyHeaderWritePromise(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void access$700(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void access$100(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState:void writeWindowUpdate()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamLocal(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void processRstStreamWriteResult(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamRemote(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$100(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$3:void run()"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:io.netty.channel.ChannelFuture write0(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamHalfClosed(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1:void onStreamClosed(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor$1:void write(io.netty.handler.codec.http2.Http2Stream,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State:void write(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void <init>(io.netty.handler.codec.http2.Http2Connection)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:void <init>(io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.Http2FrameWriter)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void increaseInitialConnectionWindow(int)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void applyLocalSettings(io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:void initialWindowSize(int)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void forEachActiveStream(io.netty.handler.codec.http2.Http2FrameStreamVisitor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2GoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2GoAwayFrame)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void initialWindowSize(int)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void initialWindowSize(int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2Connection:void goAwaySent(int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkAllWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void channelWritabilityChange()",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkConnectionThenStreamWritabilityChanged(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void checkStateWritability(io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void initialWindowSize(int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2Connection:void goAwayReceived(int,long,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void onGoAwayRead0(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void notifyHandlerException(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$400(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$5:void run()"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$4:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Exception)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void writeGoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2GoAwayFrame,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.MessageAggregator:void invokeHandleOversizedMessage(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageAggregator:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:void close()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http.HttpServerUpgradeHandler$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void registerDone(io.netty.channel.ChannelFuture)",
            "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.embedded.EmbeddedChannel:boolean finish(boolean)",
            "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$800(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void handleServerHeaderDecodeSizeError(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void flush0(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onChannelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void flush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$800(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1900(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void deregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()",
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>()"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageCodec$1:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressor(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Headers,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:void access$100(io.netty.channel.sctp.nio.NioSctpServerChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel$NioSctpServerChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$600(io.netty.channel.socket.nio.NioSocketChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:void access$100(io.netty.channel.sctp.nio.NioSctpChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$NioSctpChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:void clearReadPending0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.nio.NioServerSocketChannel:void access$100(io.netty.channel.socket.nio.NioServerSocketChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioServerSocketChannel$NioServerSocketChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioServerSocketChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoop:void select(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doDeregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void doDeregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void close(java.nio.channels.ClosedChannelException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$6$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel:boolean doConnect0(java.net.SocketAddress)",
            "io.netty.channel.AbstractChannel:void doShutdownOutput()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.KQueueServerDomainSocketChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:void doShutdownOutput()",
            "io.netty.channel.kqueue.AbstractKQueueChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel:boolean doConnect0(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void <init>(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,long,java.util.concurrent.TimeUnit)",
            "io.netty.resolver.dns.DnsQueryContext:void onQueryWriteCompletion(io.netty.channel.ChannelFuture)",
            "io.netty.resolver.dns.DefaultDnsCache$DefaultDnsCacheEntry:void scheduleExpiration(io.netty.channel.EventLoop,java.lang.Runnable,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.handler.codec.MessageAggregator$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2FrameStreamException(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStreamException)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2GoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2GoAwayFrame)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)",
            "io.netty.handler.codec.MessageAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.kqueue.AbstractKQueueServerChannel$KQueueServerSocketUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.KQueueDatagramChannel$KQueueDatagramChannelUnsafe:void readReady(io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$1:void run()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$9:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$1:void run()",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void clearReadFilter0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()",
            "io.netty.channel.kqueue.KQueueDomainSocketChannel$KQueueDomainUnsafe:void readReadyFd()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2FrameStreamException(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStreamException)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void doRead0(io.netty.handler.codec.http2.Http2Frame,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$KQueueStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.kqueue.KQueueRecvByteAllocatorHandle)",
            "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.bootstrap.Bootstrap:void access$100(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalServerChannel:void doRegister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:void access$100(io.netty.channel.sctp.oio.OioSctpServerChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel$OioSctpServerChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:void access$100(io.netty.channel.sctp.oio.OioSctpChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel$OioSctpChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.oio.OioServerSocketChannel:void clearReadPending0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void clearReadPending0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:void access$000(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$1100(io.netty.channel.AbstractChannel$AbstractUnsafe,java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer$2:void run()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:void writabilityChanged(boolean)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])",
            "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)",
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture flushInbound(boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushInbound()"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:void fireChildReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamFrame(io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel,io.netty.handler.codec.http2.Http2StreamFrame)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onChannelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.kqueue.KQueueServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.kqueue.KQueueDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.kqueue.KQueueSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelConfig:boolean setOptions(java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioDatagramChannelConfig:io.netty.channel.socket.oio.OioDatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollDatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollDomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.oio.OioServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.kqueue.KQueueChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannelConfig:io.netty.channel.kqueue.KQueueDatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueDatagramChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.kqueue.KQueueSocketChannelConfig:io.netty.channel.kqueue.KQueueSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueSocketChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.kqueue.KQueueServerChannelConfig:io.netty.channel.kqueue.KQueueServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueServerChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.kqueue.KQueueServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueServerChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:io.netty.channel.kqueue.KQueueDomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.oio.OioSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void handleUnwrapThrowable(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decodeNonJdkCompatible(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.ssl.SslHandler:void decodeJdkCompatible(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverBuilder:io.netty.resolver.dns.DnsNameResolver build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.NameResolver newNameResolver(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddressStreamProvider)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.InetAddress,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.lang.String,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.InetAddress,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.lang.String,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.channel.ChannelFuture connectChannel(io.netty.bootstrap.Bootstrap)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.MessageToByteEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeContinuationFrames(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$16:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void forceFlush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void flushIfNeeded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()",
            "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketEncoder:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker flush()",
            "io.netty.handler.ssl.SslHandler:void forceFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.Channel flush()",
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelOutboundInvoker flush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$900(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$3:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$3:void run()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void writePendingWrites()"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.PromiseCombiner$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$100(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver$SingleResolverContext:boolean finishResolve(java.lang.Class,java.util.List,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.sctp.oio.OioSctpChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.nio.AbstractNioByteChannel:int doWriteInternal(io.netty.channel.ChannelOutboundBuffer,java.lang.Object)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeDefaultFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeDefaultFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.kqueue.KQueueDomainSocketChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.FileRegion)",
            "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.EpollDomainSocketChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.FileRegion)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)",
            "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.internal.PromiseNotificationUtil:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean trySuccess(java.lang.Void)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.DefaultChannelPromise:boolean trySuccess()",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CoalescingBufferQueue:io.netty.buffer.ByteBuf remove(int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void access$100(io.netty.channel.kqueue.AbstractKQueueStreamChannel,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void access$000(io.netty.resolver.dns.DnsQueryContext,io.netty.handler.codec.dns.DnsQuery,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsQueryContext:void sendQuery(io.netty.handler.codec.dns.DnsQuery,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.HttpServerUpgradeHandler:boolean upgrade(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpServerUpgradeHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void access$200(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void processRstStreamWriteResult(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeConnectionOnError(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$200(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutputDone(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:void access$200(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void doGracefulShutdown(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown()"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise unvoid()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise unvoid()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveAllUncached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveUncached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.SocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void query(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolverContext:void access$700(io.netty.resolver.dns.DnsNameResolverContext,io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolverContext:boolean query(java.lang.String,io.netty.handler.codec.dns.DnsRecordType,io.netty.resolver.dns.DnsServerAddressStream,io.netty.util.concurrent.Promise,java.lang.Throwable)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:boolean handleRedirect(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void followCname(java.lang.String,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,java.util.Map,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void query(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.channel.ChannelPromise,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.SocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.AbstractAddressResolver:io.netty.util.concurrent.Future resolve(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$300(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$5:void run()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close()"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void firstWriteComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeWindowUpdate(int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void writeComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeContinuationFrames(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void notifyHeaderWritePromise(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise doneAllocatingPromises()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setSuccess()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JdkZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$6:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess()"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future access$201(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$2:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:void runTaskQueue()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void decrementAndRunTaskQueue()",
            "io.netty.channel.pool.FixedChannelPool:void access$1000(io.netty.channel.pool.FixedChannelPool)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.FastThreadLocalRunnable:void run()",
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void access$200(io.netty.resolver.dns.DnsQueryContext,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$3:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void handleUnwrapThrowable(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void decodeJdkCompatible(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.ssl.SslHandler$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$1300(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)",
            "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.channel.ChannelPromise,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$HeadersFrame:void send(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void handleServerHeaderDecodeSizeError(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$300(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$4:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void access$300(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$4:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void access$200(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$5:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$300(io.netty.channel.ChannelFuture,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$7:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void access$000(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$1:void run()"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$100(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$5:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$4:void run()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder$1:void run()"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void access$100(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$2:void run()"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushOutbound()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void checkException()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])",
            "io.netty.channel.embedded.EmbeddedChannel:void ensureOpen()",
            "io.netty.channel.embedded.EmbeddedChannel:boolean finish(boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void send(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void access$000(io.netty.channel.kqueue.AbstractKQueueStreamChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$3:void run()"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void release(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void access$2000(io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState:void writeWindowUpdate()"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeWindowUpdate(io.netty.channel.ChannelHandlerContext,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState:void writeWindowUpdate()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState:void writeWindowUpdate()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState:boolean writeWindowUpdateIfNeeded()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void sendPreface(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.channel.ChannelPromise,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void access$700(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$100(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$2:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamLocal(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void writeComplete()",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void processRstStreamWriteResult(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$1000(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamRemote(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:io.netty.channel.ChannelFuture write0(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State:void write(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.WeightedFairQueueByteDistributor:int distribute(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer,io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:void <init>(io.netty.handler.codec.http2.Http2Connection,io.netty.handler.codec.http2.Http2FrameWriter)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void <init>(boolean,io.netty.handler.codec.http2.Http2FrameWriter,io.netty.handler.codec.http2.Http2FrameLogger,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2FrameCodecBuilder:io.netty.handler.codec.http2.Http2FrameCodec build()",
            "io.netty.handler.codec.http2.AbstractHttp2ConnectionHandlerBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler buildFromConnection(io.netty.handler.codec.http2.Http2Connection)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void increaseInitialConnectionWindow(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeWindowUpdate(int,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void applyLocalSettings(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void initialWindowSize(int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void initialWindowSize(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$ListenerWritabilityMonitor:void channelWritabilityChange()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelWritabilityChanged()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void close()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finish(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean finishAndReleaseAll()",
            "io.netty.channel.embedded.EmbeddedChannel:boolean finish()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void onChannelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void beginRead()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$800(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$9:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.traffic.AbstractTrafficShapingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.IdleStateHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageToMessageCodec$1:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$NioSctpServerChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$NioSctpChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.nio.NioServerSocketChannel$NioServerSocketChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)",
            "io.netty.channel.ChannelOutboundBuffer:boolean remove()",
            "io.netty.channel.ChannelOutboundBuffer:void addFlush()",
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)",
            "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$6$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.DatagramPacketEncoder:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.DatagramPacketEncoder:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDatagramChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.kqueue.KQueueDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void <init>(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void doGracefulShutdown(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DefaultDnsCache$DefaultDnsCacheEntry:void scheduleExpiration(io.netty.channel.EventLoop,java.lang.Runnable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DefaultDnsCache:void scheduleCacheExpiration(java.util.List,io.netty.resolver.dns.DefaultDnsCache$DefaultDnsCacheEntry,int,io.netty.channel.EventLoop)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.marshalling.CompatibleMarshallingDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.handler.codec.DatagramPacketDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.MessageAggregator$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageAggregator$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2FrameStreamException(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStreamException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void processRstStreamWriteResult(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeConnectionOnError(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageAggregator:void invokeHandleOversizedMessage(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.handler.codec.DatagramPacketEncoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$9:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise:void access$000(io.netty.channel.VoidChannelPromise,java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$OioSctpServerChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$OioSctpChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$1000(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:void writabilityChanged(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamWritabilityChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream,boolean)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void firstWriteComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.util.concurrent.RejectedExecutionHandler)",
            "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.Executor)",
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushInbound()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDatagramChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueSocketChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.KQueueSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueServerChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.kqueue.KQueueServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.kqueue.KQueueServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.kqueue.KQueueServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.KQueueServerChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDomainSocketChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void closeOutboundAndChannel(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,boolean)",
            "io.netty.handler.ssl.SslHandler:void access$600(io.netty.handler.ssl.SslHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.NameResolver newNameResolver(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddressStreamProvider)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.AddressResolver newResolver(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddressStreamProvider)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.MessageToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.MessageToByteEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.ByteToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeContinuationFrames(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void sendPreface(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeContinuationFrames(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.handler.codec.MessageAggregator:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.handler.codec.http.HttpObjectAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpMessage)",
            "io.netty.handler.codec.http.HttpServerUpgradeHandler:boolean upgrade(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest)",
            "io.netty.handler.codec.spdy.SpdyHttpDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.spdy.SpdyFrame,java.util.List)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flushIfNeeded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.Channel flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelOutboundInvoker flush()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelOutboundInvoker flush()",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$1:void run()",
            "io.netty.channel.embedded.EmbeddedChannel:void flushOutbound0()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$1:void run()",
            "io.netty.channel.nio.AbstractNioByteChannel$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelOutboundInvoker flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$900(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$10:void run()"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$3:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$3:void run()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void writePendingWrites()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.proxy.ProxyHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel:int doWriteInternal(io.netty.channel.ChannelOutboundBuffer,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel:int doWrite0(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeDefaultFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeDefaultFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.kqueue.KQueueDomainSocketChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.FileRegion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int doWriteMultiple(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,long)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int doWriteMultiple(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollChannel:int doWriteBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,long)",
            "io.netty.channel.kqueue.AbstractKQueueChannel:int doWriteBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.unix.IovArray)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.unix.IovArray)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.FileRegion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void access$100(io.netty.channel.kqueue.AbstractKQueueStreamChannel,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$4:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void access$000(io.netty.resolver.dns.DnsQueryContext,io.netty.handler.codec.dns.DnsQuery,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$200(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$3:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeConnectionOnError(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$900(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$200(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$6:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void access$200(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$3:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void access$700(io.netty.resolver.dns.DnsNameResolverContext,io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:boolean query(java.lang.String,io.netty.handler.codec.dns.DnsRecordType,io.netty.resolver.dns.DnsServerAddressStream,io.netty.util.concurrent.Promise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolverContext:void internalResolve(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,java.util.Map,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseAorAAAA(io.netty.handler.codec.dns.DnsRecordType,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.AbstractAddressResolver:io.netty.util.concurrent.Future resolve(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object,io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.channel.ChannelPromise,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JdkZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setSuccess()"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$2:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$TimeoutTask:void run()"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void decrementAndRunTaskQueue()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void access$600(io.netty.channel.pool.FixedChannelPool)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void access$1000(io.netty.channel.pool.FixedChannelPool)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1300(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$14:void run()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.kqueue.KQueueDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$6$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeOutboundBufferForShutdown(io.netty.channel.ChannelPipeline,io.netty.channel.ChannelOutboundBuffer,java.lang.Throwable)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$4:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel$4:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel$5:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$5:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$7:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$7:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void ensureOpen()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])",
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState:boolean writeWindowUpdateIfNeeded()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void incrementWindowSize(io.netty.handler.codec.http2.Http2Stream,int)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState:boolean consumeBytes(int)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void windowUpdateRatio(io.netty.handler.codec.http2.Http2Stream,float)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void writeComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$1000(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.WeightedFairQueueByteDistributor:int distribute(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer,io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.WeightedFairQueueByteDistributor:int distributeToChildren(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer,io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void <init>(boolean,io.netty.handler.codec.http2.Http2FrameWriter,io.netty.handler.codec.http2.Http2FrameLogger,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodecBuilder:io.netty.handler.codec.http2.Http2FrameCodec build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodecBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2ConnectionHandlerBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler buildFromConnection(io.netty.handler.codec.http2.Http2Connection)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.AbstractHttp2ConnectionHandlerBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DecoratingHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onHttpServerUpgrade(io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelHandlerContext(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.AddressResolverGroup$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finishAndReleaseAll()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void cleanup()",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void cleanup(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finish()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void cleanup()",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void cleanup()",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:void cleanup(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.embedded.EmbeddedChannel)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http.HttpContentEncoder:void finishEncode(java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$9:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.traffic.AbstractTrafficShapingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void addFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void decrementPendingOutboundBytes(long)",
            "io.netty.channel.PendingBytesTracker$ChannelOutboundBufferPendingBytesTracker:void decrementPendingOutboundBytes(long)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void incrementPendingOutboundBytes(long)",
            "io.netty.channel.PendingBytesTracker$ChannelOutboundBufferPendingBytesTracker:void incrementPendingOutboundBytes(long)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$2:void run()"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$2:void run()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueDatagramChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.KQueueDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueChannel$AbstractKQueueUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DefaultDnsCache:void scheduleCacheExpiration(java.util.List,io.netty.resolver.dns.DefaultDnsCache$DefaultDnsCacheEntry,int,io.netty.channel.EventLoop)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DefaultDnsCache:io.netty.resolver.dns.DnsCacheEntry cache(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],java.net.InetAddress,long,io.netty.channel.EventLoop)",
            "io.netty.resolver.dns.DefaultDnsCache:io.netty.resolver.dns.DnsCacheEntry cache(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],java.lang.Throwable,io.netty.channel.EventLoop)"
        ]
    },
    "io.netty.handler.codec.marshalling.CompatibleMarshallingDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)",
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.MessageAggregator$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void onHttp2FrameStreamException(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStreamException)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2GoAwayFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2GoAwayFrame)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()",
            "io.netty.handler.codec.memcache.binary.BinaryMemcacheClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.MessageAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.MessageAggregator$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.VoidChannelPromise:void access$000(io.netty.channel.VoidChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.channel.DelegatingChannelPromiseNotifier:boolean tryFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$1000(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$6$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1:void deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void onHttp2StreamWritabilityChanged(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$Http2RemoteFlowControllerListener:void writabilityChanged(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()"
        ]
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor)"
        ]
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.Executor)"
        ]
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.kqueue.KQueueChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.kqueue.KQueueServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void closeOutboundAndChannel(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void access$600(io.netty.handler.ssl.SslHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$1:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.AddressResolver newResolver(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddressStreamProvider)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.AddressResolver newResolver(io.netty.util.concurrent.EventExecutor)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageAggregator:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)",
            "io.netty.handler.codec.http.HttpObjectAggregator:void handleOversizedMessage(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpMessage)",
            "io.netty.handler.codec.http.HttpServerUpgradeHandler:boolean upgrade(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest)",
            "io.netty.handler.codec.spdy.SpdyHttpDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.spdy.SpdyFrame,java.util.List)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.spdy.SpdyHttpDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.spdy.SpdyFrame,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.spdy.SpdyHttpDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelOutboundInvoker flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelOutboundInvoker flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:void flushOutbound0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushOutbound()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.AbstractNioByteChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$10:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.AbstractNioByteChannel:int doWrite0(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueDomainSocketChannel:int doWriteSingle(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int doWriteMultiple(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int doWriteMultiple(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:int doWriteMultiple(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:int doWriteBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int doWriteMultiple(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueChannel:int doWriteBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:int writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.unix.IovArray)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:int doWriteMultiple(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.unix.IovArray)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel:int doWriteMultiple(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel$4:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.AbstractKQueueStreamChannel$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$900(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$6:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$6:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void internalResolve(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void resolve(io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void access$200(io.netty.resolver.dns.DnsNameResolverContext,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void doSearchDomainQuery(java.lang.String,io.netty.util.concurrent.FutureListener)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponseAorAAAA(io.netty.handler.codec.dns.DnsRecordType,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.resolver.dns.DnsServerAddressStream,int,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:void access$600(io.netty.channel.pool.FixedChannelPool)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$14:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel$5:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$7:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void incrementWindowSize(io.netty.handler.codec.http2.Http2Stream,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void increaseInitialConnectionWindow(int)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:void incrementWindowSize(io.netty.handler.codec.http2.Http2Stream,int)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void tryExpandConnectionFlowControlWindow(io.netty.handler.codec.http2.Http2Connection)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState:boolean consumeBytes(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void receiveFlowControlledFrame(io.netty.handler.codec.http2.Http2Stream,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$1:void onStreamClosed(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:boolean consumeBytes(io.netty.handler.codec.http2.Http2Stream,int)",
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$AutoRefillState:void receiveFlowControlledFrame(int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void windowUpdateRatio(io.netty.handler.codec.http2.Http2Stream,float)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.WeightedFairQueueByteDistributor:int distributeToChildren(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer,io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.WeightedFairQueueByteDistributor:int distribute(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer,io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State)",
            "io.netty.handler.codec.http2.WeightedFairQueueByteDistributor:boolean distribute(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodecBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.AbstractHttp2ConnectionHandlerBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandlerBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandlerBuilder:io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler build()",
            "io.netty.handler.codec.http2.Http2MultiplexCodecBuilder:io.netty.handler.codec.http2.Http2MultiplexCodec build()",
            "io.netty.handler.codec.http2.Http2FrameCodecBuilder:io.netty.handler.codec.http2.Http2FrameCodec build()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsAckRead(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onHttpServerUpgrade(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:void upgradeTo(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelHandlerContext(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.resolver.AddressResolverGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void cleanup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void cleanupSafely(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void cleanup(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void access$000(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void cleanup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void cleanup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:void cleanup(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.embedded.EmbeddedChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void finishEncode(java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void decrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingBytesTracker$DefaultChannelPipelinePendingBytesTracker:void decrementPendingOutboundBytes(long)",
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()"
        ]
    },
    "io.netty.channel.PendingBytesTracker$ChannelOutboundBufferPendingBytesTracker:void decrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractCoalescingBufferQueue:void decrementReadableBytes(int)",
            "io.netty.channel.PendingWriteQueue:void recycle(io.netty.channel.PendingWriteQueue$PendingWrite,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void incrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingBytesTracker$DefaultChannelPipelinePendingBytesTracker:void incrementPendingOutboundBytes(long)",
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void init(io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask,io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.PendingBytesTracker$ChannelOutboundBufferPendingBytesTracker:void incrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:void add(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractCoalescingBufferQueue:void incrementReadableBytes(int)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DefaultDnsCache:io.netty.resolver.dns.DnsCacheEntry cache(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],java.net.InetAddress,long,io.netty.channel.EventLoop)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseAorAAAA(io.netty.handler.codec.dns.DnsRecordType,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void addNameServerToCache(io.netty.resolver.dns.DnsNameResolverContext$AuthoritativeNameServer,java.net.InetAddress,long)"
        ]
    },
    "io.netty.resolver.dns.DefaultDnsCache:io.netty.resolver.dns.DnsCacheEntry cache(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],java.lang.Throwable,io.netty.channel.EventLoop)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void firstWriteComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeWindowUpdate(int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void shutdownOutput(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void deregister(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void writeComplete(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void run()",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DelegatingChannelPromiseNotifier:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettings(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void notifyHeaderWritePromise(io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.channel.ChannelPromise,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)",
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider)"
        ]
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.AddressResolver newResolver(io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.spdy.SpdyHttpDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.kqueue.AbstractKQueueStreamChannel$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$6:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void access$200(io.netty.resolver.dns.DnsNameResolverContext,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encodeFullResponse(io.netty.handler.codec.http.HttpResponse,io.netty.handler.codec.http.HttpContent,java.util.List)",
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:void incrementWindowSize(io.netty.handler.codec.http2.Http2Stream,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void receiveFlowControlledFrame(io.netty.handler.codec.http2.Http2Stream,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:void receiveFlowControlledFrame(io.netty.handler.codec.http2.Http2Stream,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$1:void onStreamClosed(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:boolean consumeBytes(io.netty.handler.codec.http2.Http2Stream,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:boolean consumeBytes(io.netty.handler.codec.http2.Http2Stream,int)",
            "io.netty.handler.codec.http2.Http2FrameCodec:boolean consumeBytes(int,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$AutoRefillState:void receiveFlowControlledFrame(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2LocalFlowController:void receiveFlowControlledFrame(io.netty.handler.codec.http2.Http2Stream,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.WeightedFairQueueByteDistributor:boolean distribute(int,io.netty.handler.codec.http2.StreamByteDistributor$Writer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:void writePendingBytes()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandlerBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandlerBuilder:io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandlerBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodecBuilder:io.netty.handler.codec.http2.Http2MultiplexCodec build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodecBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DecoratingHttp2ConnectionEncoder:void remoteSettings(io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onHttpServerUpgrade(io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:void upgradeTo(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void cleanupSafely(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void access$000(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.PendingBytesTracker$DefaultChannelPipelinePendingBytesTracker:void decrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractCoalescingBufferQueue:void decrementReadableBytes(int)",
            "io.netty.channel.PendingWriteQueue:void recycle(io.netty.channel.PendingWriteQueue$PendingWrite,boolean)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void decrementReadableBytes(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractCoalescingBufferQueue:void writeAndRemoveAll(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractCoalescingBufferQueue:io.netty.buffer.ByteBuf remove(io.netty.buffer.ByteBufAllocator,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractCoalescingBufferQueue:void releaseAndCompleteAll(io.netty.channel.ChannelFuture)",
            "io.netty.channel.AbstractCoalescingBufferQueue:io.netty.buffer.ByteBuf removeFirst(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:void recycle(io.netty.channel.PendingWriteQueue$PendingWrite,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:void removeAndFail(java.lang.Throwable)",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()",
            "io.netty.channel.PendingWriteQueue:void removeAndFailAll(java.lang.Throwable)",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWrite()",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelPromise remove()"
        ]
    },
    "io.netty.channel.PendingBytesTracker$DefaultChannelPipelinePendingBytesTracker:void incrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:void add(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractCoalescingBufferQueue:void incrementReadableBytes(int)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void init(io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask,io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:void add(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void addPendingWrite(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void incrementReadableBytes(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractCoalescingBufferQueue:void copyTo(io.netty.channel.AbstractCoalescingBufferQueue)",
            "io.netty.channel.AbstractCoalescingBufferQueue:void add(io.netty.buffer.ByteBuf,io.netty.channel.ChannelFutureListener)",
            "io.netty.channel.AbstractCoalescingBufferQueue:void addFirst(io.netty.buffer.ByteBuf,io.netty.channel.ChannelFutureListener)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void addNameServerToCache(io.netty.resolver.dns.DnsNameResolverContext$AuthoritativeNameServer,java.net.InetAddress,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:boolean handleRedirect(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.resolver.dns.DnsQueryLifecycleObserver,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>(int)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encodeFullResponse(io.netty.handler.codec.http.HttpResponse,io.netty.handler.codec.http.HttpContent,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:void receiveFlowControlledFrame(io.netty.handler.codec.http2.Http2Stream,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$ConsumedBytesConverter:boolean consumeBytes(io.netty.handler.codec.http2.Http2Stream,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:boolean consumeBytes(int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeWindowUpdate(int,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:boolean onBytesConsumed(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:void writePendingBytes()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor:void initialWindowSize(int)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void writePendingBytes()"
        ]
    },
    "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandlerBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodecBuilder:io.netty.handler.codec.http2.Http2ConnectionHandler build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void writeAndRemoveAll(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void releaseAndCompleteAll(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractCoalescingBufferQueue:void releaseAndFailAll(io.netty.channel.ChannelOutboundInvoker,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:void removeAndFail(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.PendingWriteQueue:void removeAndFailAll(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void failPendingWrites(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWrite()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelPromise remove()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask access$1700(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask access$1600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void addPendingWrite(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void copyTo(io.netty.channel.AbstractCoalescingBufferQueue)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void add(io.netty.buffer.ByteBuf,io.netty.channel.ChannelFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractCoalescingBufferQueue:void add(io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractCoalescingBufferQueue:void add(io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void addFirst(io.netty.buffer.ByteBuf,io.netty.channel.ChannelFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractCoalescingBufferQueue:void addFirst(io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:boolean onBytesConsumed(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2FrameStream,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$DefaultHttp2StreamChannel$Http2ChannelUnsafe:void doRead0(io.netty.handler.codec.http2.Http2Frame,io.netty.channel.RecvByteBufAllocator$Handle)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void writePendingBytes()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void channelHandlerContext(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void releaseAndFailAll(io.netty.channel.ChannelOutboundInvoker,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.CoalescingBufferQueue:void releaseAndFailAll(java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void releaseAndFailAll(java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void handlerRemoved0(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void failPendingWrites(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void failPendingWritesAndClose(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask access$1700(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask access$1600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void add(io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void <init>(io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder,io.netty.handler.codec.http2.Http2Stream,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void add(io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractCoalescingBufferQueue:void addFirst(io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CoalescingBufferQueue:void releaseAndFailAll(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void releaseAndFailAll(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean,boolean)",
            "io.netty.handler.ssl.SslHandler:void access$1200(io.netty.handler.ssl.SslHandler,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void handlerRemoved0(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void <init>(io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder,io.netty.handler.codec.http2.Http2Stream,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.kqueue.KQueueEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void access$1200(io.netty.handler.ssl.SslHandler,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$5:void run()"
        ]
    }
}