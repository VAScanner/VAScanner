{
    "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)": {
        "isVulRoot": true,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": true,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)": {
        "isVulRoot": true,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String,org.apache.kafka.common.requests.ProduceRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String,org.apache.kafka.common.requests.ProduceRequest$1)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void prepare()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void send(org.apache.kafka.clients.ClientRequest,long)",
            "org.apache.kafka.clients.NetworkClient:void sendInternalMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:void prepare()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.NetworkClient:void send(org.apache.kafka.clients.ClientRequest,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendTransactionalRequest(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean trySend(long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void sendInternalMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void access$600(org.apache.kafka.clients.NetworkClient,org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendTransactionalRequest(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean trySend(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.clients.ClientResponse sendAndAwaitInitProducerIdRequest(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void access$600(org.apache.kafka.clients.NetworkClient,org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()",
            "org.apache.kafka.clients.NetworkClientUtils:boolean isReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.Sender:void run(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void pollNoWakeup()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.clients.ClientResponse sendAndAwaitInitProducerIdRequest(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClientUtils:boolean isReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendTransactionalRequest(long)",
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.Node awaitLeastLoadedNodeReady(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void pollNoWakeup()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void maybeLeaveGroup()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean poll(org.apache.kafka.clients.consumer.internals.RequestFuture,long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollOnce(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.Node awaitLeastLoadedNodeReady(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendTransactionalRequest(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doAutoCommitOffsetsAsync()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void maybeLeaveGroup()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void unsubscribe()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitMetadataUpdate(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitPendingRequests(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean poll(org.apache.kafka.clients.consumer.internals.RequestFuture,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map retrieveOffsetsByTimes(java.util.Map,long,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollOnce(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void joinGroupIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doAutoCommitOffsetsAsync()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsAsync(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsNow()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void unsubscribe()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitMetadataUpdate(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void awaitMetadataUpdate()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void poll(long,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map retrieveOffsetsByTimes(java.util.Map,long,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitPendingRequests(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsSync(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map retrieveOffsetsByTimes(java.util.Map,long,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getOffsetsByTimes(java.util.Map,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsets(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getAllTopicMetadata(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void ensureCoordinatorReady()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void joinGroupIfNeeded()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void ensureActiveGroup()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void refreshCommittedOffsetsIfNeeded()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsAsync(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsNow()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void awaitMetadataUpdate()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void ensureFreshMetadata()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void poll(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollOnce(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsSync(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinPrepare(int,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getOffsetsByTimes(java.util.Map,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOffsets(java.util.Collection,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map endOffsets(java.util.Collection,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsets(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void updateFetchPositions(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getAllTopicMetadata(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void ensureCoordinatorReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void ensureActiveGroup()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void poll(long,long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void joinGroupIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void ensureActiveGroup()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void refreshCommittedOffsetsIfNeeded()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void updateFetchPositions(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,java.util.concurrent.TimeUnit)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void ensureFreshMetadata()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinPrepare(int,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void joinGroupIfNeeded()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOffsets(java.util.Collection,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map endOffsets(java.util.Collection,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void updateFetchPositions(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void updateFetchPositions(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void updateFetchPositions(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void updateFetchPositions(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollOnce(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void joinGroupIfNeeded()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1100(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.requests.JoinGroupResponse)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1100(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.requests.JoinGroupResponse)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)"
        ],
        "vulCaller": []
    }
}