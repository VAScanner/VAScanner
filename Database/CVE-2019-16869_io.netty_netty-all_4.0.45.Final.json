{
    "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)": {
        "isVulRoot": true,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.LastHttpContent readTrailingHeaders(io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.HttpObjectDecoder$State readHeaders(io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.LastHttpContent readTrailingHeaders(io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.HttpObjectDecoder$State readHeaders(io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http.HttpServerCodec$HttpServerRequestDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ReplayingDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpClientCodec$Decoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpServerCodec$HttpServerRequestDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ReplayingDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageCodec:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$7:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$500(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$300(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CodecOutputList,int)",
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:boolean handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.local.LocalServerChannel:void doBeginRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])",
            "io.netty.channel.local.LocalChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$500(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$6:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$300(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$4:void run()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.ssl.SslHandler:void unwrapNonAppData(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CodecOutputList,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageCodec:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpServerKeepAliveHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioChannel$1:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:boolean handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void doRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioChannel$1:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void access$500(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$3:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalServerChannel:void access$000(io.netty.channel.local.LocalServerChannel,io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.sctp.SctpNotificationHandler:void fireEvent(com.sun.nio.sctp.Notification)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fireEventAndClose(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void unwrapNonAppData(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void access$000(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void access$400(io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ReplayingDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpServerKeepAliveHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.oio.AbstractOioChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeysPlain(java.util.Set)",
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeysOptimized()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void access$500(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel$5:void run()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.local.LocalChannel:void doClose()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$3:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void access$000(io.netty.channel.local.LocalServerChannel,io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalServerChannel$2:void run()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:boolean handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.sctp.SctpNotificationHandler:void fireEvent(com.sun.nio.sctp.Notification)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.PeerAddressChangeNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.AssociationChangeNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.SendFailedNotification,java.lang.Object)"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fireEventAndClose(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.logging.LoggingHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.logging.LoggingHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpObjectAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.IdleStateHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void access$300(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$6:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void run()",
            "io.netty.channel.DefaultChannelPipeline$7:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$000(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$3:void run()",
            "io.netty.channel.DefaultChannelPipeline$2:void run()",
            "io.netty.channel.DefaultChannelPipeline$7:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void run()",
            "io.netty.channel.DefaultChannelPipeline$5:void run()",
            "io.netty.channel.DefaultChannelPipeline$4:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void removeOutboundHandler()",
            "io.netty.channel.CombinedChannelDuplexHandler:void removeInboundHandler()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void access$400(io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext$1:void run()"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeysPlain(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeysOptimized()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$2:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$200(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.PeerAddressChangeNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.AssociationChangeNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.SendFailedNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.logging.LoggingHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.logging.LoggingHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpObjectAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void access$1000(io.netty.handler.ssl.SslHandler,io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void destroy()",
            "io.netty.channel.DefaultChannelPipeline:void access$200(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$300(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$9:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void remove(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void removeOutboundHandler()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void removeInboundHandler()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1400(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$200(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void flush0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void flush0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollOutReady()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void forceFlush()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void access$1000(io.netty.handler.ssl.SslHandler,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$3:void run()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void destroy()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void access$700(io.netty.channel.DefaultChannelPipeline)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$200(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$8:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$9:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void invokeHandlerAddedIfNeeded()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void remove(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void setup(io.netty.channel.ChannelHandler[])",
            "io.netty.channel.embedded.EmbeddedChannel$2:void initChannel(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$2:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void readIfNeeded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1400(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$15:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollOutReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollOutReady()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void forceFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void access$700(io.netty.channel.DefaultChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void invokeHandlerAddedIfNeeded()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInitializer:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void setup(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,io.netty.channel.ChannelConfig,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$2:void initChannel(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.handler.codec.spdy.SpdyFrameCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void readIfNeeded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$15:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void setup(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollOutReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()",
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$1:void run()",
            "io.netty.channel.local.LocalChannel$2:void run()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fireEventAndClose(java.lang.Object)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.local.LocalServerChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.local.LocalChannel:void tryClose(boolean)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,io.netty.channel.ChannelConfig,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentCompressor:io.netty.handler.codec.http.HttpContentEncoder$Result beginEncode(io.netty.handler.codec.http.HttpResponse,java.lang.String)",
            "io.netty.handler.codec.http.HttpContentDecompressor:io.netty.channel.embedded.EmbeddedChannel newContentDecoder(java.lang.String)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$700(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.spdy.SpdyFrameCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void readIfIsAutoRead()",
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1200(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()",
            "io.netty.channel.epoll.AbstractEpollChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$2:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.local.LocalChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$300(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.local.LocalServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void tryClose(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void access$400(io.netty.channel.local.LocalChannel,boolean)",
            "io.netty.channel.local.LocalChannel:void doClose()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$100(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$000(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentCompressor:io.netty.handler.codec.http.HttpContentEncoder$Result beginEncode(io.netty.handler.codec.http.HttpResponse,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentDecompressor:io.netty.channel.embedded.EmbeddedChannel newContentDecoder(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$700(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$8:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void readIfIsAutoRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.sctp.SctpServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.rxtx.RxtxChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.sctp.SctpChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$1500(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1200(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$12:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.epoll.EpollChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1100(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()",
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$300(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollOutReady()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void access$400(io.netty.channel.local.LocalChannel,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel$4:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$100(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$2:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$000(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$1:void run()"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:boolean handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.local.LocalServerChannel:void doBeginRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])",
            "io.netty.channel.local.LocalChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()"
        ]
    },
    "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.udt.DefaultUdtChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.sctp.DefaultSctpChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.DefaultChannelConfig:boolean setOptions(java.util.Map)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.sctp.SctpServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtServerChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.rxtx.RxtxChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollDatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollDomainSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.oio.OioServerSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.oio.OioSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.sctp.SctpChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1500(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$16:void run()",
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void forceFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$12:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()",
            "io.netty.handler.codec.compression.JdkZlibEncoder$3:void run()",
            "io.netty.handler.codec.compression.JZlibEncoder$3:void run()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1100(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$13:void run()",
            "io.netty.channel.AbstractChannelHandlerContext$12:void run()"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.PromiseTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()"
        ]
    },
    "io.netty.util.concurrent.ScheduledFutureTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListenersNow()",
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners0(io.netty.util.concurrent.DefaultFutureListeners)",
            "io.netty.util.concurrent.DefaultPromise:void access$100(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:void notifyListenerWithStackOverFlowProtection(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1000(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageCodec$1:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$200(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelConfig:boolean setOptions(java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollDatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollDomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.oio.OioServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.oio.OioSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.MessageToByteEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$16:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void forceFlush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void flushIfNeeded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()",
            "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void fail(io.netty.channel.ChannelHandlerContext,java.lang.String,java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$13:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListenersNow()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners()",
            "io.netty.util.concurrent.DefaultPromise:void access$000(io.netty.util.concurrent.DefaultPromise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListeners0(io.netty.util.concurrent.DefaultFutureListeners)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListenersNow()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void access$100(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$2:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListenerWithStackOverFlowProtection(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$900(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1000(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$11:void run()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.logging.LoggingHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.traffic.AbstractTrafficShapingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.logging.LoggingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.IdleStateHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.handler.codec.MessageToMessageCodec$1:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$200(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$3:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void closeOutboundAndChannel(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,boolean)",
            "io.netty.handler.ssl.SslHandler:void access$700(io.netty.handler.ssl.SslHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1900(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.MessageToByteEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.ByteToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JdkZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void protocolViolation(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CorruptedFrameException)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flushIfNeeded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])",
            "io.netty.channel.nio.AbstractNioByteChannel$1:void run()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void fail(io.netty.channel.ChannelHandlerContext,java.lang.String,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,java.lang.String)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListeners()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:boolean trySuccess(java.lang.Object)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultPromise:boolean cancel(boolean)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.util.concurrent.DefaultPromise:boolean tryFailure(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void access$000(io.netty.util.concurrent.DefaultPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$1:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks()",
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks(long)",
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)",
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$NonNotifyRunnable:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$900(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$10:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$11:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.logging.LoggingHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.traffic.AbstractTrafficShapingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.logging.LoggingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.MessageToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$3:void run()",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void closeOutboundAndChannel(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void access$700(io.netty.handler.ssl.SslHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1900(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JdkZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void protocolViolation(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CorruptedFrameException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void checkUTF8String(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void checkCloseFrameBody(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void protocolViolation(io.netty.channel.ChannelHandlerContext,java.lang.String)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder$1:void run()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void notifyHandlerException(java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$400(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)",
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.local.LocalChannel:void runFinishPeerReadTask(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalChannel:void doClose()",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean trySuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:void shutdown()",
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:java.util.List shutdownNow()",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.channel.DefaultChannelPromise:boolean trySuccess()",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:void shutdown()",
            "io.netty.handler.ssl.SslHandler:void notifyClosePromise(java.lang.Throwable)",
            "io.netty.util.concurrent.PromiseTask:boolean trySuccessInternal(java.lang.Object)",
            "io.netty.handler.ssl.SslHandler:void setHandshakeSuccess()",
            "io.netty.util.internal.PromiseNotificationUtil:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)",
            "io.netty.channel.DefaultChannelProgressivePromise:boolean trySuccess()",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler$8:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean cancel(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancelWithoutRemove(boolean)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void setSuccess0()",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)",
            "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setSuccessInternal(java.lang.Object)",
            "io.netty.util.concurrent.MultithreadEventExecutorGroup$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.util.concurrent.SingleThreadEventExecutor$2:void run()",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$1:void run()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.PromiseTask:boolean tryFailureInternal(java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)",
            "io.netty.channel.PendingWriteQueue:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void notifyClosePromise(java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void notifyHandshakeFailure(java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioChannel:void doClose()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel:void doClose()",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void setFailure0(io.netty.channel.group.ChannelGroupException)",
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setFailureInternal(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks()",
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks(long)",
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)",
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$NonNotifyRunnable:void run()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean confirmShutdown()",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.epoll.EpollEventLoop:void run()",
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void run()",
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$NonNotifyRunnable:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$10:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$2:void run()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.logging.LoggingHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.handler.timeout.IdleStateHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.WebSocketClientProtocolHandshakeHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void checkUTF8String(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void checkCloseFrameBody(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void protocolViolation(io.netty.channel.ChannelHandlerContext,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void checkCloseFrameBody(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void notifyHandlerException(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$400(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$5:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void runFinishPeerReadTask(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.embedded.EmbeddedChannel:boolean finish(boolean)",
            "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:java.util.List shutdownNow()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseCombiner:void finish(io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean access$400(io.netty.util.concurrent.PromiseCombiner)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:boolean trySuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$CloseFuture:boolean setClosed()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetSuccess(io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void notifyClosePromise(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:boolean trySuccessInternal(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:boolean setHandshakeSuccessIfStillHandshaking()",
            "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.util.internal.PromiseNotificationUtil:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object,io.netty.util.internal.logging.InternalLogger)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.ChannelOutboundBuffer:void safeSuccess(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:boolean trySuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnaryPromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap$2:void run()",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.ssl.SslHandler$8:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$8:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.EventLoop nextChild()",
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.ScheduledFutureTask:boolean cancelWithoutRemove(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void setSuccess0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void access$400(io.netty.channel.group.DefaultChannelGroupFuture)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Map,io.netty.util.concurrent.EventExecutor)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Collection,io.netty.util.concurrent.EventExecutor)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setSuccessInternal(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:boolean tryFailureInternal(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:void removeAndFail(java.lang.Throwable)",
            "io.netty.channel.PendingWriteQueue:void removeAndFailAll(java.lang.Throwable)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void notifyHandshakeFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean)",
            "io.netty.handler.ssl.SslHandler:void access$1200(io.netty.handler.ssl.SslHandler,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:boolean ensureOpen(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractServerChannel$DefaultServerUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$200(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void doClose()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int)"
        ]
    },
    "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.AbstractChannelHandlerContext:void notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundBuffer:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void setFailure0(io.netty.channel.group.ChannelGroupException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void access$300(io.netty.channel.group.DefaultChannelGroupFuture,io.netty.channel.group.ChannelGroupException)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setFailureInternal(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap$2:void run()",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.bootstrap.Bootstrap$2:void run()",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:boolean confirmShutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoop:void run()",
            "io.netty.util.concurrent.DefaultEventExecutor:void run()",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.epoll.EpollEventLoop:void run()",
            "io.netty.util.concurrent.SingleThreadEventExecutor$2:void run()",
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners()",
            "io.netty.util.concurrent.DefaultPromise:void notifyProgressiveListeners(long,long)",
            "io.netty.util.concurrent.DefaultPromise:void notifyListenerWithStackOverFlowProtection(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void access$100(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$2:void run()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$2:void run()"
        ]
    },
    "io.netty.bootstrap.Bootstrap$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.logging.LoggingHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.WebSocketClientProtocolHandshakeHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$800(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:boolean handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean)",
            "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.ChannelFutureListener$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$200(io.netty.channel.pool.SimpleChannelPool,io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finish(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean finishAndReleaseAll()",
            "io.netty.channel.embedded.EmbeddedChannel:boolean finish()"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:void finish(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:boolean access$400(io.netty.util.concurrent.PromiseCombiner)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseCombiner$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannel$CloseFuture:boolean setClosed()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetSuccess(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$DefaultUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$100(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:boolean setHandshakeSuccessIfStillHandshaking()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:boolean wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void safeSuccess(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove()"
        ]
    },
    "io.netty.util.concurrent.UnaryPromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.bootstrap.AbstractBootstrap$2:void run()",
            "io.netty.handler.codec.compression.JZlibEncoder$1:void run()",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)",
            "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder:void protocolViolation(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CorruptedFrameException)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseCombiner:void add(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler$8:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.EventLoop nextChild()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.util.concurrent.RejectedExecutionHandler)",
            "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void access$400(io.netty.channel.group.DefaultChannelGroupFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Map,io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Collection,io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void access$300(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$400(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess()",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:void removeAndFail(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.PendingWriteQueue:void removeAndFailAll(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean)",
            "io.netty.handler.ssl.SslHandler:void handlerRemoved0(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void access$1200(io.netty.handler.ssl.SslHandler,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$5:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:boolean ensureOpen(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractServerChannel$DefaultServerUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$200(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)",
            "io.netty.channel.ChannelOutboundBuffer:void close(java.nio.channels.ClosedChannelException)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void access$300(io.netty.channel.group.DefaultChannelGroupFuture,io.netty.channel.group.ChannelGroupException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel$2:void run()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void access$100(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel$2:void run()",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$1:void run()",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$1:void run()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel$1:void run()"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$2:void run()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$3:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$2:void run()"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture register()",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpChannel$2:void run()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel$1:void run()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpChannel$1:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$2:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultEventExecutor:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$2:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyProgressiveListeners(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:boolean tryProgress(long,long)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$100(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$3:void run()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$800(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$9:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.marshalling.CompatibleMarshallingDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.logging.LoggingHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$200(io.netty.channel.pool.SimpleChannelPool,io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finishAndReleaseAll()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finish()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void cleanup()",
            "io.netty.handler.codec.http.HttpContentEncoder:void finishEncode(java.util.List)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$DefaultUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$100(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.embedded.EmbeddedChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.sctp.oio.OioSctpChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeDefaultFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion,int)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.FileRegion,int)",
            "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)",
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect()"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind()",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:void add(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.local.LocalEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)",
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object,io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$300(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$5:void run()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$400(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$6:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess()"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void handlerRemoved0(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.ssl.SslHandler$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$1300(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)",
            "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void close(java.nio.channels.ClosedChannelException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()",
            "io.netty.channel.ChannelOutboundBuffer$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$100(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$2:void run()",
            "io.netty.channel.socket.nio.NioSocketChannel$1:void run()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture register()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:boolean tryProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future access$201(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire()",
            "io.netty.channel.pool.FixedChannelPool:void runTaskQueue()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$9:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer$2:void run()",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.marshalling.CompatibleMarshallingDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.logging.LoggingHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void cleanup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void finishEncode(java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$800(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeDefaultFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.epoll.IovArray,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,int)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.FileRegion,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.InetAddress,int)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.lang.String,int)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.channel.ChannelFuture connectChannel(io.netty.bootstrap.Bootstrap)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(int)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.InetAddress,int)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.lang.String,int)"
        ]
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider)"
        ]
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$6:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1300(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$14:void run()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$000(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future access$201(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$2:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:void access$300(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:void runTaskQueue()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void decrementAndRunTaskQueue()",
            "io.netty.channel.pool.FixedChannelPool:void access$1000(io.netty.channel.pool.FixedChannelPool)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)",
            "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$800(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.epoll.IovArray,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.InetAddress,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.lang.String,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.channel.ChannelFuture connectChannel(io.netty.bootstrap.Bootstrap)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.InetAddress,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.lang.String,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$14:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$000(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool$2:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:void access$300(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$3:void run()"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void decrementAndRunTaskQueue()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void access$600(io.netty.channel.pool.FixedChannelPool)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void access$1000(io.netty.channel.pool.FixedChannelPool)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:void access$600(io.netty.channel.pool.FixedChannelPool)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)",
            "io.netty.channel.ChannelOutboundBuffer:boolean remove()",
            "io.netty.channel.ChannelOutboundBuffer:void addFlush()",
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)",
            "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void addFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void init(io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask,io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void init(io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask,io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask access$1700(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask access$1600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask access$1700(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask access$1600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    }
}