{
    "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)": {
        "isVulRoot": true,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.LastHttpContent readTrailingHeaders(io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.HttpObjectDecoder$State readHeaders(io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.LastHttpContent readTrailingHeaders(io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:io.netty.handler.codec.http.HttpObjectDecoder$State readHeaders(io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http.HttpServerCodec$HttpServerRequestDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ReplayingDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpClientCodec$Decoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpServerCodec$HttpServerRequestDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ReplayingDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.HttpObjectDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.handler.codec.ByteToMessageCodec:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.memcache.binary.AbstractBinaryMemcacheDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$7:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$500(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpObjectDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$300(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.memcache.binary.AbstractBinaryMemcacheDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.memcache.binary.BinaryMemcacheClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CodecOutputList,int)",
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.local.LocalServerChannel:void doBeginRead()",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:boolean doRead0(java.lang.Object,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])",
            "io.netty.channel.local.LocalChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$500(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$6:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$300(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$4:void run()"
        ]
    },
    "io.netty.handler.codec.memcache.binary.BinaryMemcacheClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.CodecOutputList,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.ssl.SslHandler:void unwrapNonAppData(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageCodec:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void fireChannelRead(io.netty.channel.ChannelHandlerContext,java.util.List,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtensionHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.HttpServerKeepAliveHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.websocketx.extensions.WebSocketServerExtensionHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http.websocketx.Utf8FrameValidator:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioChannel$1:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void doRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioChannel$1:void run()"
        ]
    },
    "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:boolean doRead0(java.lang.Object,io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void doBeginRead()",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void fireChildRead0(java.lang.Object)"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void access$500(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)"
        ]
    },
    "io.netty.channel.local.LocalChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalServerChannel:void access$000(io.netty.channel.local.LocalServerChannel,io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()"
        ]
    },
    "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasksFrom(java.util.Queue)",
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks(long)",
            "io.netty.util.concurrent.NonStickyEventExecutorGroup$NonStickyOrderedEventExecutor:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.sctp.SctpNotificationHandler:void fireEvent(com.sun.nio.sctp.Notification)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fireEventAndClose(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelInactive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelInactive()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void unwrapNonAppData(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void access$000(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void access$400(io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.InboundHttpToHttp2Adapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.ReplayingDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ReplayingDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$FrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtensionHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpServerKeepAliveHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.WebSocketServerExtensionHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.Utf8FrameValidator:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.oio.AbstractOioChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeysOptimized(java.nio.channels.SelectionKey[])",
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeysPlain(java.util.Set)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void fireChildRead0(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void access$200(io.netty.handler.codec.http2.AbstractHttp2StreamChannel,java.lang.Object)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void fireChildRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void access$500(io.netty.channel.local.LocalChannel,io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel$5:void run()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.local.LocalChannel:void doClose()"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe$1:void run()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void access$000(io.netty.channel.local.LocalServerChannel,io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalServerChannel$2:void run()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasksFrom(java.util.Queue)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks()",
            "io.netty.channel.SingleThreadEventLoop:void afterRunningAllTasks()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void run()",
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.util.concurrent.NonStickyEventExecutorGroup$NonStickyOrderedEventExecutor:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.channel.sctp.SctpNotificationHandler:void fireEvent(com.sun.nio.sctp.Notification)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.PeerAddressChangeNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.AssociationChangeNotification,java.lang.Object)",
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.SendFailedNotification,java.lang.Object)"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fireEventAndClose(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.DatagramPacketDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.ByteToMessageDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.spdy.SpdyHttpDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.MessageAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.handler.timeout.IdleStateHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelInactive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void access$300(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$6:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void run()",
            "io.netty.channel.DefaultChannelPipeline$7:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$000(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$2:void run()",
            "io.netty.channel.DefaultChannelPipeline$3:void run()",
            "io.netty.channel.DefaultChannelPipeline$7:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void run()",
            "io.netty.channel.DefaultChannelPipeline$5:void run()",
            "io.netty.channel.DefaultChannelPipeline$4:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void removeOutboundHandler()",
            "io.netty.channel.CombinedChannelDuplexHandler:void removeInboundHandler()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void access$400(io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext$1:void run()"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readDataFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readRstStreamFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameListenerDecorator:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeysOptimized(java.nio.channels.SelectionKey[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeysPlain(java.util.Set)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$200(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void access$200(io.netty.handler.codec.http2.AbstractHttp2StreamChannel,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel$3:void run()"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void fireChildRead(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void fireChildReadAndRegister(io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel,io.netty.handler.codec.http2.Http2StreamFrame)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onStreamClosed0(io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel)"
        ]
    },
    "io.netty.channel.local.LocalChannel$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.local.LocalServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean confirmShutdown()",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.epoll.EpollEventLoop:void run()",
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.channel.SingleThreadEventLoop:void afterRunningAllTasks()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks()",
            "io.netty.util.concurrent.SingleThreadEventExecutor:boolean runAllTasks(long)"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.PeerAddressChangeNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.AssociationChangeNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.SendFailedNotification,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.spdy.SpdyHttpDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageAggregator:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void access$900(io.netty.handler.ssl.SslHandler,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void access$200(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void destroy()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$300(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$9:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void remove(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void removeOutboundHandler()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.HttpProxyHandler:void removeEncoder(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void removeInboundHandler()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.HttpProxyHandler:void removeDecoder(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader$1:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPushPromiseFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readContinuationFrame(io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void processSelectedKeys()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)",
            "io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator:void run()",
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1400(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$200(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void fireChildReadAndRegister(io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel,io.netty.handler.codec.http2.Http2StreamFrame)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void onStreamClosed0(io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void onStreamClosed(int)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void access$000(io.netty.handler.codec.http2.Http2MultiplexCodec,io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void flush0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void flush0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollOutReady()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void forceFlush()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:io.netty.channel.ChannelFuture createStreamChannel(io.netty.channel.Channel,io.netty.channel.EventLoopGroup,io.netty.channel.ChannelHandler,java.util.Map,java.util.Map,int)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:boolean confirmShutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutor:void run()",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.epoll.EpollEventLoop:void run()",
            "io.netty.channel.nio.NioEventLoop:void run()",
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()",
            "io.netty.channel.DefaultEventLoop:void run()"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void access$900(io.netty.handler.ssl.SslHandler,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$3:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$200(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$8:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void destroy()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void access$700(io.netty.channel.DefaultChannelPipeline)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$9:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void invokeHandlerAddedIfNeeded()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void remove(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:io.netty.channel.ChannelFuture createStreamChannel(io.netty.channel.Channel,io.netty.channel.EventLoopGroup,io.netty.channel.ChannelHandler,java.util.Map,java.util.Map,int)",
            "io.netty.channel.embedded.EmbeddedChannel:void setup(io.netty.channel.ChannelHandler[])",
            "io.netty.channel.embedded.EmbeddedChannel$2:void initChannel(io.netty.channel.Channel)"
        ]
    },
    "io.netty.handler.proxy.HttpProxyHandler:void removeEncoder(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:boolean safeRemoveEncoder()"
        ]
    },
    "io.netty.handler.proxy.HttpProxyHandler:void removeDecoder(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:boolean safeRemoveDecoder()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettings(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPushPromiseFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readContinuationFrame(io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader$2:void processFragment(boolean,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readHeadersFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPushPromiseFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readContinuationFrame(io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:void doStartThread()",
            "io.netty.util.concurrent.DefaultPromise:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker read()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.handler.ssl.SslHandler:void readIfNeeded(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1400(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$15:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void onStreamClosed(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void access$000(io.netty.handler.codec.http2.Http2MultiplexCodec,io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void flush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollOutReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollOutReady()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void forceFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:io.netty.channel.ChannelFuture createStreamChannel(io.netty.channel.Channel,io.netty.channel.EventLoopGroup,io.netty.channel.ChannelHandler,java.util.Map,java.util.Map,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.DefaultEventExecutor:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.channel.DefaultEventLoop:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:io.netty.util.concurrent.Future renegotiate()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$700(io.netty.channel.DefaultChannelPipeline)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void invokeHandlerAddedIfNeeded()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInitializer:void handlerAdded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void setup(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelConfig,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$2:void initChannel(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:boolean safeRemoveEncoder()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:boolean safeRemoveDecoder()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.DecoratingHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger:void readFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettings(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettingsHeader(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void doStartThread()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:void startThread()",
            "io.netty.util.concurrent.SingleThreadEventExecutor:void shutdown()",
            "io.netty.util.concurrent.SingleThreadEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners()",
            "io.netty.util.concurrent.DefaultPromise:void notifyProgressiveListeners(long,long)",
            "io.netty.util.concurrent.DefaultPromise:void notifyListenerWithStackOverFlowProtection(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.handler.codec.spdy.SpdyFrameCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelOutboundInvoker read()",
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void readIfNeeded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.DatagramPacketEncoder:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$15:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()",
            "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()",
            "io.netty.channel.embedded.EmbeddedChannel:void setup(io.netty.channel.ChannelHandler[])",
            "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollOutReady()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoop:void processReady(io.netty.channel.epoll.EpollEventArray,int)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void fireEventAndClose(java.lang.Object)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:boolean doRead0(java.lang.Object,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.local.LocalServerChannel$1:void run()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.local.LocalChannel:void tryClose(boolean)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$2:void run()",
            "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.channel.ChannelInitializer:void handlerAdded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelConfig,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:io.netty.channel.embedded.EmbeddedChannel newContentDecompressor(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)",
            "io.netty.handler.codec.http.HttpContentCompressor:io.netty.handler.codec.http.HttpContentEncoder$Result beginEncode(io.netty.handler.codec.http.HttpResponse,java.lang.String)",
            "io.netty.handler.codec.http.HttpContentDecompressor:io.netty.channel.embedded.EmbeddedChannel newContentDecoder(java.lang.String)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressionChannel(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.compression.ZlibWrapper)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,io.netty.channel.ChannelHandler[])",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void access$100(io.netty.handler.proxy.ProxyHandler,java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.proxy.ProxyHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2ConnectionDecoder:void decodeFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:io.netty.handler.codec.http2.Http2Settings decodeSettingsHeader(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:boolean prepareUpgradeResponse(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest,io.netty.handler.codec.http.HttpHeaders)"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void startThread()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.SingleThreadEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void shutdown()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListeners()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:boolean trySuccess(java.lang.Object)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:boolean cancel(boolean)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.util.concurrent.DefaultPromise:boolean tryFailure(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyProgressiveListeners(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:boolean tryProgress(long,long)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListenerWithStackOverFlowProtection(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$700(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.spdy.SpdyFrameCodec:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelOutboundInvoker read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelOutboundInvoker read()",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void readIfIsAutoRead()",
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture register()",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1200(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$300(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.local.LocalServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalChannel:void tryClose(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void access$400(io.netty.channel.local.LocalChannel,boolean)",
            "io.netty.channel.local.LocalChannel:void doClose()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void shutdownInput()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollRdHupReady()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$100(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$000(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:io.netty.channel.embedded.EmbeddedChannel newContentDecompressor(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void initDecompressor(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,boolean)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentCompressor:io.netty.handler.codec.http.HttpContentEncoder$Result beginEncode(io.netty.handler.codec.http.HttpResponse,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentDecompressor:io.netty.channel.embedded.EmbeddedChannel newContentDecoder(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressionChannel(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.compression.ZlibWrapper)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newContentCompressor(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId)",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(boolean,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void access$100(io.netty.handler.proxy.ProxyHandler,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler$2:void run()",
            "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.ByteToMessageDecoder:void decodeLast(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ServerUpgradeCodec:boolean prepareUpgradeResponse(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.FullHttpRequest,io.netty.handler.codec.http.HttpHeaders)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void execute(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void executeEpollInReadyRunnable()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.nio.AbstractNioChannel:void clearReadPending()",
            "io.netty.channel.nio.AbstractNioChannel:void setReadPending(boolean)",
            "io.netty.channel.local.LocalChannel:void runFinishPeerReadTask(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.oio.AbstractOioChannel:void setReadPending(boolean)",
            "io.netty.util.concurrent.DefaultPromise:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.nio.NioEventLoop:void rebuildSelector()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.ChannelOutboundBuffer:void close(java.nio.channels.ClosedChannelException)",
            "io.netty.util.concurrent.SingleThreadEventExecutor:void removeShutdownHook(java.lang.Runnable)",
            "io.netty.channel.local.LocalChannel:void doClose()",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void addToSpliceQueue(io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInTask)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void fireChildRead(java.lang.Object)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioByteChannel:void incompleteWrite(boolean)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.oio.AbstractOioChannel:void doBeginRead()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(io.netty.util.concurrent.ScheduledFutureTask)",
            "io.netty.channel.pool.FixedChannelPool:void close()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void fireChildReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)",
            "io.netty.bootstrap.Bootstrap:void doConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.SingleThreadEventExecutor:void addShutdownHook(java.lang.Runnable)",
            "io.netty.channel.oio.AbstractOioChannel:void clearReadPending()",
            "io.netty.bootstrap.AbstractBootstrap:void doBind0(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalServerChannel:io.netty.channel.local.LocalChannel serve(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel:void doRegister()",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:void removeScheduled(io.netty.util.concurrent.ScheduledFutureTask)",
            "io.netty.util.concurrent.SingleThreadEventExecutor:void doStartThread()",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.AbstractEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean trySuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:void shutdown()",
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:java.util.List shutdownNow()",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.channel.DefaultChannelPromise:boolean trySuccess()",
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:void shutdown()",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()",
            "io.netty.resolver.dns.DnsNameResolver$ListResolverContext:boolean finishResolve(java.lang.Class,java.util.List,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object)",
            "io.netty.util.concurrent.PromiseTask:boolean trySuccessInternal(java.lang.Object)",
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void setHandshakeSuccess()",
            "io.netty.util.internal.PromiseNotificationUtil:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.resolver.dns.InflightNameResolver:void transferResult(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)",
            "io.netty.channel.DefaultChannelProgressivePromise:boolean trySuccess()",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()",
            "io.netty.channel.ThreadPerChannelEventLoopGroup$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void resolve(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.pool.FixedChannelPool$AcquireTask:void <init>(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)",
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean cancel(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancelWithoutRemove(boolean)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.RoundRobinInetAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void setSuccess0()",
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)",
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.InetSocketAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setSuccessInternal(java.lang.Object)",
            "io.netty.util.concurrent.MultithreadEventExecutorGroup$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.DefaultNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.resolver.RoundRobinInetAddressResolver$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.util.concurrent.SingleThreadEventExecutor$5:void run()",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)",
            "io.netty.resolver.DefaultNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$1:void run()",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)",
            "io.netty.channel.PendingWriteQueue:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolverContext:void resolve(io.netty.util.concurrent.Promise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioChannel:void doClose()",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.local.LocalChannel:void doClose()",
            "io.netty.resolver.dns.InflightNameResolver:void transferResult(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.PromiseTask:boolean tryFailureInternal(java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void notifyHandshakeFailure(java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()",
            "io.netty.resolver.dns.DnsNameResolver:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setFailureInternal(java.lang.Throwable)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.RoundRobinInetAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void setFailure0(io.netty.channel.group.ChannelGroupException)",
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)",
            "io.netty.resolver.InetSocketAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.DefaultNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.resolver.RoundRobinInetAddressResolver$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.DefaultNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:boolean tryProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListener(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$700(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$8:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelOutboundInvoker read()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void readIfIsAutoRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)",
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.sctp.SctpServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.rxtx.RxtxChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.sctp.SctpChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture register()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddresses,io.netty.resolver.dns.DnsCache,long,io.netty.channel.socket.InternetProtocolFamily[],boolean,int,boolean,int,boolean,io.netty.resolver.HostsFileEntriesResolver,java.lang.String[],int)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind()",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$1500(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1200(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$12:void run()"
        ]
    },
    "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()",
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$300(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void access$400(io.netty.channel.local.LocalChannel,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel$4:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void clearEpollIn()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollInFinally(io.netty.channel.ChannelConfig)",
            "io.netty.channel.epoll.EpollChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1100(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollOutReady()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void processSelectedKey(java.nio.channels.SelectionKey,io.netty.channel.nio.AbstractNioChannel)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$100(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$2:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$000(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$1:void run()"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void initDecompressor(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean)",
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newContentCompressor(io.netty.channel.ChannelHandlerContext,java.lang.CharSequence)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressor(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Headers,boolean)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelId)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.channel.embedded.EmbeddedChannel:void <init>()"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void executeEpollInReadyRunnable()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollInFinally(io.netty.channel.ChannelConfig)",
            "io.netty.channel.epoll.AbstractEpollChannel:void doBeginRead()"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel:void clearReadPending()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:void access$100(io.netty.channel.sctp.nio.NioSctpServerChannel)",
            "io.netty.channel.socket.nio.NioSocketChannel:void access$600(io.netty.channel.socket.nio.NioSocketChannel)",
            "io.netty.channel.sctp.nio.NioSctpChannel:void access$100(io.netty.channel.sctp.nio.NioSctpChannel)",
            "io.netty.channel.socket.nio.NioDatagramChannel:void clearReadPending0()",
            "io.netty.channel.socket.nio.NioServerSocketChannel:void access$100(io.netty.channel.socket.nio.NioServerSocketChannel)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:void setReadPending(boolean)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void runFinishPeerReadTask(io.netty.channel.local.LocalChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void finishPeerRead(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioServerSocketChannel:void setReadPending(boolean)",
            "io.netty.channel.socket.oio.OioSocketChannel:void setReadPending(boolean)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel$2:void run()"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void rebuildSelector()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void select(boolean)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel$2:void run()",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void close(java.nio.channels.ClosedChannelException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.ChannelOutboundBuffer$3:void run()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void removeShutdownHook(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doDeregister()",
            "io.netty.channel.local.LocalServerChannel:void doDeregister()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)",
            "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void addToSpliceQueue(io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel:void incompleteWrite(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpChannel$2:void run()"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.oio.AbstractOioChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void failSpliceIfClosed(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(io.netty.util.concurrent.ScheduledFutureTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$1:void run()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void fireChildReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:void doConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap:void access$100(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel$1:void run()"
        ]
    },
    "io.netty.util.concurrent.SingleThreadEventExecutor:void addShutdownHook(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalChannel:void doRegister()",
            "io.netty.channel.local.LocalServerChannel:void doRegister()"
        ]
    },
    "io.netty.channel.oio.AbstractOioChannel:void clearReadPending()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel:void access$100(io.netty.channel.sctp.oio.OioSctpServerChannel)",
            "io.netty.channel.sctp.oio.OioSctpChannel:void access$100(io.netty.channel.sctp.oio.OioSctpChannel)",
            "io.netty.channel.socket.oio.OioServerSocketChannel:void clearReadPending0()",
            "io.netty.channel.socket.oio.OioSocketChannel:void clearReadPending0()"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:void doBind0(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:void access$000(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput()"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$2:void run()",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$900(io.netty.channel.AbstractChannel$AbstractUnsafe,java.lang.Runnable)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput()"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doRegister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:void removeScheduled(io.netty.util.concurrent.ScheduledFutureTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor$2:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)",
            "io.netty.channel.sctp.oio.OioSctpChannel$1:void run()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])",
            "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:java.util.List shutdownNow()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$000(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseCombiner:void finish(io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean access$400(io.netty.util.concurrent.PromiseCombiner)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:boolean trySuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$CloseFuture:boolean setClosed()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetSuccess(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:void shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver$ListResolverContext:boolean finishResolve(java.lang.Class,java.util.List,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:boolean doResolveCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.dns.DnsNameResolver:boolean doResolveAllCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.dns.DnsNameResolver:void access$300(io.netty.util.concurrent.Promise,java.lang.Object)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:boolean trySuccessInternal(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:boolean setHandshakeSuccessIfStillHandshaking()",
            "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.util.internal.PromiseNotificationUtil:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object,io.netty.util.internal.logging.InternalLogger)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.ChannelOutboundBuffer:void safeSuccess(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:void transferResult(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)",
            "io.netty.resolver.dns.InflightNameResolver:void access$000(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:boolean trySuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnaryPromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Void)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void resolve(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAllUncached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.dns.DnsNameResolver:void doResolveUncached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:void access$300(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.bootstrap.Bootstrap$3:void run()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise unvoid()",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$AcquireTask:void <init>(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolveAll(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.EventLoop nextChild()",
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void sendQuery(io.netty.handler.codec.dns.DnsQuery)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.AddressResolverGroup:io.netty.resolver.AddressResolver getResolver(io.netty.util.concurrent.EventExecutor)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.ScheduledFutureTask:boolean cancelWithoutRemove(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.ScheduledFutureTask:boolean cancel(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()",
            "io.netty.channel.nio.AbstractNioChannel:void doClose()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void finishConnect()",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.resolver.dns.DnsCacheEntry:void cancelExpiration()",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void finishConnect()"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.DefaultChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$200(io.netty.channel.pool.SimpleChannelPool,io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.RoundRobinInetAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void setSuccess0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void access$400(io.netty.channel.group.DefaultChannelGroupFuture)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Map,io.netty.util.concurrent.EventExecutor)",
            "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Collection,io.netty.util.concurrent.EventExecutor)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setSuccessInternal(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.DefaultNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void finish(io.netty.channel.AddressedEnvelope)"
        ]
    },
    "io.netty.resolver.RoundRobinInetAddressResolver$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.resolver.DefaultNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture access$000(io.netty.bootstrap.Bootstrap,io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:void removeAndFail(java.lang.Throwable)",
            "io.netty.channel.PendingWriteQueue:void removeAndFailAll(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractServerChannel$DefaultServerUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:boolean ensureOpen(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$200(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)"
        ]
    },
    "io.netty.channel.nio.AbstractNioChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void doClose()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void access$300(io.netty.resolver.dns.DnsQueryContext,java.lang.String,java.lang.Throwable)",
            "io.netty.resolver.dns.DnsQueryContext:void onQueryWriteCompletion(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:boolean tryFailureInternal(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void notifyHandshakeFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void access$1100(io.netty.handler.ssl.SslHandler,java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int)"
        ]
    },
    "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.AbstractChannelHandlerContext:void notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundBuffer:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:boolean doResolveCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)",
            "io.netty.resolver.dns.DnsNameResolver:boolean doResolveAllCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable)"
        ]
    },
    "io.netty.util.concurrent.PromiseTask:io.netty.util.concurrent.Promise setFailureInternal(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask:void run()",
            "io.netty.util.concurrent.ScheduledFutureTask:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable)"
        ]
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)",
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void setFailure0(io.netty.channel.group.ChannelGroupException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture:void access$300(io.netty.channel.group.DefaultChannelGroupFuture,io.netty.channel.group.ChannelGroupException)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$TimeoutTask:void run()"
        ]
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.util.concurrent.ConcurrentMap,java.lang.String,io.netty.util.concurrent.Promise,boolean)",
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdown0(io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel$Unsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)",
            "io.netty.bootstrap.AbstractBootstrap$2:void run()",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdown0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture initAndRegister()",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdown0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)"
        ]
    },
    "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.util.concurrent.CompleteFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void read()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doRead()",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture flushInbound(boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalServerChannel:void doBeginRead()",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:boolean doRead0(java.lang.Object,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void doBeginRead()",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalChannel:void finishPeerRead0(io.netty.channel.local.LocalChannel)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel$1:void run()",
            "io.netty.channel.local.LocalChannel$1:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.local.LocalServerChannel:void serve0(io.netty.channel.local.LocalChannel)",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.handler.codec.ByteToMessageDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.ByteToMessageDecoder:void channelInputClosed(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()"
        ]
    },
    "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.udt.DefaultUdtChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.sctp.DefaultSctpChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:void initOpts(io.netty.channel.Channel,java.util.Map)",
            "io.netty.channel.DefaultChannelConfig:boolean setOptions(java.util.Map)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtServerChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.sctp.SctpServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.rxtx.RxtxChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollDatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollDomainSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.oio.OioServerSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.oio.OioSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.sctp.SctpChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddresses,io.netty.resolver.dns.DnsCache,long,io.netty.channel.socket.InternetProtocolFamily[],boolean,int,boolean,int,boolean,io.netty.resolver.HostsFileEntriesResolver,java.lang.String[],int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverBuilder:io.netty.resolver.dns.DnsNameResolver build()"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(int)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.InetAddress,int)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.lang.String,int)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.InetAddress,int)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.lang.String,int)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.channel.ChannelFuture connectChannel(io.netty.bootstrap.Bootstrap)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1500(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$16:void run()",
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void forceFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker flush()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.DatagramPacketEncoder:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$12:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.PromiseTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor$RunnableScheduledFutureTask:void run()"
        ]
    },
    "io.netty.util.concurrent.ScheduledFutureTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListenersNow()",
            "io.netty.util.concurrent.DefaultPromise:void access$100(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners0(io.netty.util.concurrent.DefaultFutureListeners)",
            "io.netty.util.concurrent.DefaultPromise:void notifyListenerWithStackOverFlowProtection(io.netty.util.concurrent.EventExecutor,io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.local.LocalChannel$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void epollInFinally(io.netty.channel.ChannelConfig)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void epollInReady()",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener$1:void run()",
            "io.netty.handler.codec.compression.JdkZlibEncoder$3:void run()",
            "io.netty.handler.codec.compression.JZlibEncoder$3:void run()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1100(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$13:void run()",
            "io.netty.channel.AbstractChannelHandlerContext$12:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1000(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageCodec$1:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.embedded.EmbeddedChannel newCompressor(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Headers,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void doBeginRead()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:void access$100(io.netty.channel.sctp.nio.NioSctpServerChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpServerChannel$NioSctpServerChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$600(io.netty.channel.socket.nio.NioSocketChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:void access$100(io.netty.channel.sctp.nio.NioSctpChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.nio.NioSctpChannel$NioSctpChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:void clearReadPending0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.nio.NioServerSocketChannel:void access$100(io.netty.channel.socket.nio.NioServerSocketChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioServerSocketChannel$NioServerSocketChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioServerSocketChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void setReadPending(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.nio.NioEventLoop:void select(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoop:void run()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.local.LocalChannel:void doDeregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void doDeregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelActive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelActive()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$3:void run()",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void fulfillConnectPromise(io.netty.channel.ChannelPromise,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.oio.AbstractOioByteChannel:void closeOnRead(io.netty.channel.ChannelPipeline)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsCacheEntry:void scheduleExpiration(io.netty.channel.EventLoop,java.lang.Runnable,long,java.util.concurrent.TimeUnit)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void <init>(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,long,java.util.concurrent.TimeUnit)",
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)",
            "io.netty.resolver.dns.DnsQueryContext:void onQueryWriteCompletion(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:io.netty.util.concurrent.ScheduledFuture scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$InternalHttp2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)",
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollIn0()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.epoll.EpollRecvByteAllocatorHandle)",
            "io.netty.channel.oio.AbstractOioMessageChannel:void doRead()",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel$2:void run()",
            "io.netty.channel.epoll.EpollDatagramChannel$EpollDatagramChannelUnsafe:void epollInReady()",
            "io.netty.channel.oio.AbstractOioByteChannel:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe:void read()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void handleReadException(io.netty.channel.ChannelPipeline,io.netty.buffer.ByteBuf,java.lang.Throwable,boolean,io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)",
            "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void epollInReady()",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe:void clearEpollRdHup()",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.epoll.EpollDomainSocketChannel$EpollDomainUnsafe:void epollInReadFd()"
        ]
    },
    "io.netty.bootstrap.Bootstrap:void access$100(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.local.LocalServerChannel:void doRegister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel:void access$100(io.netty.channel.sctp.oio.OioSctpServerChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpServerChannel$OioSctpServerChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:void access$100(io.netty.channel.sctp.oio.OioSctpChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.oio.OioSctpChannel$OioSctpChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.oio.OioServerSocketChannel:void clearReadPending0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void clearReadPending0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:void autoReadCleared()"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:void access$000(io.netty.channel.ChannelFuture,io.netty.channel.Channel,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$900(io.netty.channel.AbstractChannel$AbstractUnsafe,java.lang.Runnable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void run()"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe:void closeOnRead(io.netty.channel.ChannelPipeline)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer$2:void run()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()",
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])",
            "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)",
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)"
        ]
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully(long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$000(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:void finish(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:boolean access$400(io.netty.util.concurrent.PromiseCombiner)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseCombiner$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannel$CloseFuture:boolean setClosed()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.local.LocalChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetSuccess(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel$DefaultUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)",
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$100(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:boolean doResolveCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:boolean doResolveAllCached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void access$300(io.netty.util.concurrent.Promise,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver$SingleResolverContext:boolean finishResolve(java.lang.Class,java.util.List,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:boolean setHandshakeSuccessIfStillHandshaking()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:boolean unwrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,int,int)",
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.util.concurrent.PromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void safeSuccess(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove()"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:void access$000(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.UnaryPromiseNotifier:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setFailure(java.lang.String,java.lang.Throwable)",
            "io.netty.util.internal.PromiseNotificationUtil:void tryFailure(io.netty.util.concurrent.Promise,java.lang.Throwable,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean tryPromise()"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveAllUncached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveUncached(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise,io.netty.resolver.dns.DnsCache)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void access$300(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$3:void run()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.bootstrap.Bootstrap$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap$2:void run()",
            "io.netty.resolver.dns.DnsNameResolver:void <init>(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddresses,io.netty.resolver.dns.DnsCache,long,io.netty.channel.socket.InternetProtocolFamily[],boolean,int,boolean,int,boolean,io.netty.resolver.HostsFileEntriesResolver,java.lang.String[],int)",
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.handler.codec.compression.JZlibEncoder$1:void run()",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void doGracefulShutdown(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture doBind(java.net.SocketAddress)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise unvoid()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void writeHeaders(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2ConnectionEncoder,int,io.netty.handler.codec.http.HttpHeaders,io.netty.handler.codec.http2.Http2Headers,boolean,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:void add(io.netty.util.concurrent.Future)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String)",
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Promise resolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String)",
            "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.EventLoop nextChild()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.ChannelPromise)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve(io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void access$900(io.netty.resolver.dns.DnsNameResolverContext,java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void internalResolve(io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void followCname(java.net.InetSocketAddress,java.lang.String,java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.SocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void sendQuery(io.netty.handler.codec.dns.DnsQuery)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void query()"
        ]
    },
    "io.netty.resolver.AddressResolverGroup:io.netty.resolver.AddressResolver getResolver(io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.SocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsCacheEntry:void cancelExpiration()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.channel.group.ChannelGroupFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void doHealthCheck(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$100(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$200(io.netty.channel.pool.SimpleChannelPool,io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void access$300(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future release(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void releaseAndOfferIfHealthy(io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void access$400(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void access$400(io.netty.channel.group.DefaultChannelGroupFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Map,io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher,boolean)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher,boolean)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close(io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect(io.netty.channel.group.ChannelMatcher)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void <init>(io.netty.channel.group.ChannelGroup,java.util.Collection,io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise doneAllocatingPromises()",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdown0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.sctp.nio.NioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdown0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.nio.NioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture unbindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()",
            "io.netty.channel.socket.oio.OioSocketChannel:void shutdown0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpServerChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.sctp.oio.OioSctpChannel:io.netty.channel.ChannelFuture bindAddress(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void doResolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void finish(io.netty.channel.AddressedEnvelope)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess()",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)"
        ]
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture access$000(io.netty.bootstrap.Bootstrap,io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void tryToFinishResolve(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:void removeAndFail(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.PendingWriteQueue:void removeAndFailAll(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrap(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.proxy.ProxyHandler:void failPendingWrites(java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean)",
            "io.netty.handler.ssl.SslHandler:void handlerRemoved0(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractServerChannel$DefaultServerUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:boolean ensureOpen(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.local.LocalChannel$LocalUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.oio.AbstractOioChannel$DefaultOioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$200(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doClose()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doDisconnect()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeForcibly()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void doClose0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future access$201(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool:void acquire0(io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire()",
            "io.netty.channel.pool.FixedChannelPool:void runTaskQueue()"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void access$300(io.netty.resolver.dns.DnsQueryContext,java.lang.String,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$4:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void onQueryWriteCompletion(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void access$200(io.netty.resolver.dns.DnsQueryContext,io.netty.channel.ChannelFuture)",
            "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void access$1100(io.netty.handler.ssl.SslHandler,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$5:void run()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.ssl.SslHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.unix.FileDescriptor,int,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void notifyOutboundHandlerException(java.lang.Throwable,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void safeFail(io.netty.channel.ChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)",
            "io.netty.channel.ChannelOutboundBuffer:void close(java.nio.channels.ClosedChannelException)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture spliceTo(io.netty.channel.epoll.AbstractEpollStreamChannel,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,java.lang.Iterable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture:void access$300(io.netty.channel.group.DefaultChannelGroupFuture,io.netty.channel.group.ChannelGroupException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$TimeoutTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.resolver.SimpleNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdown0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$400(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder$HeadersFrame:void send(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void writeHeaders(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2ConnectionEncoder,int,io.netty.handler.codec.http.HttpHeaders,io.netty.handler.codec.http2.Http2Headers,boolean,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void access$100(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel$Unsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:void access$000(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownInput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$300(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:void access$100(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushOutbound()",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.embedded.EmbeddedChannel:void checkException()",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture flushInbound(boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeGoAwayFrame(io.netty.handler.codec.http2.Http2GoAwayFrame,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void send(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeStreamFrame(io.netty.handler.codec.http2.Http2StreamFrame,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollServerChannel$EpollServerSocketUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void release(java.lang.Throwable)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceFdTask:boolean spliceIn(io.netty.channel.RecvByteBufAllocator$Handle)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeStreamFrame(io.netty.handler.codec.http2.Http2StreamFrame,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void shutdown0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:void access$300(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void shutdownOutput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:io.netty.channel.ChannelFuture shutdownOutput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$200(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void shutdown0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel:void access$200(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.oio.OioSocketChannel:io.netty.channel.ChannelFuture shutdown(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void shutdownInput0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel:io.netty.channel.ChannelFuture shutdownInput(io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioSocketChannel:void access$200(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.util.concurrent.DefaultProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,java.lang.Iterable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setProgress(long,long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])"
        ]
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void doHealthCheckOnRelease(io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void doReleaseChannel(io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture flushInbound(boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushInbound()"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void fireChildRead0(java.lang.Object)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void fireChildReadComplete()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelReadComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$200(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec:void initOpts(io.netty.channel.Channel,java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec:io.netty.channel.ChannelFuture createStreamChannel(io.netty.channel.Channel,io.netty.channel.EventLoopGroup,io.netty.channel.ChannelHandler,java.util.Map,java.util.Map,int)"
        ]
    },
    "io.netty.channel.DefaultChannelConfig:boolean setOptions(java.util.Map)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.DefaultDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.rxtx.DefaultRxtxChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollDatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerSocketChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollDomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.oio.OioServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.DefaultSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.oio.OioSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.sctp.DefaultSctpChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverBuilder:io.netty.resolver.dns.DnsNameResolver build()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.NameResolver newNameResolver(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddresses)"
        ]
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.net.InetAddress,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap:io.netty.channel.ChannelFuture bind(java.lang.String,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.net.InetAddress,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture connect(java.lang.String,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.channel.ChannelFuture connectChannel(io.netty.bootstrap.Bootstrap)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquireHealthyFromPoolOrNew(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.MessageToByteEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeContinuationFrames(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$16:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void forceFlush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void wrapAndFlush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.ssl.SslHandler:void flushIfNeeded(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()",
            "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketEncoder:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelOutboundInvoker flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelOutboundInvoker flush()"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$900(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListenersNow()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListeners()",
            "io.netty.util.concurrent.DefaultPromise:void access$000(io.netty.util.concurrent.DefaultPromise)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void access$100(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$2:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void notifyListeners0(io.netty.util.concurrent.DefaultFutureListeners)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListenersNow()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void processGoAwayWriteResult(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void fail(io.netty.channel.ChannelHandlerContext,java.lang.String,java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$13:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1000(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$11:void run()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelUnregistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelRegistered()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.traffic.AbstractTrafficShapingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.IdleStateHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()"
        ]
    },
    "io.netty.handler.codec.MessageToMessageCodec$1:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpServerChannel$NioSctpServerChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.nio.NioSctpChannel$NioSctpChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.nio.NioServerSocketChannel$NioServerSocketChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)",
            "io.netty.channel.ChannelOutboundBuffer:boolean remove()",
            "io.netty.channel.ChannelOutboundBuffer:void addFlush()",
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)",
            "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.timeout.IdleStateHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.WebSocketClientProtocolHandshakeHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelActive()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.DatagramPacketEncoder:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.DatagramPacketEncoder:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.DatagramPacketEncoder:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$1300(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.compression.JZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsCacheEntry:void scheduleExpiration(io.netty.channel.EventLoop,java.lang.Runnable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DefaultDnsCache:void scheduleCacheExpiration(java.util.List,io.netty.resolver.dns.DnsCacheEntry,int,io.netty.channel.EventLoop)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void <init>(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void doGracefulShutdown(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture schedule(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.AbstractScheduledEventExecutor:java.util.concurrent.ScheduledFuture scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2FrameCodec$InternalHttp2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.marshalling.CompatibleMarshallingDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.handler.codec.DatagramPacketDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void notifyHandlerException(java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$400(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.handler.codec.DatagramPacketEncoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise:void access$000(io.netty.channel.VoidChannelPromise,java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpServerChannel$OioSctpServerChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.sctp.oio.OioSctpChannel$OioSctpChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:void autoReadCleared()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$800(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void access$800(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelInboundInvoker fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.handler.codec.DatagramPacketDecoder:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.util.concurrent.MultithreadEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.util.concurrent.RejectedExecutionHandler)",
            "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.Executor)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.util.concurrent.EventExecutorChooserFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.UnorderedThreadPoolEventExecutor:io.netty.util.concurrent.Future shutdownGracefully()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.proxy.ProxyHandler:void writePendingWrites()"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.PromiseCombiner$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel$DefaultUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe:void access$100(io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.rxtx.RxtxChannel$RxtxUnsafe$1:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver$SingleResolverContext:boolean finishResolve(java.lang.Class,java.util.List,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.sctp.oio.OioSctpChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeDefaultFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion,int)",
            "io.netty.handler.codec.http2.AbstractHttp2StreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.FileRegion,int)",
            "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)",
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.nio.AbstractNioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:boolean trySuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.internal.PromiseNotificationUtil:void trySuccess(io.netty.util.concurrent.Promise,java.lang.Object,io.netty.util.internal.logging.InternalLogger)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyConnect(io.netty.channel.ChannelFuture,io.netty.util.concurrent.Promise)",
            "io.netty.util.concurrent.PromiseCombiner:boolean tryPromise()",
            "io.netty.channel.DefaultChannelPromise:boolean trySuccess()",
            "io.netty.util.concurrent.UnaryPromiseNotifier:void cascadeTo(io.netty.util.concurrent.Future,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void access$000(io.netty.resolver.dns.DnsQueryContext,io.netty.handler.codec.dns.DnsQuery)",
            "io.netty.resolver.dns.DnsQueryContext:void sendQuery(io.netty.handler.codec.dns.DnsQuery)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamLocal(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void processRstStreamWriteResult(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamRemote(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onRstStreamRead(io.netty.channel.ChannelHandlerContext,int,long)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void processRstStreamWriteResult(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeConnectionOnError(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void doGracefulShutdown(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void writeHeaders(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2ConnectionEncoder,int,io.netty.handler.codec.http.HttpHeaders,io.netty.handler.codec.http2.Http2Headers,boolean,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void handleServerHeaderDecodeSizeError(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:void add(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()",
            "io.netty.util.concurrent.PromiseCombiner:void addAll(io.netty.util.concurrent.Future[])",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void query(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolve(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.InetSocketAddress,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:io.netty.util.concurrent.Future resolveAll(java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void access$900(io.netty.resolver.dns.DnsNameResolverContext,java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void internalResolve(io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void resolve(io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void access$400(io.netty.resolver.dns.DnsNameResolverContext,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void followCname(java.net.InetSocketAddress,java.lang.String,java.lang.String,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,java.util.Map,boolean,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver:void doResolveAll(java.net.SocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsQueryContext:void query()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.InetSocketAddressResolver:void doResolve(java.net.SocketAddress,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.AbstractAddressResolver:io.netty.util.concurrent.Future resolve(java.net.SocketAddress)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$ClosingChannelFutureListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void checkCloseConnection(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressiveFuture addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$100(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$3:void run()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$300(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$5:void run()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void access$400(io.netty.channel.pool.SimpleChannelPool,io.netty.channel.Channel,io.netty.util.concurrent.Promise,io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool$6:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close()"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect(io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect()"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise doneAllocatingPromises()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder$Frame:void release(java.lang.Throwable)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeContinuationFrames(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setPromise()",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)",
            "io.netty.channel.DefaultChannelPromise:io.netty.channel.ChannelPromise setSuccess()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JdkZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelProgressivePromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess()"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolverContext$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void failPendingWrites(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void setConnectFailure(java.lang.Throwable)",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void handlerRemoved0(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void doDisconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:io.netty.util.concurrent.Future access$201(io.netty.channel.pool.FixedChannelPool,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$2:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:io.netty.util.concurrent.Future acquire()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:void runTaskQueue()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void decrementAndRunTaskQueue()",
            "io.netty.channel.pool.FixedChannelPool:void access$1000(io.netty.channel.pool.FixedChannelPool)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.PromiseTask$RunnableAdapter:java.lang.Object call()"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void access$200(io.netty.resolver.dns.DnsQueryContext,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$3:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.ssl.SslHandler$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void setHandshakeFailure(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.ssl.SslHandler:void handshake(io.netty.util.concurrent.Promise)",
            "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doConnect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe:void connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWriteAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)",
            "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query(io.netty.handler.codec.dns.DnsQuestion,java.lang.Iterable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$400(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$7:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$6:void run()"
        ]
    },
    "io.netty.bootstrap.Bootstrap$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$HeadersFrame:void send(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void handleServerHeaderDecodeSizeError(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$100(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$2:void run()",
            "io.netty.channel.socket.nio.NioSocketChannel$1:void run()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void access$000(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$1:void run()"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$300(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$5:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$4:void run()"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JZlibEncoder$1:void run()"
        ]
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void access$100(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$2:void run()"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushOutbound()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void checkException()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])",
            "io.netty.channel.embedded.EmbeddedChannel:void ensureOpen()",
            "io.netty.channel.embedded.EmbeddedChannel:boolean finish(boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Exception)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onConnectionError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void writeGoAwayFrame(io.netty.handler.codec.http2.Http2GoAwayFrame,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeSettingsAck(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void send(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void writeStreamFrame(io.netty.handler.codec.http2.Http2StreamFrame,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame:void release(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.bootstrap.AbstractBootstrap$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.StreamBufferingEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$300(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$6:void run()",
            "io.netty.channel.socket.nio.NioSocketChannel$5:void run()"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void access$200(io.netty.channel.epoll.AbstractEpollStreamChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel$3:void run()",
            "io.netty.channel.epoll.AbstractEpollStreamChannel$2:void run()"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture block(java.net.InetAddress,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel:void access$200(io.netty.channel.socket.oio.OioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioSocketChannel$3:void run()"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel:void access$200(io.netty.channel.socket.nio.NioSocketChannel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioSocketChannel$3:void run()",
            "io.netty.channel.socket.nio.NioSocketChannel$4:void run()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$SpliceInChannelTask:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.ProgressivePromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListeners(io.netty.util.concurrent.GenericFutureListener[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CompleteChannelFuture:io.netty.util.concurrent.Future addListener(io.netty.util.concurrent.GenericFutureListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushInbound()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$200(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$3:void run()"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.udt.DefaultUdtServerChannelConfig:io.netty.channel.udt.UdtChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.socket.DatagramChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.epoll.EpollServerChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)",
            "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.unix.DomainSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDomainSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.socket.SocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.DefaultOioSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flush(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void closeOutboundAndChannel(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,boolean)",
            "io.netty.handler.ssl.SslHandler:void access$600(io.netty.handler.ssl.SslHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.NameResolver newNameResolver(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddresses)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.AddressResolver newResolver(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddresses)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1900(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture finishEncode(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.handler.ssl.SslHandler:void wrapNonAppData(io.netty.channel.ChannelHandlerContext,boolean)",
            "io.netty.handler.ssl.SslHandler:void finishWrap(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise,boolean,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.MessageToByteEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite0(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.ByteToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeContinuationFrames(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeadersInternal(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,boolean,int,short,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void flushIfNeeded(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void error(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController:void addFlowControlled(io.netty.handler.codec.http2.Http2Stream,io.netty.handler.codec.http2.Http2RemoteFlowController$FlowControlled)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelOutboundInvoker flush()",
            "io.netty.channel.embedded.EmbeddedChannel:void flushOutbound0()",
            "io.netty.channel.nio.AbstractNioByteChannel$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelOutboundInvoker flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$900(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$10:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise:void access$000(io.netty.util.concurrent.DefaultPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise$1:void run()"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)",
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.ChannelInitializer:boolean initChannel(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void processGoAwayWriteResult(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$1000(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void fail(io.netty.channel.ChannelHandlerContext,java.lang.String,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,java.lang.String)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.compression.JZlibEncoder$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$11:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.traffic.AbstractTrafficShapingHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.MessageToMessageEncoder:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.MessageToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,java.lang.Object,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void addFlush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void init(io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask,io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.timeout.IdleStateHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.WebSocketClientProtocolHandshakeHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$3:void run()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.AbstractBootstrap$2:void run()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1300(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$14:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DefaultDnsCache:void scheduleCacheExpiration(java.util.List,io.netty.resolver.dns.DnsCacheEntry,int,io.netty.channel.EventLoop)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DefaultDnsCache:void cache(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],java.lang.Throwable,io.netty.channel.EventLoop)",
            "io.netty.resolver.dns.DefaultDnsCache:void cache(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],java.net.InetAddress,long,io.netty.channel.EventLoop)"
        ]
    },
    "io.netty.handler.codec.marshalling.CompatibleMarshallingDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void notifyHandlerException(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush0()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$400(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$5:void run()"
        ]
    },
    "io.netty.handler.codec.DatagramPacketEncoder:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$InternalHttp2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)",
            "io.netty.handler.ssl.SslHandler:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)",
            "io.netty.handler.codec.http.HttpClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()",
            "io.netty.handler.codec.memcache.binary.BinaryMemcacheClientCodec$Decoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:void access$000(io.netty.channel.VoidChannelPromise,java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void safeSetFailure(io.netty.channel.ChannelPromise,java.lang.Throwable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$800(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$800(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$9:void run()"
        ]
    },
    "io.netty.handler.codec.DatagramPacketDecoder:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.util.concurrent.RejectedExecutionHandler)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor)"
        ]
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.proxy.ProxyHandler:void writePendingWrites()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.proxy.ProxyHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.handler.proxy.ProxyHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.proxy.ProxyHandler:void setConnectSuccess()"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.sctp.oio.OioSctpChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeDefaultFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.DefaultFileRegion,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.epoll.IovArray,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,int)",
            "io.netty.channel.socket.nio.NioSocketChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeFileRegion(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.FileRegion,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.epoll.EpollDomainSocketChannel:boolean doWriteSingle(io.netty.channel.ChannelOutboundBuffer,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeStreamFrame(io.netty.handler.codec.http2.Http2StreamFrame,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec$InternalHttp2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext:void access$000(io.netty.resolver.dns.DnsQueryContext,io.netty.handler.codec.dns.DnsQuery)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamLocal(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void writeComplete()",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void processRstStreamWriteResult(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$900(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStreamRemote(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onHeadersRead(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:int onDataRead(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeConnectionOnError(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$800(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void handleServerHeaderDecodeSizeError(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void onStreamError(io.netty.channel.ChannelHandlerContext,java.lang.Throwable,io.netty.handler.codec.http2.Http2Exception$StreamException)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void writeHeadersFrame(io.netty.handler.codec.http2.Http2HeadersFrame,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2FrameCodec:void writeStreamFrame(io.netty.handler.codec.http2.Http2StreamFrame,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.util.concurrent.PromiseCombiner:void addAll(io.netty.util.concurrent.Future[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void access$400(io.netty.resolver.dns.DnsNameResolverContext,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,java.util.Map,boolean,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseAorAAAA(io.netty.handler.codec.dns.DnsRecordType,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.AbstractAddressResolver:io.netty.util.concurrent.Future resolve(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void checkCloseConnection(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void closeStream(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$700(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.SimpleChannelPool$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool$6:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroupFuture$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object,io.netty.channel.group.ChannelMatcher)",
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture newCloseFuture()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData:void write(io.netty.channel.ChannelHandlerContext,int)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolver:io.netty.util.concurrent.Future query0(java.net.InetSocketAddress,io.netty.handler.codec.dns.DnsQuestion,io.netty.handler.codec.dns.DnsRecord[],io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.FixedChannelPool$1:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)"
        ]
    },
    "io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator:io.netty.util.concurrent.Promise setSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void releaseAndOffer(io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.resolver.dns.DnsQueryContext:void setSuccess(io.netty.channel.AddressedEnvelope)",
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)"
        ]
    },
    "io.netty.handler.codec.compression.JdkZlibEncoder:io.netty.channel.ChannelFuture access$100(io.netty.handler.codec.compression.JdkZlibEncoder,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.compression.JdkZlibEncoder$1:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelProgressivePromise:io.netty.channel.ChannelPromise setSuccess()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool$2:void onTimeout(io.netty.channel.pool.FixedChannelPool$AcquireTask)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$TimeoutTask:void run()"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void decrementAndRunTaskQueue()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool:void access$600(io.netty.channel.pool.FixedChannelPool)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool:void access$1000(io.netty.channel.pool.FixedChannelPool)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.socket.oio.OioDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.local.LocalChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.epoll.EpollDatagramChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.nio.AbstractNioMessageChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)",
            "io.netty.channel.oio.AbstractOioByteChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,java.nio.channels.ClosedChannelException,boolean)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$7:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.buffer.ByteBuf,java.util.List)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:void ensureOpen()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])",
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeInbound(java.lang.Object[])"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finish(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean finishAndReleaseAll()",
            "io.netty.channel.embedded.EmbeddedChannel:boolean finish()"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeGoAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture goAway(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2FrameCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.channel.epoll.EpollDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture joinGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel$2:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.oio.OioSocketChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.socket.nio.NioSocketChannel$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.socket.nio.NioSocketChannel$4:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$3:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollServerChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.epoll.EpollChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.socket.ServerSocketChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollServerSocketChannelConfig:io.netty.channel.ChannelConfig setAutoRead(boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.DefaultChannelConfig:boolean setOption(io.netty.channel.ChannelOption,java.lang.Object)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void closeOutboundAndChannel(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.handler.ssl.SslHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void access$600(io.netty.handler.ssl.SslHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.ssl.SslHandler$1:void run()"
        ]
    },
    "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.AddressResolver newResolver(io.netty.channel.EventLoop,io.netty.channel.ChannelFactory,io.netty.resolver.dns.DnsServerAddresses)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.AddressResolver newResolver(io.netty.util.concurrent.EventExecutor)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePing(io.netty.channel.ChannelHandlerContext,boolean,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1900(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,short,boolean,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders:void write(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeHeaders(io.netty.channel.ChannelHandlerContext,int,io.netty.handler.codec.http2.Http2Headers,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.ByteToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelOutboundInvoker flush()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.embedded.EmbeddedChannel:void flushOutbound0()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])",
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.embedded.EmbeddedChannel flushOutbound()"
        ]
    },
    "io.netty.channel.nio.AbstractNioByteChannel$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$10:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.DefaultPromise$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)",
            "io.netty.util.concurrent.ImmediateEventExecutor:void execute(java.lang.Runnable)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$1000(io.netty.channel.ChannelHandlerContext,int,long,io.netty.buffer.ByteBuf,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$4:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.ByteToMessageDecoder:void callDecode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,java.lang.String)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,int)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.sctp.SctpNotificationHandler:com.sun.nio.sctp.HandlerResult handleNotification(com.sun.nio.sctp.ShutdownNotification,java.lang.Object)",
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.local.LocalChannel:void runFinishPeerReadTask(io.netty.channel.local.LocalChannel)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec:io.netty.channel.ChannelFuture createStreamChannel(io.netty.channel.Channel,io.netty.channel.EventLoopGroup,io.netty.channel.ChannelHandler,java.util.Map,java.util.Map,int)",
            "io.netty.channel.local.LocalChannel:void doClose()",
            "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.local.LocalChannel:void doBeginRead()",
            "io.netty.resolver.dns.DnsNameResolver:void close()",
            "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)",
            "io.netty.handler.codec.http2.Http2MultiplexCodec$Http2StreamChannel:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.handler.codec.MessageToMessageCodec:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void init(io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask,io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.bootstrap.Bootstrap$3:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$14:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.resolver.dns.DefaultDnsCache:void cache(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],java.lang.Throwable,io.netty.channel.EventLoop)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void finishResolve(io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DefaultDnsCache:void cache(java.lang.String,io.netty.handler.codec.dns.DnsRecord[],java.net.InetAddress,long,io.netty.channel.EventLoop)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponseAorAAAA(io.netty.handler.codec.dns.DnsRecordType,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$5:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelInboundInvoker fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.util.concurrent.Promise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$9:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.AbstractEventExecutor:void safeExecute(java.lang.Runnable)"
        ]
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider)"
        ]
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)",
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor,java.nio.channels.spi.SelectorProvider)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.proxy.ProxyHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:void doWrite(io.netty.channel.ChannelOutboundBuffer)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,io.netty.channel.epoll.IovArray,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)"
        ]
    },
    "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytesMultiple(io.netty.channel.ChannelOutboundBuffer,java.nio.ByteBuffer[],int,long,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean doWriteMultiple(io.netty.channel.ChannelOutboundBuffer,int)",
            "io.netty.channel.epoll.AbstractEpollStreamChannel:boolean writeBytes(io.netty.channel.ChannelOutboundBuffer,io.netty.buffer.ByteBuf,int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeRstStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetUnknownStream(io.netty.channel.ChannelHandlerContext,int,long,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2ConnectionHandler:io.netty.channel.ChannelFuture resetStream(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,long,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase:void writeComplete()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$900(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Stream,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$800(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponseAorAAAA(io.netty.handler.codec.dns.DnsRecordType,io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolverContext:void onResponseCNAME(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.util.concurrent.Promise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsNameResolverContext:void onResponse(io.netty.handler.codec.dns.DnsQuestion,io.netty.channel.AddressedEnvelope,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler:void access$700(io.netty.handler.codec.http2.Http2ConnectionHandler,io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object,io.netty.channel.group.ChannelMatcher)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writeFrame(io.netty.channel.ChannelHandlerContext,byte,int,io.netty.handler.codec.http2.Http2Flags,io.netty.buffer.ByteBuf,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DecoratingHttp2FrameWriter:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.Http2OutboundFrameLogger:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writePushPromise(io.netty.channel.ChannelHandlerContext,int,int,io.netty.handler.codec.http2.Http2Headers,int,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.socket.nio.NioDatagramChannel:io.netty.channel.ChannelFuture leaveGroup(java.net.InetSocketAddress,java.net.NetworkInterface)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.pool.FixedChannelPool:void access$600(io.netty.channel.pool.FixedChannelPool)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.FixedChannelPool$4:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.pool.FixedChannelPool$AcquireListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.DnsQueryContext$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.buffer.ByteBuf,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finishAndReleaseAll()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void cleanup(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:boolean finish()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void cleanup()",
            "io.netty.handler.codec.http.HttpContentEncoder:void cleanup()",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void cleanup()",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:void cleanup(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.embedded.EmbeddedChannel)",
            "io.netty.handler.codec.http.HttpContentEncoder:void finishEncode(java.util.List)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readSettingsFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onSettingsRead(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http2.Http2Settings)"
        ]
    },
    "io.netty.handler.ssl.SslHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.ssl.SslHandler$1:void run()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.dns.DnsAddressResolverGroup:io.netty.resolver.AddressResolver newResolver(io.netty.util.concurrent.EventExecutor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.embedded.EmbeddedChannel:boolean writeOutbound(java.lang.Object[])"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.DnsQueryContext:void writeQuery(io.netty.handler.codec.dns.DnsQuery)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$4:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$4:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List)"
        ]
    },
    "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:void failOverLimit(io.netty.channel.ChannelHandlerContext,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeLine(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.haproxy.HAProxyMessageDecoder:io.netty.buffer.ByteBuf decodeStruct(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.resolver.dns.DnsNameResolver:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.dns.InflightNameResolver:void close()"
        ]
    },
    "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.pool.SimpleChannelPool:void notifyHealthCheck(io.netty.util.concurrent.Future,io.netty.channel.Channel,io.netty.util.concurrent.Promise)",
            "io.netty.channel.pool.SimpleChannelPool:void closeAndFail(io.netty.channel.Channel,java.lang.Throwable,io.netty.util.concurrent.Promise)"
        ]
    },
    "io.netty.channel.embedded.EmbeddedChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.bootstrap.Bootstrap:io.netty.channel.ChannelFuture doResolveAndConnect0(io.netty.channel.Channel,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.bootstrap.Bootstrap$2:void operationComplete(io.netty.util.concurrent.Future)",
            "io.netty.channel.embedded.EmbeddedChannel:boolean finish(boolean)",
            "io.netty.channel.pool.SimpleChannelPool:void closeChannel(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask access$1700(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask access$1600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.VoidChannelPromise$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.util.concurrent.DefaultEventExecutorGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,java.nio.channels.spi.SelectorProvider)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>(int)",
            "io.netty.channel.DefaultEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,io.netty.channel.SelectStrategyFactory)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.group.DefaultChannelGroup:io.netty.channel.group.ChannelGroupFuture flushAndWrite(java.lang.Object)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.HttpObject,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void cleanup(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void access$000(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void cleanup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void decode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void cleanup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.HttpContentEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void cleanup()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)",
            "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void encode(io.netty.channel.ChannelHandlerContext,io.netty.handler.codec.http.websocketx.WebSocketFrame,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:void cleanup(io.netty.handler.codec.http2.Http2Stream,io.netty.channel.embedded.EmbeddedChannel)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)",
            "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder:io.netty.channel.ChannelFuture writeData(io.netty.channel.ChannelHandlerContext,int,io.netty.buffer.ByteBuf,int,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void finishEncode(java.util.List)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http.HttpContentEncoder:boolean encodeContent(io.netty.handler.codec.http.HttpContent,java.util.List)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)",
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void processPayloadState(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DefaultHttp2FrameReader:void readPingFrame(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,io.netty.handler.codec.http2.Http2FrameListener)",
            "io.netty.handler.codec.http2.Http2InboundFrameLogger$1:void onPingRead(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$4:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.resolver.dns.InflightNameResolver:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.InetSocketAddressResolver:void close()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask access$1700(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask access$1600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.DefaultEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.local.LocalEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,java.util.concurrent.ThreadFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int,io.netty.channel.SelectStrategyFactory)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.nio.NioEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.Http2ConnectionHandler$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener:void access$000(io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$Http2Decompressor)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)"
        ]
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateDecoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.HttpContentEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http.websocketx.extensions.compression.DeflateEncoder:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.CompressorHttp2ConnectionEncoder$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.InetSocketAddressResolver:void close()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.resolver.AddressResolverGroup$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.local.LocalEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>(int)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.channel.epoll.EpollEventLoopGroup:void <init>()"
        ]
    },
    "io.netty.channel.nio.NioEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.handler.codec.http2.DelegatingDecompressorFrameListener$1:void onStreamRemoved(io.netty.handler.codec.http2.Http2Stream)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    },
    "io.netty.resolver.AddressResolverGroup$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": [
            "io.netty.util.concurrent.DefaultPromise:void notifyListener0(io.netty.util.concurrent.Future,io.netty.util.concurrent.GenericFutureListener)"
        ]
    },
    "io.netty.channel.epoll.EpollEventLoopGroup:void <init>()": {
        "isVulRoot": false,
        "srcRoot": [
            "io.netty.handler.codec.http.HttpObjectDecoder:void splitHeader(io.netty.util.internal.AppendableCharSequence)"
        ],
        "vulCaller": []
    }
}