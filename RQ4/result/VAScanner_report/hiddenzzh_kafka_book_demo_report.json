{
    "project name": "hiddenzzh_kafka_book_demo",
    "vulnerable dependencies": {
        "org.apache.kafka:kafka-clients:2.0.0": {
            "used-method num": 126,
            "used method": [
                "org.apache.kafka.clients.consumer.KafkaConsumer:void close()",
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection)",
                "org.apache.kafka.common.config.ConfigResource$Type:void <clinit>()",
                "org.apache.kafka.common.Node:int hashCode()",
                "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String)",
                "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()",
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Properties)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void <clinit>()",
                "org.apache.kafka.common.utils.LogContext$LocationAwareKafkaLogger:void error(java.lang.String,java.lang.Throwable)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)",
                "org.apache.kafka.clients.producer.KafkaProducer:void commitTransaction()",
                "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.Iterator iterator()",
                "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:void <init>()",
                "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.List records(org.apache.kafka.common.TopicPartition)",
                "org.apache.kafka.common.errors.PolicyViolationException:void <init>(java.lang.String)",
                "org.apache.kafka.clients.producer.KafkaProducer:void close()",
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult listConsumerGroupOffsets(java.lang.String)",
                "org.apache.kafka.common.requests.MetadataResponse$TopicMetadata:void <init>(org.apache.kafka.common.protocol.Errors,java.lang.String,boolean,java.util.List)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
                "org.apache.kafka.common.utils.AbstractIterator:java.lang.Object next()",
                "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()",
                "org.apache.kafka.clients.producer.KafkaProducer:void <clinit>()",
                "org.apache.kafka.clients.consumer.ConsumerRecord:long offset()",
                "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
                "org.apache.kafka.clients.producer.ProducerRecord:java.lang.Long timestamp()",
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection)",
                "org.apache.kafka.common.utils.ImplicitLinkedHashSet$ImplicitLinkedHashSetIterator:boolean hasNext()",
                "org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription:java.util.List topics()",
                "org.apache.kafka.common.serialization.Serdes:org.apache.kafka.common.serialization.Serde String()",
                "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object put(java.lang.Object,java.lang.Object)",
                "org.apache.kafka.common.internals.KafkaFutureImpl:java.lang.Object get()",
                "org.apache.kafka.clients.admin.ConfigEntry:void <init>(java.lang.String,java.lang.String)",
                "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Long,java.lang.Object,java.lang.Object,java.lang.Iterable)",
                "org.apache.kafka.clients.producer.ProducerRecord:java.lang.Object key()",
                "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture all()",
                "org.apache.kafka.common.header.internals.RecordHeader:byte[] value()",
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map)",
                "org.apache.kafka.common.utils.LogContext$LocationIgnorantKafkaLogger:void error(java.lang.String,java.lang.Throwable)",
                "org.apache.kafka.common.requests.MetadataResponse:void <init>(int,java.util.List,java.lang.String,int,java.util.List)",
                "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object,java.lang.Object)",
                "org.apache.kafka.common.utils.LogContext$LocationAwareKafkaLogger:void error(java.lang.String,java.lang.Object,java.lang.Object)",
                "org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata:void <init>(org.apache.kafka.common.protocol.Errors,int,org.apache.kafka.common.Node,java.util.List,java.util.List,java.util.List)",
                "org.apache.kafka.common.record.DefaultRecordBatch$RecordIterator:org.apache.kafka.common.record.Record next()",
                "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
                "org.apache.kafka.clients.producer.RecordMetadata:int partition()",
                "org.apache.kafka.common.header.internals.RecordHeader:java.lang.String key()",
                "org.apache.kafka.common.utils.LogContext$LocationIgnorantKafkaLogger:void error(java.lang.String,java.lang.Object,java.lang.Object)",
                "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.List partitions(java.lang.String,int)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void seek(org.apache.kafka.common.TopicPartition,long)",
                "org.apache.kafka.common.header.internals.RecordHeaders:java.util.Iterator iterator()",
                "org.apache.kafka.common.protocol.Errors:void <clinit>()",
                "org.ietf.jgss.GSSException:java.lang.String getMessage()",
                "org.apache.kafka.common.serialization.Serdes:org.apache.kafka.common.serialization.Serde Long()",
                "org.apache.kafka.clients.admin.CreatePartitionsResult:org.apache.kafka.common.KafkaFuture all()",
                "org.apache.kafka.common.Node:void <clinit>()",
                "org.apache.kafka.clients.producer.ProducerRecord:org.apache.kafka.common.header.Headers headers()",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync()",
                "org.apache.kafka.clients.consumer.ConsumerRecords:void <clinit>()",
                "org.apache.kafka.common.Cluster:java.util.List partitionsForTopic(java.lang.String)",
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection)",
                "org.apache.kafka.common.requests.MetadataResponse:void <clinit>()",
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection)",
                "org.apache.kafka.clients.producer.RecordMetadata:java.lang.String topic()",
                "org.apache.kafka.clients.consumer.ConsumerRecords:void <init>(java.util.Map)",
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map)",
                "org.apache.kafka.common.Node:void <init>(int,java.lang.String,int)",
                "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)",
                "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object get(java.lang.Object)",
                "org.apache.kafka.common.TopicPartition:void <init>(java.lang.String,int)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
                "org.apache.kafka.common.utils.ImplicitLinkedHashSet:java.util.Iterator iterator()",
                "org.apache.kafka.clients.consumer.ConsumerRecords:boolean isEmpty()",
                "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:void put(java.util.Map,java.lang.Object,java.lang.Object)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection)",
                "org.apache.kafka.clients.admin.DeleteTopicsResult:org.apache.kafka.common.KafkaFuture all()",
                "org.apache.kafka.common.config.ConfigResource:void <init>(org.apache.kafka.common.config.ConfigResource$Type,java.lang.String)",
                "org.apache.kafka.common.header.internals.RecordHeader:void <init>(java.lang.String,byte[])",
                "org.apache.kafka.clients.admin.AlterConfigsResult:org.apache.kafka.common.KafkaFuture all()",
                "org.apache.kafka.clients.admin.DescribeTopicsResult:org.apache.kafka.common.KafkaFuture all()",
                "org.apache.kafka.common.header.internals.RecordHeaders$2:boolean hasNext()",
                "org.apache.kafka.common.utils.Utils:int toPositive(int)",
                "org.apache.kafka.clients.consumer.OffsetAndMetadata:void <init>(long)",
                "org.apache.kafka.clients.producer.ProducerRecord:java.lang.Object value()",
                "org.apache.kafka.clients.producer.KafkaProducer:void beginTransaction()",
                "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers add(org.apache.kafka.common.header.Header)",
                "org.apache.kafka.clients.admin.NewPartitions:org.apache.kafka.clients.admin.NewPartitions increaseTo(int)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map)",
                "org.apache.kafka.clients.producer.KafkaProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)",
                "org.apache.kafka.common.config.AbstractConfig$RecordingMap:java.lang.Object get(java.lang.Object)",
                "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord)",
                "org.apache.kafka.clients.consumer.ConsumerRecord:int partition()",
                "org.apache.kafka.clients.consumer.ConsumerRecord:java.lang.String topic()",
                "org.apache.kafka.common.utils.CopyOnWriteMap:java.util.Set entrySet()",
                "org.apache.kafka.common.utils.Utils:void <clinit>()",
                "org.apache.kafka.common.TopicPartition:java.lang.String topic()",
                "org.apache.kafka.clients.producer.internals.FutureRecordMetadata:org.apache.kafka.clients.producer.RecordMetadata get()",
                "org.apache.kafka.clients.admin.NewTopic:void <init>(java.lang.String,java.util.Map)",
                "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
                "org.apache.kafka.clients.producer.ProducerRecord:java.lang.Integer partition()",
                "org.apache.kafka.common.header.internals.RecordHeaders$2:org.apache.kafka.common.header.Header next()",
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync()",
                "org.apache.kafka.common.utils.Utils:int murmur2(byte[])",
                "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object)",
                "org.apache.kafka.clients.producer.KafkaProducer:void initTransactions()",
                "org.apache.kafka.common.record.DefaultRecordBatch$RecordIterator:boolean hasNext()",
                "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)",
                "org.apache.kafka.common.Node:boolean equals(java.lang.Object)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Set assignment()",
                "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String topic()",
                "org.apache.kafka.common.header.internals.RecordHeaders:void <init>()",
                "org.apache.kafka.common.utils.ImplicitLinkedHashSet$ImplicitLinkedHashSetIterator:org.apache.kafka.common.utils.ImplicitLinkedHashSet$Element next()",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties)",
                "org.apache.kafka.clients.producer.KafkaProducer$FutureFailure:org.apache.kafka.clients.producer.RecordMetadata get()",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection)",
                "org.apache.kafka.common.utils.AbstractIterator:boolean hasNext()",
                "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.Set partitions()",
                "org.apache.kafka.common.TopicPartition:int partition()",
                "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition)",
                "org.apache.kafka.clients.producer.KafkaProducer:void abortTransaction()",
                "org.apache.kafka.common.errors.SerializationException:void <init>(java.lang.String)",
                "org.apache.kafka.common.utils.CopyOnWriteMap:boolean containsKey(java.lang.Object)",
                "org.apache.kafka.clients.admin.DescribeConfigsResult:org.apache.kafka.common.KafkaFuture all()"
            ],
            "CVE": [
                "CVE-2023-25194"
            ],
            "used vul-method": [
                "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Properties)",
                "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)",
                "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties)"
            ],
            "vul-called frequency": 32,
            "related vul root method": {
                "CVE-2023-25194": [
                    "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext defaultContext(org.apache.kafka.common.security.JaasContext$Type,java.lang.String,java.lang.String)",
                    "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext load(org.apache.kafka.common.security.JaasContext$Type,java.lang.String,java.lang.String,org.apache.kafka.common.config.types.Password)"
                ]
            },
            "CVE-API": {
                "CVE-2023-25194": [
                    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Properties)",
                    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)",
                    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties)"
                ]
            }
        },
        "junit:junit:4.11": {
            "used-method num": 0,
            "used method": []
        }
    }
}