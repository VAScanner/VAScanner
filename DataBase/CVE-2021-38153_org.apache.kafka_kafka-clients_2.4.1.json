{
    "org.apache.kafka.common.security.plain.internals.PlainServerCallbackHandler:boolean authenticate(java.lang.String,char[])": {
        "isVulRoot": true,
        "vulCaller": [
            "org.apache.kafka.common.security.plain.internals.PlainServerCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.plain.internals.PlainServerCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyToken()",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:org.apache.kafka.common.security.auth.SaslExtensions retrieveCustomExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.util.Map processExtensions(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyToken()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyExtensions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] lambda$createSaslToken$1(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:org.apache.kafka.common.security.auth.SaslExtensions retrieveCustomExtensions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.util.Map processExtensions(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,org.apache.kafka.common.security.auth.SaslExtensions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] lambda$createSaslToken$1(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] lambda$createSaslToken$1(byte[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] evaluateResponse(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void reauthenticate(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.network.KafkaChannel:void prepare()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void reauthenticate(org.apache.kafka.common.network.ReauthenticationContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:void prepare()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginServerReauthentication(org.apache.kafka.common.network.NetworkReceive,java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginClientReauthentication(java.util.function.Supplier)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginServerReauthentication(org.apache.kafka.common.network.NetworkReceive,java.util.function.Supplier)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginClientReauthentication(java.util.function.Supplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void poll(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void runOnce()",
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendAndPollTransactionalRequest()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()",
            "org.apache.kafka.clients.NetworkClientUtils:boolean isReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void transmitSends()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void runOnce()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendAndPollTransactionalRequest()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void runOnce()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void transitionState(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchState,java.lang.Runnable)",
            "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()"
        ]
    },
    "org.apache.kafka.clients.NetworkClientUtils:boolean isReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.Node awaitNodeReady(org.apache.kafka.common.requests.FindCoordinatorRequest$CoordinatorType)"
        ]
    },
    "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.clients.ClientResponse sendAndAwaitInitProducerIdRequest(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void pollNoWakeup()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void transmitSends()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void transitionState(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchState,java.lang.Runnable)",
            "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void transitionState(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchState,java.lang.Runnable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void reset(org.apache.kafka.clients.consumer.OffsetResetStrategy)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void validatePosition(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void completeValidation()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void seekValidated(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void validate(javax.net.ssl.SSLEngine,javax.net.ssl.SSLEngine)"
        ]
    },
    "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslTransportLayer:void doHandshake()",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult handshakeWrap(boolean)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult handshakeUnwrap(boolean,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.Node awaitNodeReady(org.apache.kafka.common.requests.FindCoordinatorRequest$CoordinatorType)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendAndPollTransactionalRequest()",
            "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.clients.ClientResponse sendAndAwaitInitProducerIdRequest(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollForFetches(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean poll(org.apache.kafka.clients.consumer.internals.RequestFuture,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void pollNoWakeup()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1:void onSuccess(java.lang.Void)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture maybeLeaveGroup(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(org.apache.kafka.common.utils.Timer,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void reset(org.apache.kafka.clients.consumer.OffsetResetStrategy)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$1900(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,org.apache.kafka.clients.consumer.OffsetResetStrategy)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void validatePosition(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:boolean maybeValidatePosition(org.apache.kafka.clients.Metadata$LeaderAndEpoch)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void seekUnvalidated(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void completeValidation()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$800(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void seekValidated(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void seekUnvalidated(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$000(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void validate(javax.net.ssl.SSLEngine,javax.net.ssl.SSLEngine)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void validate(org.apache.kafka.common.security.ssl.SslEngineBuilder,org.apache.kafka.common.security.ssl.SslEngineBuilder)"
        ]
    },
    "org.apache.kafka.common.network.SslTransportLayer:void doHandshake()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslTransportLayer:void handshake()"
        ]
    },
    "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult handshakeWrap(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslTransportLayer:void doHandshake()"
        ]
    },
    "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult handshakeUnwrap(boolean,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslTransportLayer:void handshake()",
            "org.apache.kafka.common.network.SslTransportLayer:void doHandshake()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void runOnce()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollForFetches(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean poll(org.apache.kafka.clients.consumer.internals.RequestFuture,org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult fetchOffsetsByTimes(java.util.Map,org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitMetadataUpdate(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitPendingRequests(org.apache.kafka.common.Node,org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1:void onSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doAutoCommitOffsetsAsync()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture maybeLeaveGroup(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void unsubscribe()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void transitionState(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchState,java.lang.Runnable)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void startHeartbeatThreadIfNeeded()",
            "org.apache.kafka.common.memory.GarbageCollectedMemoryPool:void <init>(long,int,boolean,org.apache.kafka.common.metrics.Sensor)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator)",
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()",
            "org.apache.kafka.common.utils.Shell:void runCommand()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$1900(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,org.apache.kafka.clients.consumer.OffsetResetStrategy)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestOffsetReset(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetResetStrategy)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void lambda$requestOffsetReset$3(org.apache.kafka.clients.consumer.OffsetResetStrategy,org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:boolean maybeValidatePosition(org.apache.kafka.clients.Metadata$LeaderAndEpoch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:boolean access$500(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,org.apache.kafka.clients.Metadata$LeaderAndEpoch)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void seekUnvalidated(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$100(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$800(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Optional maybeCompleteValidation(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition,org.apache.kafka.common.requests.EpochEndOffset)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void completeValidation(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$000(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void seekValidated(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Optional maybeCompleteValidation(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition,org.apache.kafka.common.requests.EpochEndOffset)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void validate(org.apache.kafka.common.security.ssl.SslEngineBuilder,org.apache.kafka.common.security.ssl.SslEngineBuilder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslEngineBuilder createNewSslEngineBuilder(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.network.SslTransportLayer:void handshake()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void prepare()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set,org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map committed(java.util.Set,java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsSync(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getAllTopicMetadata(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult fetchOffsetsByTimes(java.util.Map,org.apache.kafka.common.utils.Timer,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitMetadataUpdate(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean ensureFreshMetadata(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult fetchOffsetsByTimes(java.util.Map,org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitPendingRequests(org.apache.kafka.common.Node,org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doAutoCommitOffsetsAsync()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsAsync(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void unsubscribe()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void startHeartbeatThreadIfNeeded()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.common.memory.GarbageCollectedMemoryPool:void <init>(long,int,boolean,org.apache.kafka.common.metrics.Sensor)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.login.LoginContext login()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:javax.security.auth.login.LoginContext login()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin:javax.security.auth.login.LoginContext login()"
        ]
    },
    "org.apache.kafka.common.utils.Shell:void runCommand()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Shell:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestOffsetReset(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetResetStrategy)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestOffsetReset(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void lambda$requestOffsetReset$3(org.apache.kafka.clients.consumer.OffsetResetStrategy,org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$lambda_requestOffsetReset_3__282:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:boolean access$500(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,org.apache.kafka.clients.Metadata$LeaderAndEpoch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean maybeValidatePositionForCurrentLeader(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.Metadata$LeaderAndEpoch)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$100(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void seekUnvalidated(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void maybeSeekUnvalidated(org.apache.kafka.common.TopicPartition,long,org.apache.kafka.clients.consumer.OffsetResetStrategy)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Optional maybeCompleteValidation(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition,org.apache.kafka.common.requests.EpochEndOffset)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void lambda$onSuccess$1(java.util.Map,java.util.Map,org.apache.kafka.common.TopicPartition,org.apache.kafka.common.requests.EpochEndOffset)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void completeValidation(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void seekValidated(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void seek(org.apache.kafka.common.TopicPartition,long)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.Object,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.security.ssl.SslPrincipalMapper)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslEngineBuilder createNewSslEngineBuilder(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:void validateReconfiguration(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void reconfigure(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map committed(java.util.Set,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map committed(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateFetchPositions(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsSync(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinPrepare(int,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateAssignmentMetadataIfNeeded(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void ensureActiveGroup()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getAllTopicMetadata(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics(java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOffsets(java.util.Collection,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map endOffsets(java.util.Collection,org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean ensureFreshMetadata(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void updateGroupSubscription(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void complete(java.lang.Object)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void addListener(org.apache.kafka.clients.consumer.internals.RequestFutureListener)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsAsync(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.Admin create(java.util.Properties)",
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.Admin create(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin:javax.security.auth.login.LoginContext login()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)"
        ]
    },
    "org.apache.kafka.common.utils.Shell:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Shell$ShellCommandExecutor:void execute()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestOffsetReset(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void lambda$resetMissingPositions$7(java.util.Set,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$lambda_requestOffsetReset_3__282:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean maybeValidatePositionForCurrentLeader(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.Metadata$LeaderAndEpoch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$prepareFetchRequests$8(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsIfNeeded$1(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void seekUnvalidated(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchPosition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seek(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seek(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetAndMetadata)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void maybeSeekUnvalidated(org.apache.kafka.common.TopicPartition,long,org.apache.kafka.clients.consumer.OffsetResetStrategy)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetIfNeeded(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetResetStrategy,org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetData)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$3:void lambda$onSuccess$1(java.util.Map,java.util.Map,org.apache.kafka.common.TopicPartition,org.apache.kafka.common.requests.EpochEndOffset)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$3$lambda_onSuccess_1__335:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_validateOffsetsAsync_5__319:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void seek(org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void seek(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.MockConsumer:void seek(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetAndMetadata)",
            "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.Object,java.lang.Class,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.security.ssl.SslPrincipalMapper)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.SslTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.ssl.SslPrincipalMapper)",
            "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.PlaintextTransportLayer,org.apache.kafka.common.network.ListenerName)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.Object,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.security.ssl.SslPrincipalMapper)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder:void configure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.Object,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.security.ssl.SslPrincipalMapper)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:void validateReconfiguration(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void validateReconfiguration(java.util.Map)",
            "org.apache.kafka.common.network.SslChannelBuilder:void validateReconfiguration(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:void reconfigure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void reconfigure(java.util.Map)",
            "org.apache.kafka.common.network.SslChannelBuilder:void reconfigure(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map committed(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateFetchPositions(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateAssignmentMetadataIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinPrepare(int,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateAssignmentMetadataIfNeeded(org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void ensureActiveGroup()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOffsets(java.util.Collection,org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map endOffsets(java.util.Collection,org.apache.kafka.common.utils.Timer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,java.util.concurrent.TimeUnit)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void close()"
        ]
    },
    "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.FileRecords:boolean deleteIfExists()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void close()",
            "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void close()",
            "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void close()"
        ]
    },
    "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void close(java.time.Duration,boolean)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)",
            "org.apache.kafka.common.network.Selector:void close()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void updateGroupSubscription(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void complete(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(org.apache.kafka.common.requests.LeaveGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture voidSuccess()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$RequestFutureCompletionHandler:void fireCompletion()",
            "org.apache.kafka.clients.consumer.internals.RequestFuture$2:void onSuccess(java.lang.Object)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.AsyncClient$1:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void addListener(org.apache.kafka.clients.consumer.internals.RequestFutureListener)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture compose(org.apache.kafka.clients.consumer.internals.RequestFutureAdapter)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void chain(org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doCommitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture initiateJoinGroup()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.Admin create(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Properties)"
        ]
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.Admin create(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.utils.Shell$ShellCommandExecutor:void execute()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Shell:java.lang.String execCommand(java.lang.String[],long)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:long position(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void lambda$resetMissingPositions$7(java.util.Set,org.apache.kafka.common.internals.PartitionStates$PartitionState)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$lambda_resetMissingPositions_7__287:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map fetchedRecords()"
        ]
    },
    "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$prepareFetchRequests$8(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_prepareFetchRequests_8__322:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsIfNeeded$1(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_validateOffsetsIfNeeded_1__313:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void seek(org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void seek(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetAndMetadata)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetIfNeeded(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetResetStrategy,org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void access$2700(org.apache.kafka.clients.consumer.internals.Fetcher,org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetResetStrategy,org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetData)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$3$lambda_onSuccess_1__335:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_validateOffsetsAsync_5__319:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void seek(org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void resetOffsetPosition(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void seek(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetAndMetadata)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.security.authenticator.SaslServerAuthenticator buildServerAuthenticator(java.util.Map,java.util.Map,java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.SslTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.ssl.SslPrincipalMapper)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.SslTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.ssl.SslPrincipalMapper,org.apache.kafka.common.network.SslChannelBuilder$1)"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.PlaintextTransportLayer,org.apache.kafka.common.network.ListenerName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.PlaintextTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.network.PlaintextChannelBuilder$1)"
        ]
    },
    "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder clientChannelBuilder(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,java.lang.String,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder serverChannelBuilder(org.apache.kafka.common.network.ListenerName,boolean,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void validateReconfiguration(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SslChannelBuilder:void validateReconfiguration(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void reconfigure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SslChannelBuilder:void reconfigure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.KafkaChannel:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void doClose(org.apache.kafka.common.network.KafkaChannel,boolean)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier,org.apache.kafka.common.record.AbstractLegacyRecordBatch$1)"
        ]
    },
    "org.apache.kafka.common.record.FileRecords:boolean deleteIfExists()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void reauthenticate(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void close(java.time.Duration,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.KafkaProducer:void close(java.time.Duration)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void close()",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(org.apache.kafka.common.requests.LeaveGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture voidSuccess()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$RequestFutureCompletionHandler:void fireCompletion()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void firePendingCompletedRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture$2:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AsyncClient$1:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AsyncClient$1:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void access$2900(org.apache.kafka.clients.consumer.internals.Fetcher,java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture compose(org.apache.kafka.clients.consumer.internals.RequestFutureAdapter)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendFindCoordinatorRequest(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture maybeLeaveGroup(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendHeartbeatRequest()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetRequest(org.apache.kafka.common.Node,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AsyncClient:org.apache.kafka.clients.consumer.internals.RequestFuture sendAsyncRequest(org.apache.kafka.common.Node,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void chain(org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doCommitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void access$1100(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture initiateJoinGroup()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(org.apache.kafka.common.utils.Timer,boolean)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollForFetches(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult fetchOffsetsByTimes(java.util.Map,org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.Shell:java.lang.String execCommand(java.lang.String[],long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Shell:java.lang.String execCommand(java.lang.String[])"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:long position(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$lambda_resetMissingPositions_7__287:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map fetchedRecords()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollForFetches(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void update(int,org.apache.kafka.common.requests.MetadataResponse,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void handleFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean canRetry(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_prepareFetchRequests_8__322:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_validateOffsetsIfNeeded_1__313:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void access$2700(org.apache.kafka.clients.consumer.internals.Fetcher,org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetResetStrategy,org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$LambdaValidator:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef$1:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void resetOffsetPosition(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.metrics.Metrics buildMetrics(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.utils.Time,java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.security.authenticator.SaslServerAuthenticator buildServerAuthenticator(java.util.Map,java.util.Map,java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$0(java.lang.String,org.apache.kafka.common.network.TransportLayer)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.SslTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.ssl.SslPrincipalMapper,org.apache.kafka.common.network.SslChannelBuilder$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$0(org.apache.kafka.common.network.SslTransportLayer)"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.PlaintextTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.network.PlaintextChannelBuilder$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.PlaintextChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$0(org.apache.kafka.common.network.PlaintextTransportLayer)"
        ]
    },
    "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder clientChannelBuilder(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,java.lang.String,org.apache.kafka.common.utils.Time,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:org.apache.kafka.common.network.ChannelBuilder createChannelBuilder(org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder serverChannelBuilder(org.apache.kafka.common.network.ListenerName,boolean,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void doClose(org.apache.kafka.common.network.KafkaChannel,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:void close(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void close(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.Selector$CloseMode)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier,org.apache.kafka.common.record.AbstractLegacyRecordBatch$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator iterator(org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void close(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.Producer:void close(long,java.util.concurrent.TimeUnit)",
            "org.apache.kafka.clients.producer.KafkaProducer:void close()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void close()",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1300(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.requests.JoinGroupResponse)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doCommitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void firePendingCompletedRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AsyncClient$1:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void access$2900(org.apache.kafka.clients.consumer.internals.Fetcher,java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$5:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set,org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture initiateJoinGroup()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinFollower()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendFindCoordinatorRequest(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture lookupCoordinator()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendHeartbeatRequest()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetRequest(org.apache.kafka.common.Node,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AsyncClient:org.apache.kafka.clients.consumer.internals.RequestFuture sendAsyncRequest(org.apache.kafka.common.Node,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void access$1100(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1:void onSuccess(java.lang.Void)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateFetchPositions(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.common.utils.Shell:java.lang.String execCommand(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin:void lambda$login$0()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.Metadata:void update(int,org.apache.kafka.common.requests.MetadataResponse,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.requests.MetadataResponse,long)",
            "org.apache.kafka.clients.producer.internals.ProducerMetadata:void update(int,org.apache.kafka.common.requests.MetadataResponse,long)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleSuccessfulResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void handleFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,java.lang.RuntimeException,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:boolean canRetry(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean canRetry(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef$1:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef defineInternal(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance)",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$1:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef$1:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.metrics.Metrics buildMetrics(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.utils.Time,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$0(java.lang.String,org.apache.kafka.common.network.TransportLayer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder$lambda_buildChannel_0__5:java.lang.Object get()"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$0(org.apache.kafka.common.network.SslTransportLayer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslChannelBuilder$lambda_buildChannel_0__6:java.lang.Object get()"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$0(org.apache.kafka.common.network.PlaintextTransportLayer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.PlaintextChannelBuilder$lambda_buildChannel_0__7:java.lang.Object get()"
        ]
    },
    "org.apache.kafka.clients.ClientUtils:org.apache.kafka.common.network.ChannelBuilder createChannelBuilder(org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void clear()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void close(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.common.network.Selector:void close()"
        ]
    },
    "org.apache.kafka.common.network.Selector:void close(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.Selector$CloseMode)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void send(org.apache.kafka.common.network.Send)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)",
            "org.apache.kafka.common.network.Selector:void close(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void handleCloseOnAuthenticationFailure(org.apache.kafka.common.network.KafkaChannel)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator iterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$ByteBufferLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator skipKeyValueIterator(org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.clients.producer.Producer:void close(long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1300(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.requests.JoinGroupResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$5:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$5:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinFollower()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1400(org.apache.kafka.clients.consumer.internals.AbstractCoordinator)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture lookupCoordinator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:void lambda$login$0()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin$lambda_login_0__341:void run()"
        ]
    },
    "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.requests.MetadataResponse,long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.ProducerMetadata:void update(int,org.apache.kafka.common.requests.MetadataResponse,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.requests.MetadataResponse,long)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleSuccessfulResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleSuccessfulResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:boolean canRetry(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef defineInternal(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SaslChannelBuilder$lambda_buildChannel_0__5:java.lang.Object get()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult handleCachedTransactionRequestResult(java.util.function.Supplier,org.apache.kafka.clients.producer.internals.TransactionManager$State)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void updatePreferredReadReplica(int,java.util.function.Supplier)",
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:java.lang.String toString()",
            "org.apache.kafka.common.network.KafkaChannel:void <init>(java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.function.Supplier,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginServerReauthentication(org.apache.kafka.common.network.NetworkReceive,java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginClientReauthentication(java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.utils.SystemTime:void waitObject(java.lang.Object,java.util.function.Supplier,long)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder$lambda_buildChannel_0__6:java.lang.Object get()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult handleCachedTransactionRequestResult(java.util.function.Supplier,org.apache.kafka.clients.producer.internals.TransactionManager$State)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void updatePreferredReadReplica(int,java.util.function.Supplier)",
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:java.lang.String toString()",
            "org.apache.kafka.common.network.KafkaChannel:void <init>(java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.function.Supplier,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginServerReauthentication(org.apache.kafka.common.network.NetworkReceive,java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginClientReauthentication(java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.utils.SystemTime:void waitObject(java.lang.Object,java.util.function.Supplier,long)"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder$lambda_buildChannel_0__7:java.lang.Object get()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult handleCachedTransactionRequestResult(java.util.function.Supplier,org.apache.kafka.clients.producer.internals.TransactionManager$State)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void updatePreferredReadReplica(int,java.util.function.Supplier)",
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:java.lang.String toString()",
            "org.apache.kafka.common.network.KafkaChannel:void <init>(java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.function.Supplier,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginServerReauthentication(org.apache.kafka.common.network.NetworkReceive,java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginClientReauthentication(java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.utils.SystemTime:void waitObject(java.lang.Object,java.util.function.Supplier,long)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void handlePendingDisconnects()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void send(org.apache.kafka.common.network.Send)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long,org.apache.kafka.common.requests.AbstractRequest)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void handleCloseOnAuthenticationFailure(org.apache.kafka.common.network.KafkaChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void access$300(org.apache.kafka.common.network.Selector,org.apache.kafka.common.network.KafkaChannel)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch$ByteBufferLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator skipKeyValueIterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$5:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1400(org.apache.kafka.clients.consumer.internals.AbstractCoordinator)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin$lambda_login_0__341:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void transitionState(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchState,java.lang.Runnable)",
            "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void runOnce()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,java.lang.RuntimeException,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.List validate(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Set configNames()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:org.apache.kafka.common.config.ConfigDef configDef()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult handleCachedTransactionRequestResult(java.util.function.Supplier,org.apache.kafka.clients.producer.internals.TransactionManager$State)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult initializeTransactions()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult beginCommit()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult beginAbort()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void updatePreferredReadReplica(int,java.util.function.Supplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$1600(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,int,java.util.function.Supplier)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$LambdaValidator:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef$1:java.lang.String toString()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:void <init>(java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.function.Supplier,int,org.apache.kafka.common.memory.MemoryPool)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.PlaintextChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.SslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)"
        ]
    },
    "org.apache.kafka.common.utils.SystemTime:void waitObject(java.lang.Object,java.util.function.Supplier,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerMetadata:void awaitUpdate(int,long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void handlePendingDisconnects()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long,org.apache.kafka.common.requests.AbstractRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void access$300(org.apache.kafka.common.network.Selector,org.apache.kafka.common.network.KafkaChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector$DelayedAuthenticationFailureClose:void closeNow()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void flush()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void maybeAbortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void runOnce()",
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendAndPollTransactionalRequest()"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable:java.util.Iterator iterator()"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:java.lang.Object makeNext()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerMetrics:void main(java.lang.String[])",
            "org.apache.kafka.clients.consumer.internals.ConsumerMetrics:void main(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:int validBytes()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.ConvertedRecords downConvert(byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.ConvertedRecords downConvert(byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()"
        ]
    },
    "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.AbstractRecords$1:void <init>(org.apache.kafka.common.record.AbstractRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords:java.util.Iterator recordsIterator()"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords$1:java.lang.Object makeNext()"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.TimestampType,long,short,int,int,boolean,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:void maybeEnsureValid(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$LegacyFileChannelRecordBatch:long baseOffset()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Long,java.lang.Object,java.lang.Object,java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:java.util.List fetchRecords(int)"
        ]
    },
    "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void access$100(org.apache.kafka.clients.producer.internals.Sender,org.apache.kafka.clients.ClientResponse,java.util.Map,long)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.List validate(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Set configNames()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:org.apache.kafka.common.config.ConfigDef configDef()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult initializeTransactions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void initTransactions()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult beginCommit()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void commitTransaction()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult beginAbort()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run()",
            "org.apache.kafka.clients.producer.KafkaProducer:void abortTransaction()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void access$1600(org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState,int,java.util.function.Supplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void updatePreferredReadReplica(org.apache.kafka.common.TopicPartition,int,java.util.function.Supplier)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void getConfigKeyRst(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.StringBuilder)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef$1:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef$1:java.lang.String toString()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleTokenCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:java.lang.String toString()",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterConfigsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.ListOffsetResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:java.lang.String toString()",
            "org.apache.kafka.common.message.JoinGroupResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetCommitResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.LeaveGroupRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:java.lang.String toString()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.ApiVersionsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.JoinGroupRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterConfigsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.ElectLeadersResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:java.lang.String toString()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:java.lang.String toString()",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:java.lang.String toString()",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.MetadataResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:java.lang.String toString()",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.StopReplicaRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:java.lang.String toString()",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.CreateAclsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:java.lang.String toString()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.ListOffsetRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.CreateTopicsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteAclsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:java.lang.String toString()",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:java.lang.String toString()",
            "org.apache.kafka.common.message.ProduceRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteAclsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:java.lang.String toString()",
            "org.apache.kafka.common.message.StopReplicaResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:java.lang.String toString()",
            "org.apache.kafka.common.message.MetadataRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:java.lang.String toString()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:java.lang.String toString()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:java.lang.String toString()",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:java.lang.String toString()",
            "org.apache.kafka.common.message.ListGroupsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:java.lang.String toString()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.CreateAclsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:java.lang.String toString()",
            "org.apache.kafka.common.message.LeaveGroupResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.FetchResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetFetchRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:java.lang.String toString()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:java.lang.String toString()",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:java.lang.String toString()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:java.lang.String toString()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.CreateTopicsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetFetchResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeAclsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:java.lang.String toString()",
            "org.apache.kafka.common.message.FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:java.lang.String toString()",
            "org.apache.kafka.common.message.OffsetCommitRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.ProduceResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:java.lang.String toString()",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:java.lang.String toString()",
            "org.apache.kafka.common.message.SyncGroupRequestData:java.lang.String toString()",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:java.lang.String toString()",
            "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel buildAndAttachKafkaChannel(java.nio.channels.SocketChannel,java.lang.String,java.nio.channels.SelectionKey)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel buildAndAttachKafkaChannel(java.nio.channels.SocketChannel,java.lang.String,java.nio.channels.SelectionKey)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel buildAndAttachKafkaChannel(java.nio.channels.SocketChannel,java.lang.String,java.nio.channels.SelectionKey)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerMetadata:void awaitUpdate(int,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.KafkaProducer$ClusterAndWaitTime waitOnMetadata(java.lang.String,java.lang.Integer,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void send(org.apache.kafka.clients.ClientRequest,long)",
            "org.apache.kafka.clients.NetworkClient:void sendInternalMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector$DelayedAuthenticationFailureClose:void closeNow()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void maybeDelayCloseOnAuthenticationFailure(org.apache.kafka.common.network.KafkaChannel)",
            "org.apache.kafka.common.network.Selector$DelayedAuthenticationFailureClose:boolean tryClose(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void flush()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.Sender:void maybeAbortBatches(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void runOnce()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortIncompleteBatches()"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.Iterator iterator()",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:java.lang.Object makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerMetrics:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerMetrics:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.ConvertedRecords downConvert(byte,long,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)"
        ]
    },
    "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.ConvertedRecords downConvert(byte,long,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:java.lang.Object makeNext()"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords:java.util.Iterator recordsIterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords$recordsIterator__203:java.util.Iterator iterator()"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords$1:java.lang.Object makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.TimestampType,long,short,int,int,boolean,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(org.apache.kafka.common.record.CompressionType,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(long,org.apache.kafka.common.record.CompressionType,java.lang.Integer,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(org.apache.kafka.common.record.CompressionType,long,short,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(byte,long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(org.apache.kafka.common.record.CompressionType,long,short,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(byte,long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.TimestampType,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:void maybeEnsureValid(org.apache.kafka.common.record.RecordBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch$LegacyFileChannelRecordBatch:long baseOffset()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:void maybeEnsureValid(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$LegacyFileChannelRecordBatch:long baseOffset()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String,org.apache.kafka.common.requests.ProduceRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest buildUnsafe(short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Long,java.lang.Object,java.lang.Object,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Long,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Object,java.lang.Object,java.lang.Iterable)",
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders:void <init>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecord:void <init>(java.lang.String,int,long,long,org.apache.kafka.common.record.TimestampType,long,int,int,java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:java.util.List fetchRecords(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:java.util.List access$1700(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch,int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void access$100(org.apache.kafka.clients.producer.internals.Sender,org.apache.kafka.clients.ClientResponse,java.util.Map,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$1:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:void <init>(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.Admin create(java.util.Properties)",
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.Admin create(java.util.Map)",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <init>(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.common.config.SaslConfigs:void addClientSaslSupport(org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void initTransactions()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void commitTransaction()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void abortTransaction()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void updatePreferredReadReplica(org.apache.kafka.common.TopicPartition,int,java.util.function.Supplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:void getConfigKeyRst(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.StringBuilder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleTokenCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.JoinGroupResponse:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.JoinGroupRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.StopReplicaResponse:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.CreateTopicsRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.OffsetCommitRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.SyncGroupRequest$Builder:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel buildAndAttachKafkaChannel(java.nio.channels.SocketChannel,java.lang.String,java.nio.channels.SelectionKey)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:java.nio.channels.SelectionKey registerChannel(java.lang.String,java.nio.channels.SocketChannel,int)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.KafkaProducer$ClusterAndWaitTime waitOnMetadata(java.lang.String,java.lang.Integer,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.List partitionsFor(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void send(org.apache.kafka.clients.ClientRequest,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendAndPollTransactionalRequest()",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void sendInternalMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void maybeDelayCloseOnAuthenticationFailure(org.apache.kafka.common.network.KafkaChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector$DelayedAuthenticationFailureClose:boolean tryClose(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void completeDelayedChannelClose(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortIncompleteBatches()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:boolean hasNext()"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:java.lang.Object makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords$recordsIterator__203:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(org.apache.kafka.common.record.CompressionType,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(long,org.apache.kafka.common.record.CompressionType,java.lang.Integer,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(org.apache.kafka.common.record.CompressionType,long,short,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(byte,long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(org.apache.kafka.common.record.CompressionType,long,short,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(byte,long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.TimestampType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String,org.apache.kafka.common.requests.ProduceRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest buildUnsafe(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Long,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Object,java.lang.Object,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerRecord:void <init>(java.lang.String,int,long,long,org.apache.kafka.common.record.TimestampType,long,int,int,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecord:void <init>(java.lang.String,int,long,java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:java.util.List access$1700(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch,int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$1:void onComplete(org.apache.kafka.clients.ClientResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientResponse:void onComplete()"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.clients.producer.ProducerConfig:java.util.Set configNames()",
            "org.apache.kafka.clients.producer.ProducerConfig:org.apache.kafka.common.config.ConfigDef configDef()",
            "org.apache.kafka.clients.producer.ProducerConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.Admin create(java.util.Properties)",
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.Admin create(java.util.Map)",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Set configNames()",
            "org.apache.kafka.clients.admin.AdminClientConfig:org.apache.kafka.common.config.ConfigDef configDef()",
            "org.apache.kafka.clients.admin.AdminClientConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.config.SaslConfigs:void addClientSaslSupport(org.apache.kafka.common.config.ConfigDef)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef withClientSaslSupport()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.common.config.SaslConfigs:void addClientSaslSupport(org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.SslConfigs:void addClientSslSupport(org.apache.kafka.common.config.ConfigDef)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.admin.AdminClientConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void main(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyToken()",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:org.apache.kafka.common.security.auth.SaslExtensions retrieveCustomExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.util.Map processExtensions(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyToken()",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:org.apache.kafka.common.security.auth.SaslExtensions retrieveCustomExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.util.Map processExtensions(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.network.Selector:java.nio.channels.SelectionKey registerChannel(java.lang.String,java.nio.channels.SocketChannel,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void connect(java.lang.String,java.net.InetSocketAddress,int,int)",
            "org.apache.kafka.common.network.Selector:void register(java.lang.String,java.nio.channels.SocketChannel)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:java.util.List partitionsFor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void transmitSends()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void completeDelayedChannelClose(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.utils.AbstractIterator:boolean hasNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void close()",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List getExpiredInflightBatches(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.Map toOldGroupSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment toNewGroupAssignment(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean checkAssignmentMatchedSubscription(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setNextAllowedRetry(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateJoinedSubscription(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.WindowedSum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map extractPotentialVariables(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map configProviderProperties(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:java.lang.String toString()",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$2:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.SslClientAuth:org.apache.kafka.common.config.SslClientAuth forConfig(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.util.List parseRules(java.util.List)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.lang.String getName(java.lang.String)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void validateExtensions(org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.utils.LoggingSignalHandler:void register()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionsByTopic(java.util.Collection)",
            "org.apache.kafka.common.utils.MappedIterator:boolean hasNext()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.CloseableIterator$1:boolean hasNext()",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void changeCapacity(int)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Object peek()",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:int to32BitField(java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.String toString()",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void normalize()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupRequest:java.util.Map groupAssignments()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:java.util.List partitions()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.header.internals.RecordHeaders$1:boolean hasNext()"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecord:void <init>(java.lang.String,int,long,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map fetchedRecords()"
        ]
    },
    "org.apache.kafka.clients.ClientResponse:void onComplete()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerConfig:java.util.Set configNames()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerConfig:org.apache.kafka.common.config.ConfigDef configDef()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Set configNames()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:org.apache.kafka.common.config.ConfigDef configDef()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef withClientSaslSupport()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.config.SslConfigs:void addClientSslSupport(org.apache.kafka.common.config.ConfigDef)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef withClientSslSupport()"
        ]
    },
    "org.apache.kafka.common.network.Selector:void connect(java.lang.String,java.net.InetSocketAddress,int,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void register(java.lang.String,java.nio.channels.SocketChannel)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyFullFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyIncrementalFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:boolean handleResponse(org.apache.kafka.common.requests.FetchResponse)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleConnections()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ApiVersions:void update(java.lang.String,org.apache.kafka.clients.NodeApiVersions)",
            "org.apache.kafka.clients.ApiVersions:void remove(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer$InterceptorCallback:void onCompletion(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.BufferPool:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void close()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:java.util.List getExpiredInflightBatches(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void resetProducerIdIfNeeded()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void runOnce()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler access$2600(org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void abort(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:boolean done(long,long,java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,org.apache.kafka.clients.ClientDnsLookup)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void access$2000(org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable,java.util.function.Predicate)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean threadShouldExit(long,long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult$lambda_all_1__245:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult$lambda_all_0__246:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List access$2700(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData access$2800(org.apache.kafka.clients.admin.KafkaAdminClient,java.util.Collection,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Set,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.Collection lambda$all$0(java.lang.Void)"
        ]
    },
    "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutPendingCalls(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache empty()"
        ]
    },
    "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void bootstrap(java.util.List)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean hasReadyNodes(long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean hasInFlightRequests()"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create()",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(short,short,short)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)"
        ]
    },
    "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)"
        ]
    },
    "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void addEndOffsets(java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void updateEndOffsets(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer subscriptionUserData(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.Map toOldGroupSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment toNewGroupAssignment(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription,short)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment,short)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment,short)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:void drain()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean checkAssignmentMatchedSubscription(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void rebalance(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinPrepare(int,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onLeavePrepare()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setNextAllowedRetry(java.util.Set,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onSuccess(org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestFailed(java.util.Set,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onFailure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onFailure(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$100(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.clients.consumer.internals.SubscriptionState)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean access$300(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean in(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean access$600(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair,java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection access$300(org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$2:void onSuccess(java.lang.Void)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor lookupAssignor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateJoinedSubscription(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.common.utils.Timer,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void handlePendingDisconnects()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:int getBalanceScore(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean hasIdenticalListElements(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean areSubscriptionsIdentical(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void deepCopy(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map deepCopy(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void unsubscribe()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:java.lang.Object handleResponse(org.apache.kafka.common.Node,java.lang.Object,org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords:int count()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:void record(double,long)",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas()"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:void addReporter(org.apache.kafka.common.metrics.MetricsReporter)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter:void metricRemoval(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean addAttribute(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void removeReporter(org.apache.kafka.common.metrics.MetricsReporter)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void transitionState(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchState,java.lang.Runnable)",
            "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void close()",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.utils.AppInfoParser:void unregisterMetrics(org.apache.kafka.common.metrics.Metrics)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MeasurableStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.MetricValueProvider)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Rate:long windowSize(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.SimpleRate:long windowSize(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.WindowedSum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Frequencies$1:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Frequencies:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Percentiles$1:double measure(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.RecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)"
        ]
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void logAll()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void logUnused()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map extractPotentialVariables(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map resolveConfigVariables(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map configProviderProperties(java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map resolveConfigVariables(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$CompositeValidator:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef$1:java.lang.String toString()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef$1:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$2:java.util.Map unprefixed(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$2:java.util.List validValues(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$2:boolean visible(java.lang.String,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map resolveConfigVariables(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.SslClientAuth:org.apache.kafka.common.config.SslClientAuth forConfig(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslEngineBuilder:org.apache.kafka.common.config.SslClientAuth createSslClientAuth(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCache(org.apache.kafka.common.security.token.delegation.DelegationToken,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void removeCache(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin:void lambda$login$0()"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:org.apache.kafka.common.security.kerberos.KerberosShortNamer fromUnparsedRules(java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal applyKerberosShortNamer(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.util.List parseRules(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:void <init>(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.lang.String getName(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal applySslPrincipalMapper(java.security.Principal)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslEngineBuilder createNewSslEngineBuilder(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleTokenCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void validateExtensions(org.apache.kafka.common.security.auth.SaslExtensions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)"
        ]
    },
    "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin:java.lang.String getServiceName(java.util.Map,java.lang.String,javax.security.auth.login.Configuration)",
            "org.apache.kafka.common.security.plain.internals.PlainServerCallbackHandler:boolean authenticate(java.lang.String,char[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void <init>(java.util.Collection)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.lang.String,javax.security.auth.Subject,java.lang.String,java.lang.String,java.lang.String,boolean,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:javax.security.sasl.SaslServer createSaslKerberosServer(org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.util.Map,javax.security.auth.Subject)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void <init>(int,long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.memory.MemoryPool,org.apache.kafka.common.utils.LogContext)"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void muteAll()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void unmuteAll()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void addToCompletedReceives()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslAuthenticateResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.RenewDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.JoinGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetDeleteResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.HeartbeatResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.HeartbeatResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.InitProducerIdRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.InitProducerIdRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.RenewDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.RequestHeaderData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.RequestHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.HeartbeatRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.HeartbeatRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.SaslHandshakeResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.EndTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FindCoordinatorResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FindCoordinatorRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslAuthenticateRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListGroupsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListGroupsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.EndTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.InitProducerIdResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.InitProducerIdResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ResponseHeaderData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ResponseHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SyncGroupRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SyncGroupResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)"
        ]
    },
    "org.apache.kafka.common.utils.LoggingSignalHandler:void register()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionDataByTopic(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionsByTopic(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.requests.StopReplicaRequest build(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)"
        ]
    },
    "org.apache.kafka.common.utils.MappedIterator:boolean hasNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void close()",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List getExpiredInflightBatches(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.Map toOldGroupSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment toNewGroupAssignment(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean checkAssignmentMatchedSubscription(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setNextAllowedRetry(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateJoinedSubscription(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.WindowedSum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map extractPotentialVariables(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map configProviderProperties(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:java.lang.String toString()",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$2:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.SslClientAuth:org.apache.kafka.common.config.SslClientAuth forConfig(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.util.List parseRules(java.util.List)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.lang.String getName(java.lang.String)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void validateExtensions(org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.utils.LoggingSignalHandler:void register()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionsByTopic(java.util.Collection)",
            "org.apache.kafka.common.utils.MappedIterator:boolean hasNext()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.CloseableIterator$1:boolean hasNext()",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void changeCapacity(int)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:int to32BitField(java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.String toString()",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void normalize()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupRequest:java.util.Map groupAssignments()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:java.util.List partitions()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.header.internals.RecordHeaders$1:boolean hasNext()"
        ]
    },
    "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()"
        ]
    },
    "org.apache.kafka.common.utils.CloseableIterator$1:boolean hasNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void close()",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List getExpiredInflightBatches(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.Map toOldGroupSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment toNewGroupAssignment(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean checkAssignmentMatchedSubscription(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setNextAllowedRetry(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateJoinedSubscription(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.WindowedSum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map extractPotentialVariables(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map configProviderProperties(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:java.lang.String toString()",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$2:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.SslClientAuth:org.apache.kafka.common.config.SslClientAuth forConfig(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.util.List parseRules(java.util.List)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.lang.String getName(java.lang.String)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void validateExtensions(org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.utils.LoggingSignalHandler:void register()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionsByTopic(java.util.Collection)",
            "org.apache.kafka.common.utils.MappedIterator:boolean hasNext()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.CloseableIterator$1:boolean hasNext()",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void changeCapacity(int)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:int to32BitField(java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.String toString()",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void normalize()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupRequest:java.util.Map groupAssignments()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:java.util.List partitions()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.header.internals.RecordHeaders$1:boolean hasNext()"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void changeCapacity(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:boolean add(org.apache.kafka.common.utils.ImplicitLinkedHashCollection$Element)"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.ImplicitLinkedHashMultiCollection:void <init>(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.utils.AbstractIterator:java.lang.Object next()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void close()",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List getExpiredInflightBatches(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.Map toOldGroupSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment toNewGroupAssignment(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean checkAssignmentMatchedSubscription(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setNextAllowedRetry(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateJoinedSubscription(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.consumer.NoOffsetForPartitionException:org.apache.kafka.common.TopicPartition partition()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.WindowedSum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:void <init>(org.apache.kafka.common.record.LazyDownConversionRecords,org.apache.kafka.common.record.Records,long,org.apache.kafka.common.record.ConvertedRecords)",
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map extractPotentialVariables(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map configProviderProperties(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:java.lang.String toString()",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$2:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.SslClientAuth:org.apache.kafka.common.config.SslClientAuth forConfig(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.util.List parseRules(java.util.List)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.lang.String getName(java.lang.String)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback,javax.security.auth.Subject)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void validateExtensions(org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin$1:org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredential expiringCredential()",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.SaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.network.Selector$IdleExpiryManager:java.util.Map$Entry pollExpiredConnection(long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void completeDelayedChannelClose(long)",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel lowestPriorityChannel()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.utils.LoggingSignalHandler:void register()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionsByTopic(java.util.Collection)",
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.CloseableIterator$1:java.lang.Object next()",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void changeCapacity(int)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:int to32BitField(java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.String toString()",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void normalize()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupRequest:java.util.Map groupAssignments()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:java.util.List partitions()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.header.internals.RecordHeaders$1:org.apache.kafka.common.header.Header next()"
        ]
    },
    "org.apache.kafka.common.utils.AbstractIterator:java.lang.Object peek()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String partitionsToLogString(java.util.Collection)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyFullFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyIncrementalFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.CommonClientConfigs:void <clinit>()",
            "org.apache.kafka.clients.admin.TopicDescription:java.lang.String toString()",
            "org.apache.kafka.clients.admin.ConsumerGroupDescription:java.lang.String toString()",
            "org.apache.kafka.clients.admin.MemberAssignment:java.lang.String toString()",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.lang.Exception invokePartitionsAssigned(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.lang.Exception invokePartitionsRevoked(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.lang.Exception invokePartitionsLost(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.ConfigDef$ValidString:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ValidString:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef$CaseInsensitiveValidString:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CaseInsensitiveValidString:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef$NonEmptyStringWithoutControlChars:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.lang.Object[],java.lang.String)",
            "org.apache.kafka.common.requests.CreateAclsRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata:java.lang.String toString()",
            "org.apache.kafka.common.requests.FetchRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.lang.String toString()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.ListOffsetResponse$PartitionData:java.lang.String toString()",
            "org.apache.kafka.common.requests.DeleteAclsResponse$AclFilterResponse:java.lang.String toString()",
            "org.apache.kafka.common.TopicPartitionInfo:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:java.lang.String extensionsMessage()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.util.Map processExtensions(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:java.lang.String clientFirstMessageBare()",
            "org.apache.kafka.common.requests.ProduceRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.Utils:int to32BitField(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup groupMetadata(java.lang.String,org.apache.kafka.common.protocol.Errors,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.Set)"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()"
        ]
    },
    "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Type$16:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.Object validate(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.requests.OffsetFetchResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:void <init>(java.util.Collection)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.message.UpdateMetadataRequestData,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.util.Map groupByTopic(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.requests.LeaderAndIsrRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:void normalize()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.message.LeaderAndIsrRequestData,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:java.util.Map groupAssignments()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:java.util.List partitions()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse$Holder:void <init>(org.apache.kafka.common.message.MetadataResponseData)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:org.apache.kafka.common.requests.OffsetFetchRequest$Builder allTopicPartitions(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.Map offsets()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.Map offsets()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchResponse:int sizeOf(short,java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(java.util.List,org.apache.kafka.common.protocol.Errors,int,short)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors error()"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleSuccessfulResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse$lambda_prepareResponse_1__115:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.requests.ElectLeadersRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.util.Map groupByTopic(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$28:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.common.internals.ClusterResourceListeners configureClusterResourceListeners(org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,java.util.List[])",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.internals.ClusterResourceListeners configureClusterResourceListeners(org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,java.util.List[])"
        ]
    },
    "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void update(int,org.apache.kafka.common.requests.MetadataResponse,long)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$26:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void tryComplete()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$partitionResult$0(org.apache.kafka.common.internals.KafkaFutureImpl,org.apache.kafka.common.TopicPartition,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$2:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$memberResult$1(org.apache.kafka.common.internals.KafkaFutureImpl,org.apache.kafka.clients.admin.MemberToRemove,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$28:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void maybeComplete()",
            "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture completedFuture(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$26:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:boolean maybeCompleteExceptionally(java.util.Map,org.apache.kafka.common.TopicPartition,org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$partitionResult$0(org.apache.kafka.common.internals.KafkaFutureImpl,org.apache.kafka.common.TopicPartition,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$2:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:boolean maybeCompleteExceptionally(java.util.Map,org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity,org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$memberResult$1(org.apache.kafka.common.internals.KafkaFutureImpl,org.apache.kafka.clients.admin.MemberToRemove,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeAclsResult describeAcls(org.apache.kafka.common.acl.AclBindingFilter,org.apache.kafka.clients.admin.DescribeAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:boolean handleGroupRequestError(org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult deleteConsumerGroupOffsets(java.lang.String,java.util.Set,org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.internals.KafkaFutureImpl lambda$createFutures$4(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void lambda$completeAllExceptionally$1(java.lang.Throwable,org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$28:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$28:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean cancel(boolean)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.PartitionStates:void set(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:java.lang.Object makeNext()"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$1:boolean hasNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void close()",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List getExpiredInflightBatches(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.Map toOldGroupSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment toNewGroupAssignment(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean checkAssignmentMatchedSubscription(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setNextAllowedRetry(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateJoinedSubscription(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.WindowedSum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map extractPotentialVariables(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map configProviderProperties(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:java.lang.String toString()",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$2:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.SslClientAuth:org.apache.kafka.common.config.SslClientAuth forConfig(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.util.List parseRules(java.util.List)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.lang.String getName(java.lang.String)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void validateExtensions(org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.utils.LoggingSignalHandler:void register()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionsByTopic(java.util.Collection)",
            "org.apache.kafka.common.utils.MappedIterator:boolean hasNext()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.CloseableIterator$1:boolean hasNext()",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void changeCapacity(int)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:int to32BitField(java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.String toString()",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void normalize()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupRequest:java.util.Map groupAssignments()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:java.util.List partitions()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.header.internals.RecordHeaders$1:boolean hasNext()"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef withClientSslSupport()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean ready(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClient:void access$500(org.apache.kafka.clients.NetworkClient,org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyFullFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:boolean handleResponse(org.apache.kafka.common.requests.FetchResponse)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyIncrementalFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:boolean handleResponse(org.apache.kafka.common.requests.FetchResponse)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:boolean handleResponse(org.apache.kafka.common.requests.FetchResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.ApiVersions:void update(java.lang.String,org.apache.kafka.clients.NodeApiVersions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)"
        ]
    },
    "org.apache.kafka.clients.ApiVersions:void remove(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer$InterceptorCallback:void onCompletion(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer$Completion:void complete(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.clients.producer.KafkaProducer$InterceptorCallback:void onCompletion(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientResponse:void onComplete()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void initiateClose()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void resetProducerIdIfNeeded()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void runOnce()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler access$2600(org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddOffsetsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void abort(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:boolean done(long,long,java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)",
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void access$2000(org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable,java.util.function.Predicate)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean threadShouldExit(long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult$lambda_all_1__245:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void enqueue(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void call(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult$lambda_all_0__246:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List access$2700(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData access$2800(org.apache.kafka.clients.admin.KafkaAdminClient,java.util.Collection,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Set,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.Collection lambda$all$0(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DeleteAclsResult$lambda_all_0__243:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutPendingCalls(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)"
        ]
    },
    "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache empty()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void <init>(long,long,org.apache.kafka.common.utils.LogContext,org.apache.kafka.common.internals.ClusterResourceListeners)"
        ]
    },
    "org.apache.kafka.clients.Metadata:void bootstrap(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean hasReadyNodes(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasReadyNodes(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean hasInFlightRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests()"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(short,short,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync()",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.util.Map,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void addEndOffsets(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void updateEndOffsets(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer subscriptionUserData(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()"
        ]
    },
    "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:void drain()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:void access$2100(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void assign(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void rebalance(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onLeavePrepare()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void unsubscribe()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onSuccess(org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$100(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.clients.consumer.internals.SubscriptionState)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean access$300(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isSticky()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean access$600(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection access$300(org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$2:void onSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$2:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean areSubscriptionsIdentical(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map deepCopy(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:java.lang.Object handleResponse(org.apache.kafka.common.Node,java.lang.Object,org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AsyncClient$1:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateSubscriptionMetadata()"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void record(double,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void recordWaitTime(long)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordRetries(java.lang.String,int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordErrors(java.lang.String,int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordLatency(java.lang.String,long)",
            "org.apache.kafka.common.metrics.Sensor:void record(double)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesSent(java.lang.String,long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesReceived(java.lang.String,int)",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void checkQuotas()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.BufferPool:void <init>(long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void registerMetrics(org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addReporter(org.apache.kafka.common.metrics.MetricsReporter)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.JmxReporter:void metricRemoval(org.apache.kafka.common.metrics.KafkaMetric)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean addAttribute(org.apache.kafka.common.metrics.KafkaMetric)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:void metricChange(org.apache.kafka.common.metrics.KafkaMetric)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void removeReporter(org.apache.kafka.common.metrics.MetricsReporter)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.metrics.Metrics buildMetrics(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.utils.Time,java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void unregisterMetrics(org.apache.kafka.common.metrics.Metrics)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser:void unregisterAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MeasurableStat,org.apache.kafka.common.metrics.MetricConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MeasurableStat)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.MetricValueProvider)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Measurable)",
            "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricValueProvider)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()",
            "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)",
            "org.apache.kafka.common.metrics.stats.Rate:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Rate:long windowSize(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Rate:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.SimpleRate:long windowSize(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Rate:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Frequencies$1:double measure(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()",
            "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Frequencies:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Percentiles$1:double measure(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()",
            "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Percentiles:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.network.Send buildResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.record.RecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MultiRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBuffer()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBuffer()",
            "org.apache.kafka.common.network.KafkaChannel:boolean send(org.apache.kafka.common.network.Send)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map resolveConfigVariables(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$2:java.util.List validValues(java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$2:java.util.List validValues(java.lang.String,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$2:boolean visible(java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$2:boolean visible(java.lang.String,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslEngineBuilder:org.apache.kafka.common.config.SslClientAuth createSslClientAuth(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslEngineBuilder:void <init>(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCache(org.apache.kafka.common.security.token.delegation.DelegationToken,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void removeCache(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.kerberos.KerberosShortNamer:org.apache.kafka.common.security.kerberos.KerberosShortNamer fromUnparsedRules(java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal applyKerberosShortNamer(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal build(org.apache.kafka.common.security.auth.AuthenticationContext)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslPrincipalMapper:void <init>(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:org.apache.kafka.common.security.ssl.SslPrincipalMapper fromRules(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal applySslPrincipalMapper(java.security.Principal)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal build(org.apache.kafka.common.security.auth.AuthenticationContext)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:java.lang.String getServiceName(java.util.Map,java.lang.String,javax.security.auth.login.Configuration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void <init>(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.lang.String,javax.security.auth.Subject,java.lang.String,java.lang.String,java.lang.String,boolean,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.security.authenticator.SaslClientAuthenticator buildClientAuthenticator(java.util.Map,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.lang.String,java.lang.String,java.lang.String,org.apache.kafka.common.network.TransportLayer,javax.security.auth.Subject)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:javax.security.sasl.SaslServer createSaslKerberosServer(org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.util.Map,javax.security.auth.Subject)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void createSaslServer(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void <init>(int,long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.memory.MemoryPool,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void <init>(int,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.memory.MemoryPool,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.common.network.Selector:void <init>(int,long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.HeartbeatResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.HeartbeatResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.InitProducerIdRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.RequestHeaderData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.HeartbeatRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FindCoordinatorResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FindCoordinatorRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.InitProducerIdResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ResponseHeaderData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ResponseHeader:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.requests.StopReplicaRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:boolean add(org.apache.kafka.common.utils.ImplicitLinkedHashCollection$Element)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void lambda$createRequest$1(org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopicCollection,java.lang.String,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void mustAdd(org.apache.kafka.common.utils.ImplicitLinkedHashCollection$Element)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:boolean add(java.lang.Object)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection$ImplicitLinkedHashCollectionSetView:boolean add(org.apache.kafka.common.utils.ImplicitLinkedHashCollection$Element)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:void lambda$prepareResponse$0(org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartitionCollection,org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$0(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashMultiCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResourceCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfigCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfigCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResultCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopicCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartitionCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartitionCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResourceCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResultCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopicCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfigCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopicCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignmentCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResultCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopicCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBrokerCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResultCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResultCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopicCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopicCollection:void <init>(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition access$100(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements,org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.NoOffsetForPartitionException:org.apache.kafka.common.TopicPartition partition()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:void <init>(org.apache.kafka.common.record.LazyDownConversionRecords,org.apache.kafka.common.record.Records,long,org.apache.kafka.common.record.ConvertedRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:void <init>(org.apache.kafka.common.record.LazyDownConversionRecords,org.apache.kafka.common.record.Records,long,org.apache.kafka.common.record.ConvertedRecords,org.apache.kafka.common.record.LazyDownConversionRecords$1)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback,javax.security.auth.Subject)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin$1:org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredential expiringCredential()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:void reLogin()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyToken()",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:org.apache.kafka.common.security.auth.SaslExtensions retrieveCustomExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.util.Map processExtensions(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.network.Selector$IdleExpiryManager:java.util.Map$Entry pollExpiredConnection(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel lowestPriorityChannel()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void close()",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List getExpiredInflightBatches(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.Map toOldGroupSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment toNewGroupAssignment(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean checkAssignmentMatchedSubscription(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setNextAllowedRetry(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateJoinedSubscription(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.consumer.NoOffsetForPartitionException:org.apache.kafka.common.TopicPartition partition()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.WindowedSum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map extractPotentialVariables(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map configProviderProperties(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:java.lang.String toString()",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$2:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.SslClientAuth:org.apache.kafka.common.config.SslClientAuth forConfig(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.util.List parseRules(java.util.List)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.lang.String getName(java.lang.String)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback,javax.security.auth.Subject)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void validateExtensions(org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin$1:org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredential expiringCredential()",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.SaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.network.Selector$IdleExpiryManager:java.util.Map$Entry pollExpiredConnection(long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void completeDelayedChannelClose(long)",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel lowestPriorityChannel()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.utils.LoggingSignalHandler:void register()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionsByTopic(java.util.Collection)",
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.CloseableIterator$1:java.lang.Object next()",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void changeCapacity(int)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:int to32BitField(java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.String toString()",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void normalize()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupRequest:java.util.Map groupAssignments()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:java.util.List partitions()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.header.internals.RecordHeaders$1:org.apache.kafka.common.header.Header next()"
        ]
    },
    "org.apache.kafka.common.utils.CloseableIterator$1:java.lang.Object next()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void close()",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List getExpiredInflightBatches(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.Map toOldGroupSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment toNewGroupAssignment(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean checkAssignmentMatchedSubscription(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setNextAllowedRetry(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateJoinedSubscription(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.consumer.NoOffsetForPartitionException:org.apache.kafka.common.TopicPartition partition()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.WindowedSum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map extractPotentialVariables(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map configProviderProperties(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:java.lang.String toString()",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$2:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.SslClientAuth:org.apache.kafka.common.config.SslClientAuth forConfig(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.util.List parseRules(java.util.List)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.lang.String getName(java.lang.String)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback,javax.security.auth.Subject)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void validateExtensions(org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin$1:org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredential expiringCredential()",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.SaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.network.Selector$IdleExpiryManager:java.util.Map$Entry pollExpiredConnection(long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void completeDelayedChannelClose(long)",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel lowestPriorityChannel()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.utils.LoggingSignalHandler:void register()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionsByTopic(java.util.Collection)",
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.CloseableIterator$1:java.lang.Object next()",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void changeCapacity(int)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:int to32BitField(java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.String toString()",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void normalize()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupRequest:java.util.Map groupAssignments()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:java.util.List partitions()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.header.internals.RecordHeaders$1:org.apache.kafka.common.header.Header next()"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$1:org.apache.kafka.common.header.Header next()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.header.internals.RecordHeaders$1:java.lang.Object next()"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String partitionsToLogString(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String access$300(org.apache.kafka.clients.FetchSessionHandler,java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.CommonClientConfigs:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()",
            "org.apache.kafka.clients.CommonClientConfigs:java.util.Map postProcessReconnectBackoffConfigs(org.apache.kafka.common.config.AbstractConfig,java.util.Map)",
            "org.apache.kafka.clients.CommonClientConfigs:void <clinit>()",
            "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.clients.admin.TopicDescription:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.clients.admin.ConsumerGroupDescription:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.clients.admin.MemberAssignment:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.lang.Exception invokePartitionsAssigned(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.lang.Exception invokePartitionsRevoked(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinPrepare(int,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onLeavePrepare()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.lang.Exception invokePartitionsLost(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinPrepare(int,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onLeavePrepare()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ValidString:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef$1:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ValidString:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef$1:java.lang.String toString()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$CaseInsensitiveValidString:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef$1:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$CaseInsensitiveValidString:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef$1:java.lang.String toString()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$NonEmptyStringWithoutControlChars:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef$1:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.String join(java.lang.Object[],java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:java.lang.Object newParameterizedInstance(java.lang.String,java.lang.Object[])"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse$PartitionData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse$AclFilterResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.TopicPartitionInfo:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:java.lang.String extensionsMessage()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:byte[] toBytes()"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:java.lang.String clientFirstMessageBare()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] authMessage(org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:java.lang.String toMessage()"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:java.lang.String toString(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup groupMetadata(java.lang.String,org.apache.kafka.common.protocol.Errors,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup forError(java.lang.String,org.apache.kafka.common.protocol.Errors)"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Protocol:void main(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.protocol.types.ArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Type$16:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.CompactArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Type$16:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Type$16:void write(java.nio.ByteBuffer,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Type$16:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.common.protocol.types.ArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Struct:void writeTo(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)"
        ]
    },
    "org.apache.kafka.common.protocol.types.ArrayOf:int sizeOf(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.CompactArrayOf:int sizeOf(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Schema:int sizeOf(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.common.protocol.types.ArrayOf:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Struct:int sizeOf()"
        ]
    },
    "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.Object validate(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object[] validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object[] validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String,boolean,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct validate(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.network.Send buildResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.RequestHeader)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.Errors,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.requests.AbstractResponse parseResponse(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.requests.OffsetFetchResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:void <init>(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$26:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.message.UpdateMetadataRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.requests.LeaderAndIsrRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.message.LeaderAndIsrRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.requests.LeaderAndIsrRequest build(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse$Holder:void <init>(org.apache.kafka.common.message.MetadataResponseData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse$Holder holder()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$25:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:org.apache.kafka.common.requests.OffsetFetchRequest$Builder allTopicPartitions(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:int sizeOf(short,java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(java.util.List,org.apache.kafka.common.protocol.Errors,int,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(org.apache.kafka.common.requests.LeaveGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse$lambda_prepareResponse_1__115:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.requests.ElectLeadersRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$28:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.common.internals.ClusterResourceListeners configureClusterResourceListeners(org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,java.util.List[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.internals.ClusterResourceListeners configureClusterResourceListeners(org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,java.util.List[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$26:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void tryComplete()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void <init>(java.util.Collection,org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void tryComplete(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$partitionResult$0(org.apache.kafka.common.internals.KafkaFutureImpl,org.apache.kafka.common.TopicPartition,java.util.Map,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult$lambda_partitionResult_0__244:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$27:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$2:void accept(java.util.Map,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$2:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$memberResult$1(org.apache.kafka.common.internals.KafkaFutureImpl,org.apache.kafka.clients.admin.MemberToRemove,java.util.Map,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult$lambda_memberResult_1__247:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$1:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void maybeComplete()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void <init>(int,org.apache.kafka.common.KafkaFuture)",
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture completedFuture(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$26:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:boolean maybeCompleteExceptionally(java.util.Map,org.apache.kafka.common.TopicPartition,org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$partitionResult$0(org.apache.kafka.common.internals.KafkaFutureImpl,org.apache.kafka.common.TopicPartition,java.util.Map,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$27:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:boolean maybeCompleteExceptionally(java.util.Map,org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity,org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$memberResult$1(org.apache.kafka.common.internals.KafkaFutureImpl,org.apache.kafka.clients.admin.MemberToRemove,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeAclsResult describeAcls(org.apache.kafka.common.acl.AclBindingFilter,org.apache.kafka.clients.admin.DescribeAclsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeAclsResult describeAcls(org.apache.kafka.common.acl.AclBindingFilter)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:boolean handleGroupRequestError(org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:boolean access$3000(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.internals.KafkaFutureImpl)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult deleteConsumerGroupOffsets(java.lang.String,java.util.Set,org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult deleteConsumerGroupOffsets(java.lang.String,java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.internals.KafkaFutureImpl lambda$createFutures$4(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$lambda_createFutures_4__227:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void lambda$completeAllExceptionally$1(java.lang.Throwable,org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$lambda_completeAllExceptionally_1__223:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$28:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:boolean cancel(boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.internals.PartitionStates:void set(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)"
        ]
    },
    "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.internals.AdminMetadataManager:void clearController()",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster empty()"
        ]
    },
    "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.MetadataCache:void computeClusterView()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster withPartitions(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:java.lang.Object makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean ready(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void tryConnect(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void access$500(org.apache.kafka.clients.NetworkClient,org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer$Completion:void complete(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.clients.producer.MockProducer:boolean errorNext(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void initiateClose()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void forceClose()",
            "org.apache.kafka.clients.producer.KafkaProducer:void close(java.time.Duration,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$AddOffsetsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture allOf(org.apache.kafka.common.KafkaFuture[])",
            "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture thenApply(org.apache.kafka.common.KafkaFuture$BaseFunction)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:void copyWith(org.apache.kafka.common.KafkaFuture,org.apache.kafka.common.KafkaFuture$BaseFunction)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture whenComplete(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:java.lang.Object get()",
            "org.apache.kafka.common.internals.KafkaFutureImpl:java.lang.Object get(long,java.util.concurrent.TimeUnit)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void enqueue(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void call(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void call(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListTopicsResult listTopics(org.apache.kafka.clients.admin.ListTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeClusterResult describeCluster(org.apache.kafka.clients.admin.DescribeClusterOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeAclsResult describeAcls(org.apache.kafka.common.acl.AclBindingFilter,org.apache.kafka.clients.admin.DescribeAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.RenewDelegationTokenResult renewDelegationToken(byte[],org.apache.kafka.clients.admin.RenewDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ExpireDelegationTokenResult expireDelegationToken(byte[],org.apache.kafka.clients.admin.ExpireDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeDelegationTokenResult describeDelegationToken(org.apache.kafka.clients.admin.DescribeDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void rescheduleTask(org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext,java.util.function.Supplier)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups(org.apache.kafka.clients.admin.ListConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult listConsumerGroupOffsets(java.lang.String,org.apache.kafka.clients.admin.ListConsumerGroupOffsetsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult deleteConsumerGroupOffsets(java.lang.String,java.util.Set,org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ElectLeadersResult electLeaders(org.apache.kafka.common.ElectionType,java.util.Set,org.apache.kafka.clients.admin.ElectLeadersOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult removeMembersFromConsumerGroup(java.lang.String,org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$12:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteAclsResult$lambda_all_0__243:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.Metadata:void <init>(long,long,org.apache.kafka.common.utils.LogContext,org.apache.kafka.common.internals.ClusterResourceListeners)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerMetadata:void <init>(long,long,org.apache.kafka.common.utils.LogContext,org.apache.kafka.common.internals.ClusterResourceListeners,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.consumer.internals.ConsumerMetadata:void <init>(long,long,boolean,boolean,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.utils.LogContext,org.apache.kafka.common.internals.ClusterResourceListeners)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasReadyNodes(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitSync()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.util.Map,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:void access$2100(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void close()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void raise(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void addListener(org.apache.kafka.clients.consumer.internals.RequestFutureListener)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isSticky()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$2:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateSubscriptionMetadata()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void updateGroupSubscription(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.requests.AbstractResponse parseResponse(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.BufferPool:void recordWaitTime(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.BufferPool:java.nio.ByteBuffer allocate(int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordRetries(java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void reenqueueBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordErrors(java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordLatency(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void record(double)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$1:void onSuccess(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void recordPollStart(long)",
            "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void recordPollEnd(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.lang.Exception invokePartitionsAssigned(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.lang.Exception invokePartitionsRevoked(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.lang.Exception invokePartitionsLost(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.common.metrics.Sensor:void record()",
            "org.apache.kafka.common.memory.SimpleMemoryPool:void maybeRecordEndOfDrySpell()"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesSent(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesReceived(java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives(org.apache.kafka.common.network.KafkaChannel,java.util.Deque)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.BufferPool:void <init>(long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.producer.internals.RecordAccumulator,boolean,int,short,int,org.apache.kafka.clients.producer.internals.SenderMetricsRegistry,org.apache.kafka.common.utils.Time,int,long,org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.ApiVersions)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void registerMetrics(org.apache.kafka.common.metrics.Metrics,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void <init>(org.apache.kafka.common.utils.LogContext,int,org.apache.kafka.common.record.CompressionType,int,long,int,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.ApiVersions,org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.producer.internals.BufferPool)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry,org.apache.kafka.clients.consumer.internals.Fetcher$1)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$4100(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,java.lang.String,int,int)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:void metricChange(org.apache.kafka.common.metrics.KafkaMetric)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerMetrics:void main(java.lang.String[])",
            "org.apache.kafka.common.metrics.Metrics:void <init>()"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void unregisterAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void close(java.time.Duration,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void close(java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MeasurableStat)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Measurable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.Measurable)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricValueProvider)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.common.utils.AppInfoParser:void registerMetrics(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.AppInfoParser$AppInfo)"
        ]
    },
    "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:java.lang.Object getAttribute(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:double value()",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Rate:double measure(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()",
            "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)"
        ]
    },
    "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.network.Send buildResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void buildResponseOnAuthenticateFailure(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.record.MultiRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MultiRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBuffer()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBuffer()",
            "org.apache.kafka.common.network.KafkaChannel:boolean send(org.apache.kafka.common.network.Send)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBuffer()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBufferAndUpdateInterestOps()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBuffer()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBufferAndUpdateInterestOps()"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:boolean send(org.apache.kafka.common.network.Send)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.network.Send write()"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslEngineBuilder:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslEngineBuilder createNewSslEngineBuilder(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal build(org.apache.kafka.common.security.auth.AuthenticationContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()",
            "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()",
            "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslPrincipalMapper:org.apache.kafka.common.security.ssl.SslPrincipalMapper fromRules(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.security.authenticator.SaslClientAuthenticator buildClientAuthenticator(java.util.Map,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.lang.String,java.lang.String,java.lang.String,org.apache.kafka.common.network.TransportLayer,javax.security.auth.Subject)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$1(java.lang.String,java.net.Socket,org.apache.kafka.common.security.authenticator.LoginManager,org.apache.kafka.common.network.TransportLayer)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void createSaslServer(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.common.network.Selector:void <init>(int,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.memory.MemoryPool,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void <init>(int,long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void <init>(int,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.common.network.Selector:void <init>(long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.ElectLeadersRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.requests.JoinGroupResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.requests.OffsetCommitResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.LeaveGroupRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.requests.DeleteGroupsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.JoinGroupRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.requests.HeartbeatResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.InitProducerIdRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:org.apache.kafka.common.requests.ElectLeadersResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.requests.UpdateMetadataResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.HeartbeatRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.requests.IncrementalAlterConfigsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.ListPartitionReassignmentsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.requests.FindCoordinatorResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.requests.DeleteTopicsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.FindCoordinatorRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.CreateDelegationTokenRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.DeleteGroupsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.requests.CreateTopicsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:org.apache.kafka.common.requests.ListPartitionReassignmentsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.requests.StopReplicaResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.MetadataRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.DeleteTopicsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.requests.ListGroupsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.IncrementalAlterConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.requests.LeaveGroupResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.requests.InitProducerIdResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.CreateTopicsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.requests.ControlledShutdownResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.DescribeGroupsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.requests.LeaderAndIsrResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.SyncGroupRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.requests.SyncGroupResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$27:void lambda$createRequest$1(org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopicCollection,java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$27$lambda_createRequest_1__253:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void mustAdd(org.apache.kafka.common.utils.ImplicitLinkedHashCollection$Element)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:boolean add(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashCollection$ImplicitLinkedHashCollectionSetView:boolean add(org.apache.kafka.common.utils.ImplicitLinkedHashCollection$Element)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection$ImplicitLinkedHashCollectionSetView:boolean add(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleApiVersionsRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.ApiVersionsRequest)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:void lambda$prepareResponse$0(org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartitionCollection,org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownResponse$lambda_prepareResponse_0__134:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$0(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse$lambda_prepareResponse_0__114:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse(int,byte)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResourceCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfigCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfigCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResultCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopicCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartitionCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartitionCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResourceCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResultCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopicCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfigCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopicCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignmentCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResultCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopicCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBrokerCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResultCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResultCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopicCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopicCollection:void <init>(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition access$100(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements,org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:void <init>(org.apache.kafka.common.record.LazyDownConversionRecords,org.apache.kafka.common.record.Records,long,org.apache.kafka.common.record.ConvertedRecords,org.apache.kafka.common.record.LazyDownConversionRecords$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords:java.util.Iterator iterator(long)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyToken()",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:org.apache.kafka.common.security.auth.SaslExtensions retrieveCustomExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.util.Map processExtensions(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:void reLogin()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:void access$600(org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$1:java.lang.Object next()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void close()",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List getExpiredInflightBatches(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:void lambda$all$1(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.ElectLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map incrementalAlterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult alterPartitionReassignments(java.util.Map,org.apache.kafka.clients.admin.AlterPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListPartitionReassignmentsResult listPartitionReassignments(java.util.Optional,org.apache.kafka.clients.admin.ListPartitionReassignmentsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache bootstrap(java.util.List)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.Map toOldGroupSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment toNewGroupAssignment(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.PartitionAssignorAdapter:java.util.List getAssignorInstances(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean checkAssignmentMatchedSubscription(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setNextAllowedRetry(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void requestFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeUpdateJoinedSubscription(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsForTimes(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedPartitions(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void clearBufferedDataForUnassignedTopics(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.consumer.NoOffsetForPartitionException:org.apache.kafka.common.TopicPartition partition()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.WindowedSum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.AbstractRecords$1:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:org.apache.kafka.common.record.RecordBatch firstBatch()",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map extractPotentialVariables(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map configProviderProperties(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:java.lang.String toString()",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$2:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.SslClientAuth:org.apache.kafka.common.config.SslClientAuth forConfig(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.util.List parseRules(java.util.List)",
            "org.apache.kafka.common.security.ssl.SslPrincipalMapper:java.lang.String getName(java.lang.String)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback,javax.security.auth.Subject)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleExtensionsCallback(org.apache.kafka.common.security.auth.SaslExtensionsCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void validateExtensions(org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin$1:org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredential expiringCredential()",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.SaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.network.Selector$IdleExpiryManager:java.util.Map$Entry pollExpiredConnection(long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void completeDelayedChannelClose(long)",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel lowestPriorityChannel()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void write(org.apache.kafka.common.protocol.Writable,org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:int size(org.apache.kafka.common.protocol.ObjectSerializationCache,short)",
            "org.apache.kafka.common.utils.LoggingSignalHandler:void register()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupPartitionsByTopic(java.util.Collection)",
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.CloseableIterator$1:java.lang.Object next()",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void changeCapacity(int)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashCollection:void <init>(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)",
            "org.apache.kafka.common.utils.Utils:int to32BitField(java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.String toString()",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void normalize()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupRequest:java.util.Map groupAssignments()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:java.util.List partitions()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.Map offsets()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:void setFlags(org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.util.Map groupByTopic(java.util.List)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.header.internals.RecordHeaders$1:org.apache.kafka.common.header.Header next()"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String access$300(org.apache.kafka.clients.FetchSessionHandler,java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerConfig:java.util.Map postProcessParsedConfig(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.CommonClientConfigs:java.util.Map postProcessReconnectBackoffConfigs(org.apache.kafka.common.config.AbstractConfig,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Map postProcessParsedConfig(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Map postProcessParsedConfig(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Map postProcessParsedConfig(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ValidList:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef$1:java.lang.String toString()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.Object newParameterizedInstance(java.lang.String,java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] authMessage(org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] clientSignature(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)",
            "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] clientProof(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)",
            "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] serverSignature(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:java.lang.String toMessage()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramMessages$AbstractScramMessage:byte[] toBytes()"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup forError(java.lang.String,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:void writeTo(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendControlRecord(long,org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)",
            "org.apache.kafka.common.record.EndTransactionMarker:java.nio.ByteBuffer serializeValue()",
            "org.apache.kafka.common.requests.RequestUtils:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.types.Struct,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:int sizeOf()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendControlRecord(long,org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)",
            "org.apache.kafka.common.record.EndTransactionMarker:java.nio.ByteBuffer serializeValue()",
            "org.apache.kafka.common.requests.RequestUtils:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.types.Struct,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:int sizeOf(short,java.util.Iterator)",
            "org.apache.kafka.common.requests.ResponseHeader:int sizeOf()"
        ]
    },
    "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object[] validate(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object validate(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object[] validate(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object validate(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String,boolean,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Field$Int64:void <init>(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$Int64:void <init>(java.lang.String,java.lang.String,long)",
            "org.apache.kafka.common.protocol.types.Field$ComplexArray:org.apache.kafka.common.protocol.types.Field withFields(org.apache.kafka.common.protocol.types.Field[])",
            "org.apache.kafka.common.protocol.types.Field$ComplexArray:org.apache.kafka.common.protocol.types.Field nullableWithFields(org.apache.kafka.common.protocol.types.Field[])",
            "org.apache.kafka.common.protocol.types.Field$ComplexArray:org.apache.kafka.common.protocol.types.Field withFields(java.lang.String,org.apache.kafka.common.protocol.types.Field[])",
            "org.apache.kafka.common.protocol.types.Field$CompactNullableStr:void <init>(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$CompactStr:void <init>(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$TaggedFieldsSection:void <init>(org.apache.kafka.common.protocol.types.Type)",
            "org.apache.kafka.common.protocol.types.Field$Int8:void <init>(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$Int8:void <init>(java.lang.String,java.lang.String,byte)",
            "org.apache.kafka.common.protocol.types.Field$Bool:void <init>(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type)",
            "org.apache.kafka.common.protocol.types.Field$CompactArray:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$Array:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$Str:void <init>(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$Int32:void <init>(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$Int32:void <init>(java.lang.String,java.lang.String,int)",
            "org.apache.kafka.common.protocol.types.Field$UUID:void <init>(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$UUID:void <init>(java.lang.String,java.lang.String,org.apache.kafka.common.protocol.types.Field$UUID)",
            "org.apache.kafka.common.protocol.types.Field$NullableStr:void <init>(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Field$Int16:void <init>(java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct validate(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Schema:java.lang.Object validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Struct:void validate()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void sendInitialToken()"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.RequestHeader)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long,org.apache.kafka.common.requests.AbstractRequest)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void sendHandshakeRequest(org.apache.kafka.common.requests.ApiVersionsResponse)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.requests.AbstractResponse parseResponse(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.AbstractResponse receiveKafkaResponse()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$10:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$9:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse$Holder holder()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Collection brokers()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map brokersById()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Collection topicMetadata()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Node controller()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void <init>(java.util.Collection,org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void tryComplete(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleFailure(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult$lambda_partitionResult_0__244:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$2:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult$lambda_memberResult_1__247:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$1:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void <init>(int,org.apache.kafka.common.KafkaFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture allOf(org.apache.kafka.common.KafkaFuture[])"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeAclsResult describeAcls(org.apache.kafka.common.acl.AclBindingFilter)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:boolean access$3000(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$26:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult deleteConsumerGroupOffsets(java.lang.String,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$lambda_createFutures_4__227:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$lambda_completeAllExceptionally_1__223:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.internals.AdminMetadataManager:void clearController()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void handleNotControllerError(org.apache.kafka.common.protocol.Errors)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster empty()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:void <init>(boolean,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)",
            "org.apache.kafka.clients.producer.MockProducer:void <init>(boolean,org.apache.kafka.clients.producer.Partitioner,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)",
            "org.apache.kafka.clients.producer.MockProducer:void <init>()",
            "org.apache.kafka.clients.admin.internals.AdminMetadataManager:void <init>(org.apache.kafka.common.utils.LogContext,long,long)",
            "org.apache.kafka.clients.MetadataCache:org.apache.kafka.clients.MetadataCache empty()"
        ]
    },
    "org.apache.kafka.clients.MetadataCache:void computeClusterView()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.MetadataCache:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node,org.apache.kafka.common.Cluster)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster withPartitions(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void tryConnect(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:boolean errorNext(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:boolean completeNext()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void forceClose()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void close(java.time.Duration,boolean)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture allOf(org.apache.kafka.common.KafkaFuture[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AlterConfigsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteTopicsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteRecordsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.AlterReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.CreatePartitionsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeConfigsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeTopicsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.CreateAclsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteAclsResult:org.apache.kafka.common.KafkaFuture all()"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture thenApply(org.apache.kafka.common.KafkaFuture$BaseFunction)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.ListTopicsResult:org.apache.kafka.common.KafkaFuture listings()",
            "org.apache.kafka.clients.admin.ListTopicsResult:org.apache.kafka.common.KafkaFuture names()",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult:void <init>(org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture config(java.lang.String)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture numPartitions(java.lang.String)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture replicationFactor(java.lang.String)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture lambda$values$1(java.util.Map$Entry)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeTopicsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteAclsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture thenApply(org.apache.kafka.common.KafkaFuture$Function)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:void copyWith(org.apache.kafka.common.KafkaFuture,org.apache.kafka.common.KafkaFuture$BaseFunction)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture whenComplete(org.apache.kafka.common.KafkaFuture$BiConsumer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.ElectLeadersResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:org.apache.kafka.common.KafkaFuture partitionResult(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:org.apache.kafka.common.KafkaFuture memberResult(org.apache.kafka.clients.admin.MemberToRemove)",
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult:org.apache.kafka.common.KafkaFuture partitionResult(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult:org.apache.kafka.common.KafkaFuture partitions()"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:java.lang.Object get()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DeleteAclsResult:java.util.List getAclBindings(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:java.lang.Object get(long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListTopicsResult listTopics(org.apache.kafka.clients.admin.ListTopicsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListTopicsResult listTopics()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeClusterResult describeCluster(org.apache.kafka.clients.admin.DescribeClusterOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeClusterResult describeCluster()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.RenewDelegationTokenResult renewDelegationToken(byte[],org.apache.kafka.clients.admin.RenewDelegationTokenOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.RenewDelegationTokenResult renewDelegationToken(byte[])"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ExpireDelegationTokenResult expireDelegationToken(byte[],org.apache.kafka.clients.admin.ExpireDelegationTokenOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ExpireDelegationTokenResult expireDelegationToken(byte[])"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeDelegationTokenResult describeDelegationToken(org.apache.kafka.clients.admin.DescribeDelegationTokenOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeDelegationTokenResult describeDelegationToken()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void rescheduleTask(org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext,java.util.function.Supplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void access$3100(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext,java.util.function.Supplier)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups(org.apache.kafka.clients.admin.ListConsumerGroupsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult listConsumerGroupOffsets(java.lang.String,org.apache.kafka.clients.admin.ListConsumerGroupOffsetsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult listConsumerGroupOffsets(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ElectLeadersResult electLeaders(org.apache.kafka.common.ElectionType,java.util.Set,org.apache.kafka.clients.admin.ElectLeadersOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ElectPreferredLeadersResult electPreferredLeaders(java.util.Collection,org.apache.kafka.clients.admin.ElectPreferredLeadersOptions)",
            "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ElectLeadersResult electLeaders(org.apache.kafka.common.ElectionType,java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult removeMembersFromConsumerGroup(java.lang.String,org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupOptions)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.ProducerMetadata:void <init>(long,long,org.apache.kafka.common.utils.LogContext,org.apache.kafka.common.internals.ClusterResourceListeners,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerMetadata:void <init>(long,long,boolean,boolean,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.utils.LogContext,org.apache.kafka.common.internals.ClusterResourceListeners)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void raise(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(org.apache.kafka.common.requests.LeaveGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void raise(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture failure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$RequestFutureCompletionHandler:void fireCompletion()",
            "org.apache.kafka.clients.consumer.internals.RequestFuture$2:void onFailure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onFailure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.AsyncClient$1:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AsyncClient$1:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.RequestFutureAdapter:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.BufferPool:java.nio.ByteBuffer allocate(int,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void reenqueueBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$1:void onSuccess(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$2000(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.common.TopicPartition,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$1900(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.common.TopicPartition,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void recordPollStart(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void recordPollEnd(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(org.apache.kafka.common.utils.Timer,boolean)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void record()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordBatchSplit()",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$1:void recordRebalanceFailure()",
            "org.apache.kafka.common.network.Selector:void register(java.lang.String,java.nio.channels.SocketChannel)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void doClose(org.apache.kafka.common.network.KafkaChannel,boolean)"
        ]
    },
    "org.apache.kafka.common.memory.SimpleMemoryPool:void maybeRecordEndOfDrySpell()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.memory.SimpleMemoryPool:java.nio.ByteBuffer tryAllocate(int)",
            "org.apache.kafka.common.memory.SimpleMemoryPool:void release(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void addToCompletedReceives(org.apache.kafka.common.network.KafkaChannel,java.util.Deque)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.producer.internals.RecordAccumulator,boolean,int,short,int,org.apache.kafka.clients.producer.internals.SenderMetricsRegistry,org.apache.kafka.common.utils.Time,int,long,org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.ApiVersions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void <init>(org.apache.kafka.common.utils.LogContext,int,org.apache.kafka.common.record.CompressionType,int,long,int,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.ApiVersions,org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.producer.internals.BufferPool)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry,org.apache.kafka.clients.consumer.internals.Fetcher$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,int,int,int,int,int,boolean,java.lang.String,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry,org.apache.kafka.common.utils.Time,long,long,org.apache.kafka.common.requests.IsolationLevel,org.apache.kafka.clients.ApiVersions)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$4100(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,java.lang.String,int,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.clients.GroupRebalanceConfig,org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.util.List,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void close(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Admin:void close(long,java.util.concurrent.TimeUnit)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.common.utils.LogContext,java.lang.String,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.clients.consumer.internals.Fetcher,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,long,long,int,java.util.List,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.Measurable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void registerMetrics(org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.Measurable)",
            "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void registerMetrics(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.AppInfoParser$AppInfo)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser:void registerAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics,long)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:java.lang.Object getAttribute(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.AttributeList getAttributes(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.metrics.KafkaMetric:double value()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void buildResponseOnAuthenticateFailure(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:java.lang.String handleHandshakeRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.SaslHandshakeRequest)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:java.lang.String handleHandshakeRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.SaslHandshakeRequest)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleApiVersionsRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.ApiVersionsRequest)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBufferAndUpdateInterestOps()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void send(org.apache.kafka.common.network.Send)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBufferAndUpdateInterestOps()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.network.Send)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.network.Send write()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void reauthenticate(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.security.auth.KafkaPrincipal principal()"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.security.auth.KafkaPrincipal principal()"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.security.auth.KafkaPrincipal principal()"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$1(java.lang.String,java.net.Socket,org.apache.kafka.common.security.authenticator.LoginManager,org.apache.kafka.common.network.TransportLayer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder$lambda_buildChannel_1__4:java.lang.Object get()"
        ]
    },
    "org.apache.kafka.common.network.Selector:void <init>(int,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void <init>(long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void <init>(long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.ElectLeadersRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.requests.JoinGroupResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.requests.OffsetCommitResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.LeaveGroupRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.requests.DeleteGroupsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.JoinGroupRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.requests.HeartbeatResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.InitProducerIdRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ElectLeadersResponse:org.apache.kafka.common.requests.ElectLeadersResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.requests.UpdateMetadataResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.HeartbeatRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.requests.IncrementalAlterConfigsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.ListPartitionReassignmentsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.requests.FindCoordinatorResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.requests.DeleteTopicsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.FindCoordinatorRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.CreateDelegationTokenRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.DeleteGroupsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.requests.CreateTopicsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:org.apache.kafka.common.requests.ListPartitionReassignmentsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.requests.StopReplicaResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.MetadataRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.DeleteTopicsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.requests.ListGroupsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.IncrementalAlterConfigsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.requests.LeaveGroupResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.requests.InitProducerIdResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.CreateTopicsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.requests.ControlledShutdownResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.DescribeGroupsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.requests.LeaderAndIsrResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.SyncGroupRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.requests.SyncGroupResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$27$lambda_createRequest_1__253:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.JoinGroupRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetDeleteResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetDeleteRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.requests.DescribeAclsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashCollection$ImplicitLinkedHashCollectionSetView:boolean add(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void maybeAddPartitionToTransaction(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void markSequenceUnresolved(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.IncompleteBatches:void add(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:void consumeAbortedTransactionsUpTo(long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void lambda$resetMissingPositions$7(java.util.Set,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void addPartitionMovementRecord(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.common.metrics.Sensor:void checkForest(java.util.Set)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object get(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void ignore(java.lang.String)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.security.plain.PlainLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean commit()",
            "org.apache.kafka.common.security.scram.ScramLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:javax.security.sasl.SaslServer createSaslKerberosServer(org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.util.Map,javax.security.auth.Subject)",
            "org.apache.kafka.common.network.Selector:void connect(java.lang.String,java.net.InetSocketAddress,int,int)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void mute(org.apache.kafka.common.network.KafkaChannel)",
            "org.apache.kafka.common.protocol.Protocol:void populateSchemaFields(org.apache.kafka.common.protocol.types.Schema,java.util.Set)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleApiVersionsRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.ApiVersionsRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse$lambda_prepareResponse_0__134:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse$lambda_prepareResponse_0__114:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse(int,byte)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse(int,byte)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords:java.util.Iterator iterator(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:void <init>(java.lang.String,org.apache.kafka.common.record.LazyDownConversionRecords)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:void access$600(org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin$Refresher:void run()"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] clientSignature(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:void verifyClientProof(org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] clientProof(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage handleServerFirstMessage(char[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] serverSignature(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:void handleServerFinalMessage(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$AbstractScramMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage:byte[] toBytes()",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFinalMessage:byte[] toBytes()",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:byte[] toBytes()",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage:byte[] toBytes()"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendControlRecord(long,org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendEndTxnMarker(long,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.record.EndTransactionMarker:java.nio.ByteBuffer serializeValue()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendEndTxnMarker(long,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.types.Struct,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:int sizeOf()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object validate(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object[] validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object[] validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String,boolean,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct validate(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object validate(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object[] validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object[] validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String,boolean,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct validate(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$Int64:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.CommonFields:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <clinit>()",
            "org.apache.kafka.common.requests.FetchRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <clinit>()",
            "org.apache.kafka.common.requests.FetchResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$Int64:void <init>(java.lang.String,java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$ComplexArray:org.apache.kafka.common.protocol.types.Field withFields(org.apache.kafka.common.protocol.types.Field[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:void <clinit>()",
            "org.apache.kafka.common.requests.FetchRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$ComplexArray:org.apache.kafka.common.protocol.types.Field nullableWithFields(org.apache.kafka.common.protocol.types.Field[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Field$ComplexArray:org.apache.kafka.common.protocol.types.Field withFields(java.lang.String,org.apache.kafka.common.protocol.types.Field[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Field$CompactNullableStr:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Field$CompactStr:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Field$TaggedFieldsSection:void <init>(org.apache.kafka.common.protocol.types.Type)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Field$TaggedFieldsSection:org.apache.kafka.common.protocol.types.Field$TaggedFieldsSection of(java.lang.Object[])"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$Int8:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.CommonFields:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <clinit>()",
            "org.apache.kafka.common.requests.FetchRequest:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$Int8:void <init>(java.lang.String,java.lang.String,byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.CommonFields:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$Bool:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:void <clinit>()",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void <clinit>()",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:void <clinit>()",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:void <clinit>()",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetResponseData:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void <clinit>()",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.HeartbeatResponseData:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:void <clinit>()",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void <clinit>()",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:void <clinit>()",
            "org.apache.kafka.common.message.RequestHeaderData:void <clinit>()",
            "org.apache.kafka.common.message.HeartbeatRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:void <clinit>()",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void <clinit>()",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData:void <clinit>()",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaRequestData:void <clinit>()",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void <clinit>()",
            "org.apache.kafka.common.message.EndTxnRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void <clinit>()",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.CreateAclsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void <clinit>()",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void <clinit>()",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:void <clinit>()",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void <clinit>()",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void <clinit>()",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void <clinit>()",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void <clinit>()",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void <clinit>()",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void <clinit>()",
            "org.apache.kafka.common.message.DescribeAclsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.ProduceRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void <clinit>()",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void <clinit>()",
            "org.apache.kafka.common.message.MetadataRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void <clinit>()",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void <clinit>()",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void <clinit>()",
            "org.apache.kafka.common.message.ListGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <clinit>()",
            "org.apache.kafka.common.message.CreateAclsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void <clinit>()",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.EndTxnResponseData:void <clinit>()",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void <clinit>()",
            "org.apache.kafka.common.message.FetchResponseData:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void <clinit>()",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void <clinit>()",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:void <clinit>()",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void <clinit>()",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void <clinit>()",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ResponseHeaderData:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void <clinit>()",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void <clinit>()",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:void <clinit>()",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void <clinit>()",
            "org.apache.kafka.common.message.FetchRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void <clinit>()",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ProduceResponseData:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void <clinit>()",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void <clinit>()",
            "org.apache.kafka.common.message.SyncGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.SyncGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.EndTxnRequest:void <clinit>()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceResponse:void <clinit>()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void <clinit>()",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:void <clinit>()",
            "org.apache.kafka.common.record.EndTransactionMarker:void <clinit>()",
            "org.apache.kafka.common.record.ControlRecordType:void <clinit>()",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <clinit>()",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.CreateAclsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceResponse:void <clinit>()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <clinit>()",
            "org.apache.kafka.common.requests.FetchResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$CompactArray:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Field$Array:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$Str:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.CommonFields:void <clinit>()",
            "org.apache.kafka.common.requests.FetchRequest:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$Int32:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.CommonFields:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <clinit>()",
            "org.apache.kafka.common.requests.FetchRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceResponse:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <clinit>()",
            "org.apache.kafka.common.requests.FetchResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$Int32:void <init>(java.lang.String,java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.CommonFields:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$UUID:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Field$UUID:void <init>(java.lang.String,java.lang.String,org.apache.kafka.common.protocol.types.Field$UUID)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Field$NullableStr:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.CommonFields:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$Int16:void <init>(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.CommonFields:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Schema:java.lang.Object validate(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object[] validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object[] validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Field:void <init>(java.lang.String,org.apache.kafka.common.protocol.types.Type,java.lang.String,boolean,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct validate(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:void validate()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void reauthenticate(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.network.KafkaChannel:void prepare()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void sendInitialToken()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void sendHandshakeRequest(org.apache.kafka.common.requests.ApiVersionsResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.AbstractResponse receiveKafkaResponse()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveToken()"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Collection brokers()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleSuccessfulResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Map brokersById()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Collection topicMetadata()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleSuccessfulResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Node controller()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:org.apache.kafka.common.Node controller(org.apache.kafka.common.requests.MetadataResponse)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils$lambda_transformMap_1__3:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils$lambda_transformMap_0__2:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Errors:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void addError(java.lang.Throwable,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveToken()",
            "org.apache.kafka.common.requests.ApiError:org.apache.kafka.common.errors.ApiException exception()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void handleNotControllerError(org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void access$3700(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.protocol.Errors)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:void <init>(boolean,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:void <init>(boolean,org.apache.kafka.clients.producer.Partitioner,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:void <init>()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.internals.AdminMetadataManager:void <init>(org.apache.kafka.common.utils.LogContext,long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:boolean completeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:void flush()"
        ]
    },
    "org.apache.kafka.clients.admin.AlterConfigsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DeleteConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DeleteTopicsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DeleteRecordsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeLogDirsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AlterReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.CreatePartitionsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeConfigsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeTopicsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AlterPartitionReassignmentsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.CreateAclsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DeleteAclsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.ListTopicsResult:org.apache.kafka.common.KafkaFuture listings()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.ListTopicsResult:org.apache.kafka.common.KafkaFuture names()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.ListConsumerGroupsResult:void <init>(org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups(org.apache.kafka.clients.admin.ListConsumerGroupsOptions)"
        ]
    },
    "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture config(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture numPartitions(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture replicationFactor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture lambda$values$1(java.util.Map$Entry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.CreateTopicsResult$lambda_values_1__238:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture thenApply(org.apache.kafka.common.KafkaFuture$Function)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.ElectLeadersResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult:org.apache.kafka.common.KafkaFuture all()"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:org.apache.kafka.common.KafkaFuture partitionResult(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:org.apache.kafka.common.KafkaFuture memberResult(org.apache.kafka.clients.admin.MemberToRemove)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.ElectPreferredLeadersResult:org.apache.kafka.common.KafkaFuture partitionResult(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.ElectPreferredLeadersResult:org.apache.kafka.common.KafkaFuture partitions()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListTopicsResult listTopics()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeClusterResult describeCluster()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.RenewDelegationTokenResult renewDelegationToken(byte[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ExpireDelegationTokenResult expireDelegationToken(byte[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.DescribeDelegationTokenResult describeDelegationToken()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void access$3100(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext,java.util.function.Supplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$26:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult listConsumerGroupOffsets(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ElectPreferredLeadersResult electPreferredLeaders(java.util.Collection,org.apache.kafka.clients.admin.ElectPreferredLeadersOptions)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.Admin:org.apache.kafka.clients.admin.ElectLeadersResult electLeaders(org.apache.kafka.common.ElectionType,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void raise(org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(org.apache.kafka.common.requests.LeaveGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture failure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture coordinatorNotAvailable()",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture noBrokersAvailable()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture$2:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AsyncClient$1:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onFailure(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onFailure(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFutureAdapter:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onFailure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$1:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$2000(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch,int)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$1900(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch,int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordBatchSplit()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$1:void recordRebalanceFailure()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$1:void onSuccess(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$1:void onFailure(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.common.memory.SimpleMemoryPool:java.nio.ByteBuffer tryAllocate(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.NetworkReceive:long readFrom(java.nio.channels.ScatteringByteChannel)"
        ]
    },
    "org.apache.kafka.common.memory.SimpleMemoryPool:void release(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.NetworkReceive:void close()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,int,int,int,int,int,boolean,java.lang.String,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry,org.apache.kafka.common.utils.Time,long,long,org.apache.kafka.common.requests.IsolationLevel,org.apache.kafka.clients.ApiVersions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.admin.Admin:void close(long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.common.utils.LogContext,java.lang.String,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.clients.consumer.internals.Fetcher,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.clients.consumer.internals.ConsumerMetadata,long,long,int,java.util.List,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.Measurable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void registerAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.AttributeList getAttributes(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:java.lang.String handleHandshakeRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.SaslHandshakeRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void send(org.apache.kafka.common.network.Send)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void sendHandshakeRequest(org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.network.Send)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendAuthenticationFailureResponse()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.security.auth.KafkaPrincipal principal()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SaslChannelBuilder$lambda_buildChannel_1__4:java.lang.Object get()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult handleCachedTransactionRequestResult(java.util.function.Supplier,org.apache.kafka.clients.producer.internals.TransactionManager$State)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void updatePreferredReadReplica(int,java.util.function.Supplier)",
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:java.lang.String toString()",
            "org.apache.kafka.common.network.KafkaChannel:void <init>(java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.function.Supplier,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginServerReauthentication(org.apache.kafka.common.network.NetworkReceive,java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginClientReauthentication(java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.utils.SystemTime:void waitObject(java.lang.Object,java.util.function.Supplier,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void <init>(long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetDeleteResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetDeleteResponse:org.apache.kafka.common.requests.OffsetDeleteResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.OffsetDeleteRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.requests.DescribeAclsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void maybeAddPartitionToTransaction(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void markSequenceUnresolved(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.IncompleteBatches:void add(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long,boolean)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:void consumeAbortedTransactionsUpTo(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void addPartitionMovementRecord(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void movePartition(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void checkForest(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:void <init>(org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.metrics.Sensor[],org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.utils.Time,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel)",
            "org.apache.kafka.common.metrics.Sensor:void checkForest(java.util.Set)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Object get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Short getShort(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Integer getInt(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Long getLong(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Double getDouble(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getList(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Boolean getBoolean(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.String getString(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.types.Password getPassword(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Class getClass(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void ignore(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.common.config.AbstractConfig$RecordingMap:java.lang.Object get(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.security.plain.PlainLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean commit()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.ScramLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void mute(org.apache.kafka.common.network.KafkaChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void mute(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void muteAll()"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:void populateSchemaFields(org.apache.kafka.common.protocol.types.Schema,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Protocol:void populateSchemaFields(org.apache.kafka.common.protocol.types.Schema,java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.DescribeLogDirsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleApiVersionsRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.ApiVersionsRequest)"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecordsSend:void <init>(java.lang.String,org.apache.kafka.common.record.LazyDownConversionRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords:org.apache.kafka.common.record.LazyDownConversionRecordsSend toSend(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin$Refresher:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void transitionState(org.apache.kafka.clients.consumer.internals.SubscriptionState$FetchState,java.lang.Runnable)",
            "org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SslEngineValidator)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslServer:void verifyClientProof(org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslClient:org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage handleServerFirstMessage(char[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslClient:void handleServerFinalMessage(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFinalMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendEndTxnMarker(long,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:void writeEndTransactionalMarker(java.nio.ByteBuffer,long,long,int,long,short,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.protocol.CommonFields:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.common.protocol.CommonFields:void <clinit>()",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <clinit>()",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.EndTxnRequest:void <clinit>()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeAclsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternSetStructFields(org.apache.kafka.common.resource.ResourcePattern,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternFilterSetStructFields(org.apache.kafka.common.resource.ResourcePatternFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceSetStructFields(org.apache.kafka.common.acl.AccessControlEntry,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceFilterSetStructFields(org.apache.kafka.common.acl.AccessControlEntryFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchRequest:void <clinit>()",
            "org.apache.kafka.common.requests.CreateAclsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiError:void write(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <clinit>()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <clinit>()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <clinit>()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.FetchResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.EndTxnResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.ListOffsetRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest build(short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.FetchRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchRequest:void <clinit>()",
            "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.FetchRequest build(short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest$lambda_toStruct_0__161:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.requests.ListOffsetResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.FetchResponse:int sizeOf(short,java.util.Iterator)",
            "org.apache.kafka.common.requests.FetchResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.ProduceResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.requests.ProduceResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:boolean hasUsableOffsetForLeaderEpochVersion(org.apache.kafka.clients.NodeApiVersions)",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest build(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Field$TaggedFieldsSection:org.apache.kafka.common.protocol.types.Field$TaggedFieldsSection of(java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void <clinit>()",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.HeartbeatResponseData:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.RequestHeaderData:void <clinit>()",
            "org.apache.kafka.common.message.HeartbeatRequestData:void <clinit>()",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData:void <clinit>()",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void <clinit>()",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void <clinit>()",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void <clinit>()",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void <clinit>()",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void <clinit>()",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void <clinit>()",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaResponseData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void <clinit>()",
            "org.apache.kafka.common.message.ListGroupsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ListGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void <clinit>()",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void <clinit>()",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void <clinit>()",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ResponseHeaderData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void <clinit>()",
            "org.apache.kafka.common.message.SyncGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.SyncGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ElectLeadersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:void <clinit>()",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.SaslAuthenticateResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.RenewDelegationTokenResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void <clinit>()",
            "org.apache.kafka.common.message.FetchRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.FetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void <clinit>()",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResourceCollection:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource find(byte,java.lang.String)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResourceCollection:java.util.List findAll(byte,java.lang.String)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.MetadataRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void <clinit>()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic lambda$convertToMetadataRequestTopic$0(java.lang.String)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:void lambda$new$0(org.apache.kafka.common.message.MetadataRequestData,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:void <init>(java.util.List)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartitionCollection:org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition find(int)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartitionCollection:java.util.List findAll(int)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:org.apache.kafka.common.requests.LeaveGroupRequest build(short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.MemberToRemove:org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity toMemberIdentity()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture maybeLeaveGroup(java.lang.String)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void <clinit>()",
            "org.apache.kafka.common.requests.LeaveGroupRequest:java.util.List members()"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void <clinit>()",
            "org.apache.kafka.common.message.ProduceResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void lambda$createRequest$1(org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopicCollection,java.lang.String,java.util.List)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopicCollection:org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic find(java.lang.String)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopicCollection:java.util.List findAll(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.HeartbeatResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.HeartbeatResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.HeartbeatResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.InitProducerIdRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.clients.ClientResponse sendAndAwaitInitProducerIdRequest(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult lambda$initializeTransactions$1()",
            "org.apache.kafka.common.message.InitProducerIdRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void <clinit>()",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection:org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey find(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection:java.util.List findAll(short)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(int,short,java.util.List,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void <clinit>()",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResultCollection:org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult find(java.lang.String)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResultCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition lambda$null$0(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ApiVersionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:void <clinit>()",
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void <clinit>()",
            "org.apache.kafka.common.message.ProduceRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.RenewDelegationTokenRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void <clinit>()",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment lambda$getErrorResponse$0(java.lang.Integer)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void <clinit>()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResultCollection:org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult find(java.lang.String)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResultCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void <clinit>()",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:void <clinit>()",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.RequestHeaderData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientRequest:org.apache.kafka.common.requests.RequestHeader makeHeader(short)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.RequestHeader nextRequestHeader(org.apache.kafka.common.protocol.ApiKeys,short)",
            "org.apache.kafka.common.message.RequestHeaderData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.RequestHeaderData:void <clinit>()",
            "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()",
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.ApiKeys,short,java.lang.String,int)",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.RequestHeader parse(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.message.HeartbeatRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendHeartbeatRequest()",
            "org.apache.kafka.common.message.HeartbeatRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void <clinit>()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getTopics(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void <clinit>()",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken lambda$new$1(org.apache.kafka.common.security.token.delegation.DelegationToken)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void <clinit>()",
            "org.apache.kafka.common.message.SyncGroupRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void <clinit>()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetDeleteRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner lambda$new$0(org.apache.kafka.common.security.auth.KafkaPrincipal)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse prepareResponse(int,java.util.Collection,java.lang.String,int,java.util.List,int)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse prepareResponse(int,org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.security.auth.KafkaPrincipal,long,long,long,java.lang.String,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void <clinit>()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.requests.StopReplicaRequest build(short)",
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:java.lang.String handleHandshakeRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.SaslHandshakeRequest)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void <clinit>()",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void <clinit>()",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void <clinit>()",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.EndTxnRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.EndTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.EndTxnRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopicCollection:org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic find(java.lang.String)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopicCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopicCollection:org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic find(java.lang.String)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopicCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$1(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup groupMetadata(java.lang.String,org.apache.kafka.common.protocol.Errors,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.Set)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup groupMetadata(java.lang.String,org.apache.kafka.common.protocol.Errors,java.lang.String,java.lang.String,java.lang.String,java.util.List,int)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void <clinit>()",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void <clinit>()",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void <clinit>()",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.FindCoordinatorResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FindCoordinatorResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.requests.FindCoordinatorResponse prepareResponse(org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.requests.LeaderAndIsrRequest build(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void <clinit>()",
            "org.apache.kafka.common.message.ListGroupsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void <clinit>()",
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic lambda$build$0(java.util.Map$Entry)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void <clinit>()",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.FindCoordinatorRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void lookupCoordinator(org.apache.kafka.common.requests.FindCoordinatorRequest$CoordinatorType,java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:org.apache.kafka.common.requests.FindCoordinatorRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendFindCoordinatorRequest(org.apache.kafka.common.Node)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void <clinit>()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader lambda$build$0(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void <clinit>()",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void <clinit>()",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$26:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void <clinit>()",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.message.ElectLeadersRequestData toRequestData(short)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.SaslHandshakeRequest createSaslHandshakeRequest(short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember groupMember(java.lang.String,java.lang.String,java.lang.String,java.lang.String,byte[],byte[])"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ControlledShutdownRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopicCollection:org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic find(java.lang.String)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopicCollection:java.util.List findAll(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResultCollection:org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult find(java.lang.String)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResultCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void <clinit>()",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResultCollection:org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult find(int)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResultCollection:java.util.List findAll(int)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void <clinit>()",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartitionCollection:org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition find(java.lang.String,int)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartitionCollection:java.util.List findAll(java.lang.String,int)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void <clinit>()",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void <clinit>()",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:void lambda$prepareResponse$0(org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartitionCollection,org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfigCollection:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig find(java.lang.String,byte)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfigCollection:java.util.List findAll(java.lang.String,byte)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfigCollection:org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig find(java.lang.String)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfigCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:void <clinit>()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(int,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.message.SaslAuthenticateRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void <clinit>()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState lambda$groupByTopic$1(org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.StopReplicaResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirCollection:org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir find(java.lang.String)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(java.util.List,boolean,short,short)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void <clinit>()",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer lambda$null$0(org.apache.kafka.common.security.auth.KafkaPrincipal)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignmentCollection:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment find(int)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignmentCollection:java.util.List findAll(int)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void <clinit>()",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.NewTopic:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic convertToCreatableTopic()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopicCollection:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic find(java.lang.String)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopicCollection:java.util.List findAll(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void <clinit>()",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResultCollection:org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult find(java.lang.String)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResultCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.EndTxnResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.EndTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.EndTxnResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(java.util.List,org.apache.kafka.common.protocol.Errors,int,short)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void <clinit>()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.message.IncrementalAlterConfigsResponseData toResponseData(int,java.util.Map)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void <clinit>()",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void <clinit>()",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void <clinit>()",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void <clinit>()",
            "org.apache.kafka.common.message.FetchRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.FetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.FetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData:void <clinit>()",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.InitProducerIdResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.InitProducerIdResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.InitProducerIdResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ResponseHeaderData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ResponseHeaderData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void <clinit>()",
            "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()",
            "org.apache.kafka.common.requests.ResponseHeader:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ResponseHeader:void <init>(int,short)",
            "org.apache.kafka.common.requests.ResponseHeader:org.apache.kafka.common.requests.ResponseHeader parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void <clinit>()",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:void <clinit>()",
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0 lambda$build$1(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void <clinit>()",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void <clinit>()",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBrokerCollection:org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker find(int)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBrokerCollection:java.util.List findAll(int)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void <clinit>()",
            "org.apache.kafka.common.requests.MetadataResponse:void lambda$prepareResponse$0(org.apache.kafka.common.message.MetadataResponseData,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:java.util.List getErrorResponseTopics(java.util.List,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(int,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfigCollection:org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig find(java.lang.String)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfigCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:void <clinit>()",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void <clinit>()",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void <clinit>()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState lambda$groupByTopic$1(org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.common.message.JoinGroupRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol find(java.lang.String)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void <clinit>()",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void <clinit>()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic lambda$getTopics$0(java.util.Map$Entry)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.Map)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchPartition:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void <clinit>()",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void <clinit>()",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.requests.ControlledShutdownResponse prepareResponse(org.apache.kafka.common.protocol.Errors,java.util.Set)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void <clinit>()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopicCollection:org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic find(java.lang.String)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopicCollection:java.util.List findAll(java.lang.String)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResourceCollection:org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource find(byte,java.lang.String)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResourceCollection:java.util.List findAll(byte,java.lang.String)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinFollower()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupResponseData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.SyncGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void read(org.apache.kafka.common.protocol.Readable,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void <clinit>()",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse lambda$getErrorResponse$0(org.apache.kafka.common.requests.ApiError,org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest$Builder:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest build(short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.EndTxnRequest:void <clinit>()",
            "org.apache.kafka.common.requests.EndTxnRequest$Builder:org.apache.kafka.common.requests.EndTxnRequest build(short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest$Builder:org.apache.kafka.common.requests.WriteTxnMarkersRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:org.apache.kafka.common.requests.DescribeConfigsRequest build(short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AlterConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AlterConfigsRequest$Builder:org.apache.kafka.common.requests.AlterConfigsRequest build(short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.CreatePartitionsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest$Builder:org.apache.kafka.common.requests.CreatePartitionsRequest build(short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.requests.WriteTxnMarkersResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.DeleteRecordsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest$Builder:org.apache.kafka.common.requests.DeleteRecordsRequest build(short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.requests.DescribeAclsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeAclsResponse$lambda_toStruct_0__128:java.lang.Object apply(java.lang.Object)",
            "org.apache.kafka.common.requests.DescribeAclsResponse$lambda_validate_1__132:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.requests.DescribeLogDirsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.requests.CreatePartitionsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest$Builder:org.apache.kafka.common.requests.AddPartitionsToTxnRequest build(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.requests.DeleteRecordsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short,boolean)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest$Builder:org.apache.kafka.common.requests.DescribeLogDirsRequest build(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.DescribeLogDirsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.requests.DeleteAclsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse$lambda_validate_2__119:java.lang.Object apply(java.lang.Object)",
            "org.apache.kafka.common.requests.DeleteAclsResponse$lambda_validate_0__122:java.lang.Object apply(java.lang.Object)",
            "org.apache.kafka.common.requests.DeleteAclsResponse$lambda_validate_1__126:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer subscriptionUserData(java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData memberData(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData deserializeTopicPartitionAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void <clinit>()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.lang.Short deserializeVersion(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription,short)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV0(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV1(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment,short)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignmentV0(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignmentV1(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:void <clinit>()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.common.record.EndTransactionMarker:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.EndTransactionMarker:void <init>(org.apache.kafka.common.record.ControlRecordType,int)",
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.protocol.types.Struct buildRecordValue()",
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.record.EndTransactionMarker deserialize(org.apache.kafka.common.record.Record)",
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.record.EndTransactionMarker deserializeValue(org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)",
            "org.apache.kafka.common.record.EndTransactionMarker:void <clinit>()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,long,int,long,short,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.record.ControlRecordType:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.common.record.EndTransactionMarker:void ensureTransactionMarkerControlType(org.apache.kafka.common.record.ControlRecordType)",
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.record.EndTransactionMarker deserialize(org.apache.kafka.common.record.Record)",
            "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.record.ControlRecordType[] values()",
            "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.protocol.types.Struct recordKey()",
            "org.apache.kafka.common.record.ControlRecordType:short parseTypeId(java.nio.ByteBuffer)",
            "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.record.ControlRecordType fromTypeId(short)",
            "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.record.ControlRecordType parse(java.nio.ByteBuffer)",
            "org.apache.kafka.common.record.ControlRecordType:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.requests.AlterConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.requests.CreateAclsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <clinit>()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.CreateAclsRequest$Builder:org.apache.kafka.common.requests.CreateAclsRequest build(short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.CreateAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateAclsRequest$lambda_validate_0__156:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.requests.AddPartitionsToTxnResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <clinit>()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.requests.AlterReplicaLogDirsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:org.apache.kafka.common.requests.DeleteAclsRequest build(short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.DeleteAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DeleteAclsRequest$lambda_validate_0__160:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void reauthenticate(org.apache.kafka.common.network.ReauthenticationContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveToken()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$5:org.apache.kafka.common.Node controller(org.apache.kafka.common.requests.MetadataResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.utils.Utils$lambda_transformMap_1__3:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.utils.Utils$lambda_transformMap_0__2:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.protocol.Errors:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.FetchSessionHandler:boolean handleResponse(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$EndTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$FindCoordinatorHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean canRetry(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$InitProducerIdHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddOffsetsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void lambda$null$3(java.util.Map,org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic,org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$25:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$32:void <clinit>()",
            "org.apache.kafka.clients.admin.KafkaAdminClient:boolean handleGroupRequestError(org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean lambda$hasCoordinatorMoved$0(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$28:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(org.apache.kafka.common.requests.LeaveGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture coordinatorNotAvailable()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$6:void <clinit>()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch initializeCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean lambda$null$0(org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveToken()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void handleSaslHandshakeResponse(org.apache.kafka.common.requests.SaslHandshakeResponse)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:java.lang.String handleHandshakeRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.SaslHandshakeRequest)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleApiVersionsRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.ApiVersionsRequest)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$1:void <clinit>()",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors[] values()",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forCode(short)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forException(java.lang.Throwable)",
            "org.apache.kafka.common.protocol.Errors:java.lang.String toHtml()",
            "org.apache.kafka.common.protocol.Errors:void main(java.lang.String[])",
            "org.apache.kafka.common.protocol.Errors:void <clinit>()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:boolean hasError()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <clinit>()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.StopReplicaResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.Errors lambda$errorCounts$0(org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:boolean hasError()",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.ApiError:org.apache.kafka.common.requests.ApiError fromThrowable(java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiError:void write(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiError:boolean isSuccess()",
            "org.apache.kafka.common.requests.ApiError:void <clinit>()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:boolean hasError()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void lambda$errorCounts$0(java.util.Map,org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.SyncGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchResponse$PartitionData:boolean hasError()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.FetchResponse:int sizeOf(short,java.util.Iterator)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors topLevelError()",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.EpochEndOffset:void <init>(int,long)",
            "org.apache.kafka.common.requests.EpochEndOffset:boolean hasError()",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:boolean hasError()",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:boolean hasError()",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map errorCounts(java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.Errors lambda$errorCounts$0(org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.JoinGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.InitProducerIdResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:boolean hasError()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.ApiVersionsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.Errors get(java.lang.String)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.protocol.Errors$lambda_static_0__20:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void addError(java.lang.Throwable,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleFailure(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:org.apache.kafka.common.errors.ApiException exception()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void access$3700(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:void flush()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:void commitTransaction()",
            "org.apache.kafka.clients.producer.MockProducer:void abortTransaction()"
        ]
    },
    "org.apache.kafka.clients.admin.CreateTopicsResult$lambda_values_1__238:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.admin.ElectPreferredLeadersResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture coordinatorNotAvailable()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture noBrokersAvailable()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture lookupCoordinator()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onFailure(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$1:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.common.network.NetworkReceive:long readFrom(java.nio.channels.ScatteringByteChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveResponseOrToken()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()",
            "org.apache.kafka.common.network.KafkaChannel:long receive(org.apache.kafka.common.network.NetworkReceive)"
        ]
    },
    "org.apache.kafka.common.network.NetworkReceive:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendAuthenticationFailureResponse()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleAuthenticationFailure()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteResponse:org.apache.kafka.common.requests.OffsetDeleteResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.OffsetDeleteRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void movePartition(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void access$200(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements,org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void <init>(org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.metrics.Sensor[],org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.utils.Time,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Short getShort(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Integer getInt(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)",
            "org.apache.kafka.clients.producer.KafkaProducer:int configureDeliveryTimeout(org.apache.kafka.clients.producer.ProducerConfig,org.slf4j.Logger)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)",
            "org.apache.kafka.clients.producer.KafkaProducer:int configureRetries(org.apache.kafka.clients.producer.ProducerConfig,boolean,org.slf4j.Logger)",
            "org.apache.kafka.clients.producer.KafkaProducer:int configureInflightRequests(org.apache.kafka.clients.producer.ProducerConfig,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.GroupRebalanceConfig:void <init>(org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.clients.GroupRebalanceConfig$ProtocolType)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.metrics.Metrics buildMetrics(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.utils.Time,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Long getLong(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)",
            "org.apache.kafka.clients.producer.KafkaProducer:int lingerMs(org.apache.kafka.clients.producer.ProducerConfig)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.GroupRebalanceConfig:void <init>(org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.clients.GroupRebalanceConfig$ProtocolType)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.metrics.Metrics buildMetrics(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.utils.Time,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Double getDouble(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.List getList(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Boolean getBoolean(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)",
            "org.apache.kafka.clients.GroupRebalanceConfig:void <init>(org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.clients.GroupRebalanceConfig$ProtocolType)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.String getString(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)",
            "org.apache.kafka.clients.producer.KafkaProducer:short configureAcks(org.apache.kafka.clients.producer.ProducerConfig,boolean,org.slf4j.Logger)",
            "org.apache.kafka.clients.ClientUtils:org.apache.kafka.common.network.ChannelBuilder createChannelBuilder(org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.lang.String generateClientId(org.apache.kafka.clients.admin.AdminClientConfig)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.GroupRebalanceConfig:void <init>(org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.clients.GroupRebalanceConfig$ProtocolType)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.metrics.Metrics buildMetrics(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.utils.Time,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.types.Password getPassword(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Class getClass(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.String,java.lang.Class)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig$RecordingMap:java.lang.Object get(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:java.util.Optional lastSeenLeaderEpoch(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:java.util.Optional partitionInfoIfCurrent(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.Metadata:void lambda$handleMetadataResponse$3(java.util.Map,java.util.List,org.apache.kafka.clients.MetadataCache$PartitionInfoAndEpoch)",
            "org.apache.kafka.clients.ApiVersions:org.apache.kafka.clients.NodeApiVersions get(java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:long nextOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry getPartition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:java.util.OptionalLong lastAckedOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:java.util.OptionalInt lastAckedSequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List inFlightBatches(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.Sender:void maybeRemoveFromInflightBatches(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.ProducerMetadata:boolean retainTopic(java.lang.String,boolean,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean isMuted(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.CommonClientConfigs:java.util.Map postProcessReconnectBackoffConfigs(org.apache.kafka.common.config.AbstractConfig,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:org.apache.kafka.clients.admin.ConfigEntry get(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture config(java.lang.String)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture numPartitions(java.lang.String)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture replicationFactor(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.AlterConfigOp$OpType:org.apache.kafka.clients.admin.AlterConfigOp$OpType forId(byte)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.lang.Throwable getSubLevelError(java.util.Map,java.lang.Object,java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.MetadataCache:java.util.Optional getPartitionInfoHavingEpoch(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.MetadataCache:java.util.Optional getPartitionInfo(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean canConnect(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isBlackedOut(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long connectionDelay(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnecting(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isPreparingConnection(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void connecting(java.lang.String,long,java.lang.String,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.ClusterConnectionStates:void throttle(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long throttleDelayMs(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isReady(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isDisconnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.common.errors.AuthenticationException authenticationException(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ClusterConnectionStates$NodeConnectionState nodeState(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:void add(org.apache.kafka.clients.NetworkClient$InFlightRequest)",
            "org.apache.kafka.clients.InFlightRequests:java.util.Deque requestQueue(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean canSendMore(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:int count(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Iterable clearAll(java.lang.String)",
            "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys,short,short)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.clients.ApiVersion)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.ApiVersion apiVersion(org.apache.kafka.common.protocol.ApiKeys)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resetOffsetPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata lambda$committed$3(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void lambda$onSuccess$1(java.util.Map,java.util.Map,org.apache.kafka.common.TopicPartition,org.apache.kafka.common.requests.EpochEndOffset)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair removeMovementRecordOfPartition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void addPartitionMovementRecord(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$SubscriptionComparator:int compare(java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(org.apache.kafka.common.TopicPartition,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void processPartitionMovement(org.apache.kafka.common.TopicPartition,java.lang.String,java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void lambda$assign$1(java.util.Map,java.util.Map,java.lang.String,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean lambda$assign$0(java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map fetchedRecords()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.FetchSessionHandler sessionHandler(int)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionComparator:int compare(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.List records(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean removeAttribute(org.apache.kafka.common.metrics.KafkaMetric,java.lang.String)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean addAttribute(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:java.lang.Object getAttribute(java.lang.String)",
            "org.apache.kafka.common.ConsumerGroupState:org.apache.kafka.common.ConsumerGroupState parse(java.lang.String)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:java.nio.ByteBuffer get(int)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:void release(java.nio.ByteBuffer)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:int compare(org.apache.kafka.common.config.ConfigDef$ConfigKey,org.apache.kafka.common.config.ConfigDef$ConfigKey,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object get(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.ConfigDef$Type typeOf(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig$ResolvingMap:java.lang.Object get(java.lang.Object)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:java.lang.String replace(java.util.Map,java.lang.String,java.util.regex.Pattern)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String owner(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String tokenIdForHmac(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation tokenForHmac(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation token(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:java.lang.String getServiceName(java.util.Map,java.lang.String,javax.security.auth.login.Configuration)",
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntry(java.util.Map,java.util.Map,java.lang.Object)",
            "org.apache.kafka.common.security.ssl.SslEngineBuilder:void <init>(java.util.Map)",
            "org.apache.kafka.common.security.auth.SecurityProtocol:org.apache.kafka.common.security.auth.SecurityProtocol forId(short)",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer$PlainSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)",
            "org.apache.kafka.common.security.plain.PlainLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerExtensionsValidatorCallback:void valid(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object rawClaim(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.String[] mechanismNamesCompatibleWithPolicy(java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadServerContext(org.apache.kafka.common.network.ListenerName,java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadClientContext(java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramExtensions:boolean tokenAuthenticated()",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramMechanism:org.apache.kafka.common.security.scram.internals.ScramMechanism forMechanismName(java.lang.String)",
            "org.apache.kafka.common.security.scram.ScramLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.RequestHeader nextRequestHeader(org.apache.kafka.common.protocol.ApiKeys,short)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void createSaslServer(java.lang.String)",
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.security.authenticator.LoginManager:java.lang.Class configuredClassOrDefault(java.util.Map,org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo:long calcCompletionTimesAndReturnSessionLifetimeMs()",
            "org.apache.kafka.common.serialization.StringDeserializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.UUIDSerializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.UUIDDeserializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.StringSerializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:void close(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void close(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.Selector$CloseMode)",
            "org.apache.kafka.common.network.Selector:boolean isChannelReady(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel openOrClosingChannelOrFail(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel channel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel closingChannel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void addToStagedReceives(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.NetworkReceive)",
            "org.apache.kafka.common.network.Selector:int numStagedReceives(org.apache.kafka.common.network.KafkaChannel)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.security.ssl.SslPrincipalMapper)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createClientCallbackHandler(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$1(java.lang.String,java.net.Socket,org.apache.kafka.common.security.authenticator.LoginManager,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.network.SslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.utils.LoggingSignalHandler$1:java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])",
            "org.apache.kafka.common.utils.SecurityUtils:void addConfiguredSecurityProviders(java.util.Map)",
            "org.apache.kafka.common.utils.SecurityUtils:org.apache.kafka.common.resource.ResourceType resourceType(java.lang.String)",
            "org.apache.kafka.common.utils.SecurityUtils:org.apache.kafka.common.acl.AclOperation operation(java.lang.String)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object get(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.NavigableMap read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.BoundField get(java.lang.String)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forCode(short)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forException(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:void updateErrorCounts(java.util.Map,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:java.util.Collection configNames(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errors(long)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse$Config config(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:void <init>(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node nodeById(int)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node leaderFor(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.PartitionInfo partition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:java.lang.Integer partitionCountForTopic(java.lang.String)",
            "org.apache.kafka.common.resource.ResourceType:org.apache.kafka.common.resource.ResourceType fromCode(byte)",
            "org.apache.kafka.common.acl.AclPermissionType:org.apache.kafka.common.acl.AclPermissionType fromCode(byte)",
            "org.apache.kafka.common.acl.AclOperation:org.apache.kafka.common.acl.AclOperation fromCode(byte)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1$get__270:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void mute(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.DescribeLogDirsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords:org.apache.kafka.common.record.LazyDownConversionRecordsSend toSend(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords:org.apache.kafka.common.record.RecordsSend toSend(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:void writeEndTransactionalMarker(java.nio.ByteBuffer,long,long,int,long,short,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,long,int,long,short,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.requests.AlterConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.ListOffsetRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.DescribeAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:void <clinit>()",
            "org.apache.kafka.common.requests.DescribeAclsRequest$Builder:org.apache.kafka.common.requests.DescribeAclsRequest build(short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:org.apache.kafka.common.requests.CreateAclsRequest$AclCreation fromStruct(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:void resourcePatternSetStructFields(org.apache.kafka.common.resource.ResourcePattern,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:void setStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:void resourcePatternFilterSetStructFields(org.apache.kafka.common.resource.ResourcePatternFilter,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:org.apache.kafka.common.requests.CreateAclsRequest$AclCreation fromStruct(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:void aceSetStructFields(org.apache.kafka.common.acl.AccessControlEntry,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:void setStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:void aceFilterSetStructFields(org.apache.kafka.common.acl.AccessControlEntryFilter,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.requests.CreateAclsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.FetchRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:void write(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.CreatePartitionsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.requests.ProduceResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.requests.WriteTxnMarkersResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.DeleteRecordsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.requests.ListOffsetResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.requests.DescribeLogDirsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.requests.AddPartitionsToTxnResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.requests.CreatePartitionsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest$Builder:org.apache.kafka.common.requests.AddOffsetsToTxnRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.requests.DeleteRecordsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.requests.AlterReplicaLogDirsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.requests.AddOffsetsToTxnResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.requests.AddOffsetsToTxnResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.requests.DeleteAclsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.requests.EndTxnResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.requests.EndTxnResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.EndTxnResponse:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.ClientRequest:org.apache.kafka.common.requests.RequestHeader makeHeader(short)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.clients.ApiVersion)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:boolean hasUsableOffsetForLeaderEpochVersion(org.apache.kafka.clients.NodeApiVersions)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void sendHandshakeRequest(org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void saslAuthenticateVersion(org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])",
            "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()",
            "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.ApiKeys[] values()",
            "org.apache.kafka.common.protocol.ApiKeys:void <init>(java.lang.String,int,int,java.lang.String,boolean,byte,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[])",
            "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.ApiKeys forId(int)",
            "org.apache.kafka.common.protocol.ApiKeys:boolean hasId(int)",
            "org.apache.kafka.common.protocol.ApiKeys:java.lang.String toHtml()",
            "org.apache.kafka.common.protocol.ApiKeys:void main(java.lang.String[])",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.requests.AlterConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListGroupsRequest$Builder:void <init>(org.apache.kafka.common.message.ListGroupsRequestData)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(java.util.Map,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(int,java.util.Map,org.apache.kafka.common.requests.IsolationLevel,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.ListOffsetRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(short,java.lang.String,long,short,org.apache.kafka.common.requests.TransactionResult)",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.message.ControlledShutdownRequestData,short)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(short,java.util.List)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateAclsRequest$Builder:void <init>(java.util.List)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$Builder:void <init>(org.apache.kafka.common.message.ListPartitionReassignmentsRequestData)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:void <init>(org.apache.kafka.common.acl.AclBindingFilter,short)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.DescribeAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.requests.OffsetFetchResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.requests.StopReplicaResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.message.MetadataRequestData,short)",
            "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.MetadataRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest$Builder:void <init>(org.apache.kafka.common.message.OffsetCommitRequestData)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:void <init>(java.util.Map)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest$Builder:void <init>(org.apache.kafka.common.message.SaslAuthenticateRequestData)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.requests.CreateAclsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(short,java.util.Map,boolean)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:void <init>(java.util.List)",
            "org.apache.kafka.common.requests.HeartbeatRequest$Builder:void <init>(org.apache.kafka.common.message.HeartbeatRequestData)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:void <init>(org.apache.kafka.common.message.DescribeGroupsRequestData)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.message.SaslAuthenticateRequestData)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.message.SaslAuthenticateRequestData,short)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.SaslAuthenticateRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.requests.ExpireDelegationTokenResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.message.ListPartitionReassignmentsRequestData,short)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.ListPartitionReassignmentsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:void <init>(org.apache.kafka.common.message.ElectLeadersRequestData,short)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.ElectLeadersRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(short,int,int,int,int,java.util.Map,org.apache.kafka.common.requests.IsolationLevel,java.util.List,org.apache.kafka.common.requests.FetchMetadata,java.lang.String)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.FetchRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.message.UpdateMetadataRequestData,short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:void <init>(short,java.util.List)",
            "org.apache.kafka.common.requests.CreateAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.CreateAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(short,java.util.Map,boolean)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AlterConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.requests.HeartbeatResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:void <init>(short,int,int,long,java.util.List,java.util.Collection)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.message.LeaderAndIsrRequestData,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(java.util.Map,int,boolean,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.CreatePartitionsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.requests.ProduceResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.requests.WriteTxnMarkersResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.message.SyncGroupRequestData,short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.SyncGroupRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:void <init>(org.apache.kafka.common.message.ApiVersionsRequestData,short,java.lang.Short)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:void <init>(org.apache.kafka.common.message.DeleteGroupsRequestData,short)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.DeleteGroupsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.message.OffsetFetchRequestData,short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(int,java.util.Map,short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.DeleteRecordsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.requests.DescribeDelegationTokenResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeAclsRequest$Builder:void <init>(org.apache.kafka.common.acl.AclBindingFilter)",
            "org.apache.kafka.common.requests.AbstractRequest$1:void <clinit>()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.requests.ListOffsetResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData,short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:void <init>(org.apache.kafka.common.message.DeleteTopicsRequestData)",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:void <init>()",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:void <init>(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest$Builder:void <init>(java.lang.String,long,short,java.util.List)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.requests.ControlledShutdownResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.requests.DescribeAclsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest$Builder:void <init>(java.util.Set)",
            "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.message.LeaveGroupRequestData,short)",
            "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.LeaveGroupRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder:void <init>(short,int,int,long,boolean,java.util.Collection)",
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest$Builder forConsumer(boolean,org.apache.kafka.common.requests.IsolationLevel)",
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:void <init>(short,short,int,org.apache.kafka.common.requests.IsolationLevel)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.message.DescribeGroupsRequestData,short)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.DescribeGroupsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest$Builder:void <init>(org.apache.kafka.common.message.CreateTopicsRequestData)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:org.apache.kafka.common.requests.OffsetDeleteResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.requests.SyncGroupResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:void <init>(org.apache.kafka.common.message.DeleteGroupsRequestData)",
            "org.apache.kafka.common.requests.AbstractResponse$1:void <clinit>()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest$Builder:void <init>(java.util.Map,int,boolean)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest$Builder:void <init>(org.apache.kafka.common.message.OffsetDeleteRequestData)",
            "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.message.HeartbeatRequestData,short)",
            "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.HeartbeatRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.FetchRequest$Builder forConsumer(int,int,java.util.Map)",
            "org.apache.kafka.common.requests.FetchRequest$Builder:void <init>(short,short,int,int,int,java.util.Map)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest$Builder:void <init>(org.apache.kafka.common.message.CreateDelegationTokenRequestData)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.message.CreateDelegationTokenRequestData,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.CreateDelegationTokenRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:void <init>(java.util.List)",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:void <init>(org.apache.kafka.common.message.RenewDelegationTokenRequestData,short)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.RenewDelegationTokenRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.requests.DescribeLogDirsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.requests.AddPartitionsToTxnResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest$Builder forMagic(byte,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:void <init>(short,short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest$Builder:void <init>(org.apache.kafka.common.message.ExpireDelegationTokenRequestData)",
            "org.apache.kafka.common.requests.RequestContext:boolean isUnsupportedApiVersionsRequest()",
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.ApiKeys,short,java.lang.String,int)",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.protocol.ApiKeys apiKey()",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.RequestHeader parse(java.nio.ByteBuffer)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest$Builder:void <init>(org.apache.kafka.common.message.TxnOffsetCommitRequestData)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(java.util.Map,int,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.requests.CreatePartitionsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(short,java.lang.String,long,short,java.util.List)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.message.OffsetCommitRequestData,short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.message.TxnOffsetCommitRequestData,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$Builder:void <init>(org.apache.kafka.common.message.IncrementalAlterConfigsRequestData)",
            "org.apache.kafka.common.requests.SyncGroupRequest$Builder:void <init>(org.apache.kafka.common.message.SyncGroupRequestData)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest$Builder:void <init>(org.apache.kafka.common.message.RenewDelegationTokenRequestData)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(short,java.lang.String,long,short,java.lang.String)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.requests.LeaveGroupResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.requests.DeleteTopicsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.requests.FindCoordinatorResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.requests.DeleteRecordsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:void <init>(org.apache.kafka.common.message.DescribeDelegationTokenRequestData,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:void <init>(short,short,java.util.Map,int)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder forConsumer(java.util.Map)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.message.CreateTopicsRequestData,short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.CreateTopicsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest$Builder:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.common.requests.ListGroupsRequest:void <init>(org.apache.kafka.common.message.ListGroupsRequestData,short)",
            "org.apache.kafka.common.requests.ListGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.requests.SaslHandshakeResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.requests.IncrementalAlterConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(java.util.Set,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.DescribeLogDirsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.requests.AlterReplicaLogDirsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.message.DeleteTopicsRequestData,short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.DeleteTopicsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest$Builder:void <init>(int,java.util.Map)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.requests.LeaderAndIsrResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.requests.UpdateMetadataResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.EndTxnRequest$Builder:void <init>(java.lang.String,long,short,org.apache.kafka.common.requests.TransactionResult)",
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.message.StopReplicaRequestData,short)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.requests.ListGroupsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest$Builder:void <init>(org.apache.kafka.common.message.ControlledShutdownRequestData,short)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.requests.CreateTopicsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.message.ExpireDelegationTokenRequestData,short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.ExpireDelegationTokenRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$Builder:void <init>(org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.requests.AddOffsetsToTxnResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:void <init>(org.apache.kafka.common.message.IncrementalAlterConfigsRequestData,short)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.IncrementalAlterConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.requests.DeleteAclsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:org.apache.kafka.common.requests.ListPartitionReassignmentsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.requests.JoinGroupResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.InitProducerIdRequest$Builder:void <init>(org.apache.kafka.common.message.InitProducerIdRequestData)",
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.message.JoinGroupRequestData,short)",
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.JoinGroupRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.requests.InitProducerIdResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.JoinGroupRequest$Builder:void <init>(org.apache.kafka.common.message.JoinGroupRequestData)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.requests.RenewDelegationTokenResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:void <init>(java.lang.String,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:void <init>(java.lang.String,java.util.List,short,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest$Builder:void <init>(java.util.Map)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.requests.OffsetCommitResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:void <init>(org.apache.kafka.common.ElectionType,java.util.Collection,int)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.requests.TxnOffsetCommitResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.message.InitProducerIdRequestData,short)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.InitProducerIdRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.requests.DeleteGroupsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:void <init>(short,int,int,long,java.util.List,java.util.List)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest$Builder:void <init>(org.apache.kafka.common.message.FindCoordinatorRequestData)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.message.FindCoordinatorRequestData,short)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.FindCoordinatorRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest$Builder:void <init>(org.apache.kafka.common.message.SaslHandshakeRequestData)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest:void <init>(org.apache.kafka.common.message.OffsetDeleteRequestData,short)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.OffsetDeleteRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest$Builder:void <init>(java.lang.String,long,short,java.lang.String)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(org.apache.kafka.common.message.MetadataRequestData)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(java.util.List,boolean,short,short)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(java.util.List,boolean)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(int,short,java.util.List)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:org.apache.kafka.common.requests.ElectLeadersResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.message.SaslHandshakeRequestData)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.message.SaslHandshakeRequestData,short)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.SaslHandshakeRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest$Builder:void <init>(java.util.List)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(short,java.util.List)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.DeleteAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.requests.SaslAuthenticateResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.requests.EndTxnResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.ListOffsetRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.FetchRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.FetchRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest$lambda_toStruct_0__161:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.requests.ListOffsetResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.requests.ProduceResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:boolean hasUsableOffsetForLeaderEpochVersion(org.apache.kafka.clients.NodeApiVersions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListGroupsRequestData:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.message.ListGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void <clinit>()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.ListGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newRequest()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ApiMessageType:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.message.ApiMessageType[] values()",
            "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.message.ApiMessageType fromApiKey(short)",
            "org.apache.kafka.common.message.ApiMessageType:void <clinit>()",
            "org.apache.kafka.common.protocol.ApiKeys:short requestHeaderVersion(short)",
            "org.apache.kafka.common.protocol.ApiKeys:short responseHeaderVersion(short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslAuthenticateResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.protocol.ApiMessage newResponse()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.requests.SaslAuthenticateResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.message.RenewDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.requests.RenewDelegationTokenResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResourceCollection:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource find(byte,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResourceCollection:java.util.List findAll(byte,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic lambda$convertToMetadataRequestTopic$0(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest$lambda_convertToMetadataRequestTopic_0__172:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:void lambda$new$0(org.apache.kafka.common.message.MetadataRequestData,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest$Builder$lambda_new_0__144:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:void <init>(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartitionCollection:org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition find(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartitionCollection:java.util.List findAll(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:org.apache.kafka.common.requests.LeaveGroupRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.clients.admin.MemberToRemove:org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity toMemberIdentity()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$memberResult$1(org.apache.kafka.common.internals.KafkaFutureImpl,org.apache.kafka.clients.admin.MemberToRemove,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:void lambda$all$0(org.apache.kafka.common.internals.KafkaFutureImpl,java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31$toMemberIdentity__248:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:java.util.List members()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopicCollection:org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopicCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.HeartbeatResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult lambda$initializeTransactions$1()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$lambda_initializeTransactions_1__208:java.lang.Object get()"
        ]
    },
    "org.apache.kafka.common.message.InitProducerIdRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection:org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey find(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey apiVersion(short)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection:java.util.List findAll(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(int,short,java.util.List,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(int,short,java.util.List)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResultCollection:org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.Errors get(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResultCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$27:org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition lambda$null$0(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$27$lambda_null_0__257:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ApiVersionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:org.apache.kafka.common.requests.ApiVersionsRequest build(short)",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$19:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.RenewDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.RenewDelegationTokenRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment lambda$getErrorResponse$0(java.lang.Integer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$lambda_getErrorResponse_0__174:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResultCollection:org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResultCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.clients.ClientRequest:org.apache.kafka.common.requests.RequestHeader makeHeader(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long,org.apache.kafka.common.requests.AbstractRequest)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.RequestHeader nextRequestHeader(org.apache.kafka.common.protocol.ApiKeys,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void sendHandshakeRequest(org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)"
        ]
    },
    "org.apache.kafka.common.message.RequestHeaderData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.ApiKeys,short,java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.RequestHeader parse(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.common.message.HeartbeatRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$20:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.ExpireDelegationTokenRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken lambda$new$1(org.apache.kafka.common.security.token.delegation.DelegationToken)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse$lambda_new_1__109:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SyncGroupRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$27:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner lambda$new$0(org.apache.kafka.common.security.auth.KafkaPrincipal)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder$lambda_new_0__202:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse prepareResponse(int,java.util.Collection,java.lang.String,int,java.util.List,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse prepareResponse(int,java.util.Collection,java.lang.String,int,java.util.List)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse prepareResponse(int,org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.security.auth.KafkaPrincipal,long,long,long,java.lang.String,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse prepareResponse(int,org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.security.auth.KafkaPrincipal)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.requests.TxnOffsetCommitResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.requests.SaslHandshakeResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.EndTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopicCollection:org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopicCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopicCollection:org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Optional topicAuthorizedOperations(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopicCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup groupMetadata(java.lang.String,org.apache.kafka.common.protocol.Errors,java.lang.String,java.lang.String,java.lang.String,java.util.List,int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FindCoordinatorResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.requests.FindCoordinatorResponse prepareResponse(org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListGroupsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaveGroupResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic lambda$build$0(java.util.Map$Entry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder$lambda_build_0__201:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void lookupCoordinator(org.apache.kafka.common.requests.FindCoordinatorRequest$CoordinatorType,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void lookupCoordinator(org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void access$1600(org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.common.requests.FindCoordinatorRequest$CoordinatorType,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$22:org.apache.kafka.common.requests.FindCoordinatorRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.message.FindCoordinatorRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader lambda$build$0(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder$lambda_build_0__193:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$18:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$26:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.SaslHandshakeRequest createSaslHandshakeRequest(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void sendHandshakeRequest(org.apache.kafka.common.requests.ApiVersionsResponse)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.SaslHandshakeRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember groupMember(java.lang.String,java.lang.String,java.lang.String,java.lang.String,byte[],byte[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ControlledShutdownRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(int,org.apache.kafka.common.protocol.Errors)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.requests.DescribeDelegationTokenResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopicCollection:org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopicCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResultCollection:org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResultCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResultCollection:org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult find(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResultCollection:java.util.List findAll(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartitionCollection:org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition find(java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartitionCollection:java.util.List findAll(java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfigCollection:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig find(java.lang.String,byte)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfigCollection:java.util.List findAll(java.lang.String,byte)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfigCollection:org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfigCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.SaslAuthenticateRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.SaslAuthenticateRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState lambda$groupByTopic$1(org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder$lambda_groupByTopic_1__194:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirCollection:org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$5:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$4:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$17:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(java.util.List,boolean,short,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(java.util.List,boolean,short)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(java.util.List,boolean)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()",
            "org.apache.kafka.clients.producer.internals.ProducerMetadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.ConsumerMetadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getAllTopicMetadata(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:org.apache.kafka.common.requests.MetadataRequest$Builder allTopics()",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:void <clinit>()",
            "org.apache.kafka.common.requests.MetadataRequest$Builder$lambda_new_0__144:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer lambda$null$0(org.apache.kafka.common.security.auth.KafkaPrincipal)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse$lambda_null_0__112:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$2:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignmentCollection:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment find(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignmentCollection:java.util.List findAll(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.requests.ExpireDelegationTokenResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopicCollection:org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopicCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResultCollection:org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResultCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.EndTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.InitProducerIdResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ResponseHeaderData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ResponseHeader:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:void <init>(int,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.ResponseHeader toResponseHeader()"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:org.apache.kafka.common.requests.ResponseHeader parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0 lambda$build$1(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder$lambda_build_1__200:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBrokerCollection:org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker find(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBrokerCollection:java.util.List findAll(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfigCollection:org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfigCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState lambda$groupByTopic$1(org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder$lambda_groupByTopic_1__196:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection:org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocolCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic lambda$getTopics$0(java.util.Map$Entry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest$lambda_getTopics_0__175:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.requests.ControlledShutdownResponse prepareResponse(org.apache.kafka.common.protocol.Errors,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$23:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopicCollection:org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic find(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopicCollection:java.util.List findAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResourceCollection:org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource find(byte,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResourceCollection:java.util.List findAll(byte,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.SyncGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void read(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse lambda$getErrorResponse$0(org.apache.kafka.common.requests.ApiError,org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$lambda_getErrorResponse_0__173:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest$Builder:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.EndTxnRequest$Builder:org.apache.kafka.common.requests.EndTxnRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.EndTxnRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest$Builder:org.apache.kafka.common.requests.WriteTxnMarkersRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:org.apache.kafka.common.requests.DescribeConfigsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AlterConfigsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest$Builder:org.apache.kafka.common.requests.AlterConfigsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.CreatePartitionsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest$Builder:org.apache.kafka.common.requests.CreatePartitionsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreatePartitionsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.requests.WriteTxnMarkersResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.DeleteRecordsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest$Builder:org.apache.kafka.common.requests.DeleteRecordsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteRecordsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse$lambda_toStruct_0__128:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse$lambda_validate_1__132:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.requests.DescribeLogDirsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.requests.CreatePartitionsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest$Builder:org.apache.kafka.common.requests.AddPartitionsToTxnRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.requests.DeleteRecordsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest$Builder:org.apache.kafka.common.requests.DescribeLogDirsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeLogDirsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.requests.DeleteAclsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse$lambda_validate_2__119:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse$lambda_validate_0__122:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse$lambda_validate_1__126:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData memberData(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData deserializeTopicPartitionAssignment(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData memberData(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.lang.Short deserializeVersion(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV0(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV1(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignmentV0(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignmentV1(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignmentV1(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.record.EndTransactionMarker:void <init>(org.apache.kafka.common.record.ControlRecordType,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.record.EndTransactionMarker deserializeValue(org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.protocol.types.Struct buildRecordValue()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.EndTransactionMarker:java.nio.ByteBuffer serializeValue()"
        ]
    },
    "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.record.EndTransactionMarker deserialize(org.apache.kafka.common.record.Record)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.record.EndTransactionMarker deserializeValue(org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.record.EndTransactionMarker deserialize(org.apache.kafka.common.record.Record)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,long,int,long,short,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,short,org.apache.kafka.common.record.EndTransactionMarker)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,long,short,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.record.EndTransactionMarker:void ensureTransactionMarkerControlType(org.apache.kafka.common.record.ControlRecordType)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.EndTransactionMarker:void <init>(org.apache.kafka.common.record.ControlRecordType,int)",
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.record.EndTransactionMarker deserializeValue(org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.record.ControlRecordType[] values()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.protocol.types.Struct recordKey()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendControlRecord(long,org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.record.ControlRecordType:short parseTypeId(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.record.ControlRecordType parse(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.record.ControlRecordType fromTypeId(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.record.ControlRecordType parse(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.record.ControlRecordType parse(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.record.EndTransactionMarker deserialize(org.apache.kafka.common.record.Record)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.requests.AlterConfigsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.requests.CreateAclsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$Builder:org.apache.kafka.common.requests.CreateAclsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.CreateAclsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$lambda_validate_0__156:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.requests.AddPartitionsToTxnResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.requests.AlterReplicaLogDirsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:org.apache.kafka.common.requests.DeleteAclsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.DeleteAclsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest$lambda_validate_0__160:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$EndTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$FindCoordinatorHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$InitProducerIdHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$27:void lambda$null$3(java.util.Map,org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic,org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$27$lambda_null_3__256:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$32:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$32:void <clinit>()",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ConfigEntry$ConfigSource configSource(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigSource)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean lambda$hasCoordinatorMoved$0(org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext$lambda_hasCoordinatorMoved_0__235:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$6:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$6:void <clinit>()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean lambda$null$0(org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater$lambda_null_0__149:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void handleSaslHandshakeResponse(org.apache.kafka.common.requests.SaslHandshakeResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$1:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void handleSaslHandshakeResponse(org.apache.kafka.common.requests.SaslHandshakeResponse)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$1:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors[] values()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$32:void <clinit>()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$6:void <clinit>()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$1:void <clinit>()",
            "org.apache.kafka.common.protocol.Errors:java.lang.String toHtml()",
            "org.apache.kafka.common.protocol.Errors:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forCode(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:void lambda$null$3(java.util.Map,org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic,org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$28:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:java.util.Map responseData()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.Errors lambda$errorCounts$0(org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void lambda$errorCounts$0(java.util.Map,org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.SyncGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors topLevelError()",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors getError(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.Errors lambda$errorCounts$0(org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.ListGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.JoinGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.InitProducerIdResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.ApiVersionsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.Errors get(java.lang.String)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ElectLeadersResponse:java.util.Map electLeadersResult(org.apache.kafka.common.message.ElectLeadersResponseData)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.protocol.Errors error()",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forException(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiError:org.apache.kafka.common.requests.ApiError fromThrowable(java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map errorCounts(java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.protocol.Errors:java.lang.String toHtml()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Errors:void main(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.protocol.Errors:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:boolean hasError()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.requests.OffsetFetchResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <clinit>()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.Errors lambda$errorCounts$0(org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaResponse$lambda_errorCounts_0__133:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:boolean hasError()"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:boolean hasError()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.common.requests.HeartbeatResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:org.apache.kafka.common.requests.ApiError fromThrowable(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void addError(java.lang.Throwable,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:boolean isSuccess()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.ApiError:boolean isFailure()"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void addError(java.lang.Throwable,org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:int validateTopicResponses(java.util.List,java.util.Map)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse$AclDeletionResult:void <init>(org.apache.kafka.common.acl.AclBinding)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiError:org.apache.kafka.common.requests.ApiError fromThrowable(java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiError:void <clinit>()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:java.util.Map fromResponseData(org.apache.kafka.common.message.IncrementalAlterConfigsResponseData)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsResponse$AclFilterResponse:void <init>(java.util.Collection)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:boolean hasError()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:boolean hasError()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:void lambda$errorCounts$0(java.util.Map,org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsResponse$lambda_errorCounts_0__113:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse$PartitionData:boolean hasError()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.Errors topLevelError()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.EpochEndOffset:void <init>(int,long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.EpochEndOffset:boolean hasError()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:boolean hasError()"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:boolean hasError()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:boolean hasError()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$FindCoordinatorHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:boolean hasError()",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:java.util.Map errorCounts(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void handleSaslHandshakeResponse(org.apache.kafka.common.requests.SaslHandshakeResponse)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.Errors lambda$errorCounts$0(org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrResponse$lambda_errorCounts_0__127:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()",
            "org.apache.kafka.clients.producer.internals.TransactionManager$InitProducerIdHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:boolean hasError()"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenResponse:boolean hasError()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.Errors get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$26:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.protocol.Errors error()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveToken()"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.protocol.Errors$lambda_static_0__20:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:void commitTransaction()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:void abortTransaction()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveResponseOrToken()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveToken()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.AbstractResponse receiveKafkaResponse()"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:long receive(org.apache.kafka.common.network.NetworkReceive)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.network.NetworkReceive read()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleAuthenticationFailure()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void completeCloseOnAuthenticationFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void access$200(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements,org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void processPartitionMovement(org.apache.kafka.common.TopicPartition,java.lang.String,java.util.Map,java.util.TreeSet,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:int configureDeliveryTimeout(org.apache.kafka.clients.producer.ProducerConfig,org.slf4j.Logger)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:int configureRetries(org.apache.kafka.clients.producer.ProducerConfig,boolean,org.slf4j.Logger)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:int configureInflightRequests(org.apache.kafka.clients.producer.ProducerConfig,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)"
        ]
    },
    "org.apache.kafka.clients.GroupRebalanceConfig:void <init>(org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.clients.GroupRebalanceConfig$ProtocolType)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:int lingerMs(org.apache.kafka.clients.producer.ProducerConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.KafkaProducer:int configureDeliveryTimeout(org.apache.kafka.clients.producer.ProducerConfig,org.slf4j.Logger)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:short configureAcks(org.apache.kafka.clients.producer.ProducerConfig,boolean,org.slf4j.Logger)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.Sender newSender(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerMetadata)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.lang.String generateClientId(org.apache.kafka.clients.admin.AdminClientConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.Metadata:java.util.Optional lastSeenLeaderEpoch(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.Metadata$LeaderAndEpoch leaderAndEpoch(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpochIfNewer(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.Metadata:java.util.Optional partitionInfoIfCurrent(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.Metadata$LeaderAndEpoch leaderAndEpoch(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.Metadata:void lambda$handleMetadataResponse$3(java.util.Map,java.util.List,org.apache.kafka.clients.MetadataCache$PartitionInfoAndEpoch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata$lambda_handleMetadataResponse_3__139:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.ApiVersions:org.apache.kafka.clients.NodeApiVersions get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsAsync$5(java.util.Map,org.apache.kafka.common.Node,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:long nextOffset(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry getPartition(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:java.lang.Integer sequenceNumber(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void incrementSequenceNumber(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void addInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:int firstInFlightSequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.ProducerBatch nextBatchBySequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void removeInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void maybeUpdateLastAckedSequence(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void updateLastAckedOffset(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean hasInflightBatches(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void setNextSequence(org.apache.kafka.common.TopicPartition,int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:java.util.OptionalLong lastAckedOffset(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:java.util.OptionalLong lastAckedOffset(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:java.util.OptionalInt lastAckedSequence(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:java.util.OptionalInt lastAckedSequence(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:java.util.List inFlightBatches(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.Sender:void maybeRemoveFromInflightBatches(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void maybeRemoveAndDeallocateBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.Sender:void reenqueueBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerMetadata:boolean retainTopic(java.lang.String,boolean,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean lambda$update$2(long,org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.Metadata:boolean lambda$update$1(long,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean isMuted(org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List drainBatchesForOneNode(org.apache.kafka.common.Cluster,org.apache.kafka.common.Node,int,long)"
        ]
    },
    "org.apache.kafka.clients.admin.Config:org.apache.kafka.clients.admin.ConfigEntry get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AlterConfigOp$OpType:org.apache.kafka.clients.admin.AlterConfigOp$OpType forId(byte)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.lang.Throwable getSubLevelError(java.util.Map,java.lang.Object,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult:boolean maybeCompleteExceptionally(java.util.Map,org.apache.kafka.common.TopicPartition,org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult:boolean maybeCompleteExceptionally(java.util.Map,org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity,org.apache.kafka.common.internals.KafkaFutureImpl)"
        ]
    },
    "org.apache.kafka.clients.MetadataCache:java.util.Optional getPartitionInfoHavingEpoch(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:java.util.Optional partitionInfoIfCurrent(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.MetadataCache:java.util.Optional getPartitionInfo(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:java.util.Optional partitionInfoIfCurrent(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean canConnect(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean ready(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClient:boolean canConnect(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isBlackedOut(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.ClusterConnectionStates:long connectionDelay(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:long connectionDelay(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long pollDelayMs(java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnecting(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isPreparingConnection(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.Node leastLoadedNode(long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void connecting(java.lang.String,long,java.lang.String,org.apache.kafka.clients.ClientDnsLookup)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void throttle(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void maybeThrottle(org.apache.kafka.common.requests.AbstractResponse,short,java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:long throttleDelayMs(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:long throttleDelayMs(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long pollDelayMs(java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isReady(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean canSendRequest(java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnected(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClusterConnectionStates:long pollDelayMs(java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isDisconnected(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:boolean connectionFailed(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.common.errors.AuthenticationException authenticationException(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.errors.AuthenticationException authenticationException(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ClusterConnectionStates$NodeConnectionState nodeState(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClusterConnectionStates:java.net.InetAddress currentAddress(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void disconnected(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:void checkingApiVersions(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void ready(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void authenticationFailed(java.lang.String,long,org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ConnectionState connectionState(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:void add(org.apache.kafka.clients.NetworkClient$InFlightRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long,org.apache.kafka.common.requests.AbstractRequest)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:java.util.Deque requestQueue(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest completeNext(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest lastSent(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest completeLastSent(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:boolean canSendMore(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean canSendRequest(java.lang.String,long)",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:int count(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:int inFlightRequestCount(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.Node leastLoadedNode(long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:boolean isEmpty(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean hasInFlightRequests(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:java.lang.Iterable clearAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys,short,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.clients.ApiVersion)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.ApiVersion apiVersion(org.apache.kafka.common.protocol.ApiKeys)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:boolean hasUsableOffsetForLeaderEpochVersion(org.apache.kafka.clients.NodeApiVersions)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata lambda$committed$3(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer$lambda_committed_3__276:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair removeMovementRecordOfPartition(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void movePartition(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$SubscriptionComparator:int compare(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$SubscriptionComparator:int compare(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(org.apache.kafka.common.TopicPartition,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void processPartitionMovement(org.apache.kafka.common.TopicPartition,java.lang.String,java.util.Map,java.util.TreeSet,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void lambda$assign$1(java.util.Map,java.util.Map,java.lang.String,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$lambda_assign_1__298:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean lambda$assign$0(java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$lambda_assign_0__297:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.FetchSessionHandler sessionHandler(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onFailure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionComparator:int compare(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionComparator:int compare(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.List records(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean removeAttribute(org.apache.kafka.common.metrics.KafkaMetric,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter:void metricRemoval(org.apache.kafka.common.metrics.KafkaMetric)"
        ]
    },
    "org.apache.kafka.common.ConsumerGroupState:org.apache.kafka.common.ConsumerGroupState parse(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:java.nio.ByteBuffer get(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.KafkaLZ4BlockInputStream:void <init>(java.nio.ByteBuffer,org.apache.kafka.common.record.BufferSupplier,boolean)"
        ]
    },
    "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:void release(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.KafkaLZ4BlockInputStream:void close()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:int compare(org.apache.kafka.common.config.ConfigDef$ConfigKey,org.apache.kafka.common.config.ConfigDef$ConfigKey,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:int lambda$sortedConfigs$1(java.util.Map,org.apache.kafka.common.config.ConfigDef$ConfigKey,org.apache.kafka.common.config.ConfigDef$ConfigKey)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.ConfigDef$Type typeOf(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig$ResolvingMap:java.lang.Object get(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:java.util.Optional lastSeenLeaderEpoch(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:java.util.Optional partitionInfoIfCurrent(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.Metadata:void lambda$handleMetadataResponse$3(java.util.Map,java.util.List,org.apache.kafka.clients.MetadataCache$PartitionInfoAndEpoch)",
            "org.apache.kafka.clients.ApiVersions:org.apache.kafka.clients.NodeApiVersions get(java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:long nextOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry getPartition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:java.util.OptionalLong lastAckedOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:java.util.OptionalInt lastAckedSequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List inFlightBatches(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.Sender:void maybeRemoveFromInflightBatches(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.ProducerMetadata:boolean retainTopic(java.lang.String,boolean,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean isMuted(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.CommonClientConfigs:java.util.Map postProcessReconnectBackoffConfigs(org.apache.kafka.common.config.AbstractConfig,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:org.apache.kafka.clients.admin.ConfigEntry get(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture config(java.lang.String)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture numPartitions(java.lang.String)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture replicationFactor(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.AlterConfigOp$OpType:org.apache.kafka.clients.admin.AlterConfigOp$OpType forId(byte)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.lang.Throwable getSubLevelError(java.util.Map,java.lang.Object,java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.MetadataCache:java.util.Optional getPartitionInfoHavingEpoch(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.MetadataCache:java.util.Optional getPartitionInfo(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean canConnect(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isBlackedOut(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long connectionDelay(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnecting(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isPreparingConnection(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void connecting(java.lang.String,long,java.lang.String,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.ClusterConnectionStates:void throttle(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long throttleDelayMs(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isReady(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isDisconnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.common.errors.AuthenticationException authenticationException(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ClusterConnectionStates$NodeConnectionState nodeState(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:void add(org.apache.kafka.clients.NetworkClient$InFlightRequest)",
            "org.apache.kafka.clients.InFlightRequests:java.util.Deque requestQueue(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean canSendMore(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:int count(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Iterable clearAll(java.lang.String)",
            "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys,short,short)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.clients.ApiVersion)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.ApiVersion apiVersion(org.apache.kafka.common.protocol.ApiKeys)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resetOffsetPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata lambda$committed$3(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void lambda$onSuccess$1(java.util.Map,java.util.Map,org.apache.kafka.common.TopicPartition,org.apache.kafka.common.requests.EpochEndOffset)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair removeMovementRecordOfPartition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void addPartitionMovementRecord(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$SubscriptionComparator:int compare(java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(org.apache.kafka.common.TopicPartition,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void processPartitionMovement(org.apache.kafka.common.TopicPartition,java.lang.String,java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void lambda$assign$1(java.util.Map,java.util.Map,java.lang.String,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean lambda$assign$0(java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map fetchedRecords()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.FetchSessionHandler sessionHandler(int)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionComparator:int compare(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.List records(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean removeAttribute(org.apache.kafka.common.metrics.KafkaMetric,java.lang.String)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean addAttribute(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:java.lang.Object getAttribute(java.lang.String)",
            "org.apache.kafka.common.ConsumerGroupState:org.apache.kafka.common.ConsumerGroupState parse(java.lang.String)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:java.nio.ByteBuffer get(int)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:void release(java.nio.ByteBuffer)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:int compare(org.apache.kafka.common.config.ConfigDef$ConfigKey,org.apache.kafka.common.config.ConfigDef$ConfigKey,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object get(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.ConfigDef$Type typeOf(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig$ResolvingMap:java.lang.Object get(java.lang.Object)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:java.lang.String replace(java.util.Map,java.lang.String,java.util.regex.Pattern)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String owner(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String tokenIdForHmac(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation tokenForHmac(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation token(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:java.lang.String getServiceName(java.util.Map,java.lang.String,javax.security.auth.login.Configuration)",
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntry(java.util.Map,java.util.Map,java.lang.Object)",
            "org.apache.kafka.common.security.ssl.SslEngineBuilder:void <init>(java.util.Map)",
            "org.apache.kafka.common.security.auth.SecurityProtocol:org.apache.kafka.common.security.auth.SecurityProtocol forId(short)",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer$PlainSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)",
            "org.apache.kafka.common.security.plain.PlainLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerExtensionsValidatorCallback:void valid(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object rawClaim(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.String[] mechanismNamesCompatibleWithPolicy(java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadServerContext(org.apache.kafka.common.network.ListenerName,java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadClientContext(java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramExtensions:boolean tokenAuthenticated()",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramMechanism:org.apache.kafka.common.security.scram.internals.ScramMechanism forMechanismName(java.lang.String)",
            "org.apache.kafka.common.security.scram.ScramLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.RequestHeader nextRequestHeader(org.apache.kafka.common.protocol.ApiKeys,short)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void createSaslServer(java.lang.String)",
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.security.authenticator.LoginManager:java.lang.Class configuredClassOrDefault(java.util.Map,org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo:long calcCompletionTimesAndReturnSessionLifetimeMs()",
            "org.apache.kafka.common.serialization.StringDeserializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.UUIDSerializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.UUIDDeserializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.StringSerializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:void close(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void close(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.Selector$CloseMode)",
            "org.apache.kafka.common.network.Selector:boolean isChannelReady(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel openOrClosingChannelOrFail(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel channel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel closingChannel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void addToStagedReceives(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.NetworkReceive)",
            "org.apache.kafka.common.network.Selector:int numStagedReceives(org.apache.kafka.common.network.KafkaChannel)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.security.ssl.SslPrincipalMapper)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createClientCallbackHandler(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$1(java.lang.String,java.net.Socket,org.apache.kafka.common.security.authenticator.LoginManager,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.network.SslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.utils.LoggingSignalHandler$1:java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])",
            "org.apache.kafka.common.utils.SecurityUtils:void addConfiguredSecurityProviders(java.util.Map)",
            "org.apache.kafka.common.utils.SecurityUtils:org.apache.kafka.common.resource.ResourceType resourceType(java.lang.String)",
            "org.apache.kafka.common.utils.SecurityUtils:org.apache.kafka.common.acl.AclOperation operation(java.lang.String)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object get(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.NavigableMap read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.BoundField get(java.lang.String)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forCode(short)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forException(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AbstractResponse:void updateErrorCounts(java.util.Map,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:java.util.Collection configNames(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errors(long)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse$Config config(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:void <init>(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node nodeById(int)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node leaderFor(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.PartitionInfo partition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:java.lang.Integer partitionCountForTopic(java.lang.String)",
            "org.apache.kafka.common.resource.ResourceType:org.apache.kafka.common.resource.ResourceType fromCode(byte)",
            "org.apache.kafka.common.acl.AclPermissionType:org.apache.kafka.common.acl.AclPermissionType fromCode(byte)",
            "org.apache.kafka.common.acl.AclOperation:org.apache.kafka.common.acl.AclOperation fromCode(byte)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1$get__270:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.config.ConfigTransformer:java.lang.String replace(java.util.Map,java.lang.String,java.util.regex.Pattern)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String owner(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramServerCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String tokenIdForHmac(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation tokenForHmac(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation token(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramServerCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntry(java.util.Map,java.util.Map,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntries(java.util.Map,java.util.Map,java.util.Set)"
        ]
    },
    "org.apache.kafka.common.security.auth.SecurityProtocol:org.apache.kafka.common.security.auth.SecurityProtocol forId(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest:java.lang.String listenerNameFromSecurityProtocol(org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint)"
        ]
    },
    "org.apache.kafka.common.security.plain.internals.PlainSaslServer$PlainSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.OAuthBearerExtensionsValidatorCallback:void valid(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void lambda$handle$0(org.apache.kafka.common.security.oauthbearer.OAuthBearerExtensionsValidatorCallback,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String option(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String optionValue(java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String option(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String principalClaimName()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String scopeClaimName()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.util.List requiredScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:int allowableClockSkewMs()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object rawClaim(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:boolean isClaimType(java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object claim(java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateClaimForExistenceAndType(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,boolean,java.lang.String,java.lang.Class[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo:long calcCompletionTimesAndReturnSessionLifetimeMs()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.String[] mechanismNamesCompatibleWithPolicy(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient$OAuthBearerSaslClientFactory:java.lang.String[] getMechanismNames(java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer$OAuthBearerSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshConfig:void <init>(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadServerContext(org.apache.kafka.common.network.ListenerName,java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadClientContext(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramExtensions:boolean tokenAuthenticated()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo:long calcCompletionTimesAndReturnSessionLifetimeMs()"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMechanism:org.apache.kafka.common.security.scram.internals.ScramMechanism forMechanismName(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer$ScramSaslServerFactory:javax.security.sasl.SaslServer createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient$ScramSaslClientFactory:javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.LoginManager:java.lang.Class configuredClassOrDefault(java.util.Map,org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo:long calcCompletionTimesAndReturnSessionLifetimeMs()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo:long access$100(org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo)"
        ]
    },
    "org.apache.kafka.common.serialization.StringDeserializer:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.common.serialization.ExtendedDeserializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.serialization.UUIDSerializer:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.serialization.ExtendedSerializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.serialization.UUIDDeserializer:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.common.serialization.ExtendedDeserializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.serialization.StringSerializer:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.serialization.ExtendedSerializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.network.Selector:boolean isChannelReady(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean canSendRequest(java.lang.String,long)",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel openOrClosingChannelOrFail(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void send(org.apache.kafka.common.network.Send)",
            "org.apache.kafka.common.network.Selector:void mute(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void unmute(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel channel(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel lowestPriorityChannel()"
        ]
    },
    "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel closingChannel(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void addToStagedReceives(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.NetworkReceive)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void attemptRead(java.nio.channels.SelectionKey,org.apache.kafka.common.network.KafkaChannel)",
            "org.apache.kafka.common.network.Selector:void lambda$pollSelectionKeys$0(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.NetworkReceive)"
        ]
    },
    "org.apache.kafka.common.network.Selector:int numStagedReceives(org.apache.kafka.common.network.KafkaChannel)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void createClientCallbackHandler(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.utils.LoggingSignalHandler$1:java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.SecurityUtils:void addConfiguredSecurityProviders(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslEngineBuilder:void <init>(java.util.Map)",
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.utils.SecurityUtils:org.apache.kafka.common.resource.ResourceType resourceType(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.SecurityUtils:org.apache.kafka.common.acl.AclOperation operation(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object get(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:java.util.Optional lastSeenLeaderEpoch(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:java.util.Optional partitionInfoIfCurrent(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.Metadata:void lambda$handleMetadataResponse$3(java.util.Map,java.util.List,org.apache.kafka.clients.MetadataCache$PartitionInfoAndEpoch)",
            "org.apache.kafka.clients.ApiVersions:org.apache.kafka.clients.NodeApiVersions get(java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:long nextOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry getPartition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:java.util.OptionalLong lastAckedOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionBookkeeper:java.util.OptionalInt lastAckedSequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.StickyPartitionCache:int partition(java.lang.String,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.producer.internals.StickyPartitionCache:int nextPartition(java.lang.String,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.producer.internals.Sender:java.util.List inFlightBatches(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.Sender:void maybeRemoveFromInflightBatches(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.Sender:void addToInflightBatches(java.util.List)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.ProducerMetadata:boolean retainTopic(java.lang.String,boolean,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean isMuted(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getDeque(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getOrCreateDeque(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.CommonClientConfigs:java.util.Map postProcessReconnectBackoffConfigs(org.apache.kafka.common.config.AbstractConfig,java.util.Map)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.Config:org.apache.kafka.clients.admin.ConfigEntry get(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture config(java.lang.String)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture numPartitions(java.lang.String)",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture replicationFactor(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.AlterConfigOp$OpType:org.apache.kafka.clients.admin.AlterConfigOp$OpType forId(byte)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.common.message.IncrementalAlterConfigsRequestData toIncrementalAlterConfigsRequestData(java.util.Collection,java.util.Map,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.lang.Throwable getSubLevelError(java.util.Map,java.lang.Object,java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.ElectPreferredLeadersResult$1:void accept(java.util.Map,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.MetadataCache:java.util.Optional getPartitionInfoHavingEpoch(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.MetadataCache:java.util.Optional getPartitionInfo(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean canConnect(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isBlackedOut(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long connectionDelay(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnecting(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isPreparingConnection(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void connecting(java.lang.String,long,java.lang.String,org.apache.kafka.clients.ClientDnsLookup)",
            "org.apache.kafka.clients.ClusterConnectionStates:void throttle(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long throttleDelayMs(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isReady(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isDisconnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.common.errors.AuthenticationException authenticationException(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ClusterConnectionStates$NodeConnectionState nodeState(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:void add(org.apache.kafka.clients.NetworkClient$InFlightRequest)",
            "org.apache.kafka.clients.InFlightRequests:java.util.Deque requestQueue(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean canSendMore(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:int count(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Iterable clearAll(java.lang.String)",
            "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys,short,short)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.clients.ApiVersion)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.ApiVersion apiVersion(org.apache.kafka.common.protocol.ApiKeys)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resetOffsetPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata lambda$committed$3(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)",
            "org.apache.kafka.clients.consumer.CooperativeStickyAssignor:void adjustAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void lambda$onSuccess$1(java.util.Map,java.util.Map,org.apache.kafka.common.TopicPartition,org.apache.kafka.common.requests.EpochEndOffset)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair removeMovementRecordOfPartition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:void addPartitionMovementRecord(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$ConsumerPair)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$SubscriptionComparator:int compare(java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void put(org.apache.kafka.common.Node,org.apache.kafka.clients.ClientRequest)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Iterator requestIterator(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void validateCooperativeAssignment(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:java.util.List sortPartitions(java.util.Map,java.util.Set,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(org.apache.kafka.common.TopicPartition,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void balance(java.util.Map,java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void processPartitionMovement(org.apache.kafka.common.TopicPartition,java.lang.String,java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:void lambda$assign$1(java.util.Map,java.util.Map,java.lang.String,java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor:boolean lambda$assign$0(java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.FetchSessionHandler sessionHandler(int)",
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient$OffsetForEpochResult handleResponse(org.apache.kafka.common.Node,java.util.Map,org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse)",
            "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionComparator:int compare(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.List records(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean removeAttribute(org.apache.kafka.common.metrics.KafkaMetric,java.lang.String)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean addAttribute(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor getSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric metric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:java.lang.Object getAttribute(java.lang.String)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:java.nio.ByteBuffer get(int)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:void release(java.nio.ByteBuffer)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:float[] getAndCreateEstimationIfAbsent(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:int compare(org.apache.kafka.common.config.ConfigDef$ConfigKey,org.apache.kafka.common.config.ConfigDef$ConfigKey,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtml(java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object get(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.ConfigDef$Type typeOf(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map instantiateConfigProviders(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.AbstractConfig$ResolvingMap:java.lang.Object get(java.lang.Object)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:java.lang.String replace(java.util.Map,java.lang.String,java.util.regex.Pattern)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String owner(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String tokenIdForHmac(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation tokenForHmac(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation token(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:java.lang.String getServiceName(java.util.Map,java.lang.String,javax.security.auth.login.Configuration)",
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void copyMapEntry(java.util.Map,java.util.Map,java.lang.Object)",
            "org.apache.kafka.common.security.ssl.SslEngineBuilder:void <init>(java.util.Map)",
            "org.apache.kafka.common.security.auth.SecurityProtocol:org.apache.kafka.common.security.auth.SecurityProtocol forId(short)",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer$PlainSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)",
            "org.apache.kafka.common.security.plain.PlainLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerExtensionsValidatorCallback:void valid(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object rawClaim(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.String[] mechanismNamesCompatibleWithPolicy(java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadServerContext(org.apache.kafka.common.network.ListenerName,java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadClientContext(java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramExtensions:boolean tokenAuthenticated()",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramMechanism:org.apache.kafka.common.security.scram.internals.ScramMechanism forMechanismName(java.lang.String)",
            "org.apache.kafka.common.security.scram.ScramLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.RequestHeader nextRequestHeader(org.apache.kafka.common.protocol.ApiKeys,short)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer,java.util.Map,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void createSaslServer(java.lang.String)",
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.security.authenticator.LoginManager:java.lang.Class configuredClassOrDefault(java.util.Map,org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo:long calcCompletionTimesAndReturnSessionLifetimeMs()",
            "org.apache.kafka.common.serialization.StringDeserializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.UUIDSerializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.UUIDDeserializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.StringSerializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:void close(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void close(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.Selector$CloseMode)",
            "org.apache.kafka.common.network.Selector:boolean isChannelReady(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel openOrClosingChannelOrFail(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel channel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel closingChannel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void addToStagedReceives(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.NetworkReceive)",
            "org.apache.kafka.common.network.Selector:int numStagedReceives(org.apache.kafka.common.network.KafkaChannel)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.security.ssl.SslPrincipalMapper)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createClientCallbackHandler(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createConnectionsMaxReauthMsMap(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.Authenticator lambda$buildChannel$1(java.lang.String,java.net.Socket,org.apache.kafka.common.security.authenticator.LoginManager,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.network.SslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.utils.LoggingSignalHandler$1:java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])",
            "org.apache.kafka.common.utils.SecurityUtils:void addConfiguredSecurityProviders(java.util.Map)",
            "org.apache.kafka.common.utils.SecurityUtils:org.apache.kafka.common.resource.ResourceType resourceType(java.lang.String)",
            "org.apache.kafka.common.utils.SecurityUtils:org.apache.kafka.common.acl.AclOperation operation(java.lang.String)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object get(java.lang.Object)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:boolean remove(java.lang.Object,java.lang.Object)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:boolean replace(java.lang.Object,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:void write(java.nio.ByteBuffer,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.NavigableMap read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.TaggedFields:int sizeOf(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.Map validate(java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.BoundField get(java.lang.String)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forCode(short)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forException(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractResponse:void updateErrorCounts(java.util.Map,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:java.util.Collection configNames(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errors(long)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse$Config config(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:void <init>(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.Collection createTopicMetadata(org.apache.kafka.common.message.MetadataResponseData)",
            "org.apache.kafka.common.requests.MetadataResponse$Holder:java.util.List convertToNodes(java.util.List)",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node nodeById(int)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node leaderFor(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.PartitionInfo partition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:java.lang.Integer partitionCountForTopic(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1$get__270:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.protocol.types.TaggedFields:java.util.NavigableMap read(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.Object read(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.BoundField get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object get(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:boolean hasField(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:boolean hasField(org.apache.kafka.common.protocol.types.Field)",
            "org.apache.kafka.common.protocol.types.Struct:boolean hasField(org.apache.kafka.common.protocol.types.Field$ComplexArray)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct instance(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct instance(org.apache.kafka.common.protocol.types.Field)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct instance(org.apache.kafka.common.protocol.types.Field$ComplexArray)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:void updateErrorCounts(java.util.Map,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Collection)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void lambda$errorCounts$0(java.util.Map,org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup)",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.LeaveGroupResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:java.util.Collection configNames(org.apache.kafka.common.config.ConfigResource)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errors(long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse$Config config(org.apache.kafka.common.config.ConfigResource)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node nodeById(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.internals.AdminMetadataManager:org.apache.kafka.common.Node nodeById(int)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleServerDisconnect(long,java.lang.String,java.util.Optional)",
            "org.apache.kafka.common.Cluster:java.util.Optional nodeIfOnline(org.apache.kafka.common.TopicPartition,int)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node leaderFor(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.common.Node lambda$regroupPartitionMapByNode$10(java.util.Map$Entry)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.PartitionInfo partition(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.Cluster:java.util.Optional nodeIfOnline(org.apache.kafka.common.TopicPartition,int)"
        ]
    },
    "org.apache.kafka.common.Cluster:java.lang.Integer partitionCountForTopic(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.KafkaProducer$ClusterAndWaitTime waitOnMetadata(java.lang.String,java.lang.Integer,long)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupAssignment assign(org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$GroupSubscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,int)"
        ]
    },
    "org.apache.kafka.common.resource.ResourceType:org.apache.kafka.common.resource.ResourceType fromCode(byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.acl.AclPermissionType:org.apache.kafka.common.acl.AclPermissionType fromCode(byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.acl.AclOperation:org.apache.kafka.common.acl.AclOperation fromCode(byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$fromCode__229:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$17$1$get__270:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords:org.apache.kafka.common.record.RecordsSend toSend(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.DescribeAclsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest$Builder:org.apache.kafka.common.requests.DescribeAclsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeAclsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:org.apache.kafka.common.requests.CreateAclsRequest$AclCreation fromStruct(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:void setStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.DescribeAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.DeleteAclsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest$Builder:org.apache.kafka.common.requests.AddOffsetsToTxnRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.requests.AddOffsetsToTxnResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.requests.EndTxnResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Schema[] schemaVersions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void saslAuthenticateVersion(org.apache.kafka.common.requests.ApiVersionsResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.ApiKeys[] values()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()",
            "org.apache.kafka.common.protocol.ApiKeys:java.lang.String toHtml()",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractRequest$1:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractResponse$1:void <clinit>()",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:void <init>(java.lang.String,int,int,java.lang.String,boolean,byte,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <init>(java.lang.String,int,int,java.lang.String,boolean,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[])",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.ApiKeys forId(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientRequest:org.apache.kafka.common.requests.RequestHeader makeHeader(short)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.clients.ApiVersion)",
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.ApiKeys,short,java.lang.String,int)",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.protocol.ApiKeys apiKey()",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.RequestHeader parse(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:boolean hasId(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NodeApiVersions:void <init>(org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKeyCollection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.clients.ApiVersion)",
            "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.ApiKeys forId(int)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:java.lang.String toHtml()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void main(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListGroupsRequest$Builder:void <init>(org.apache.kafka.common.message.ListGroupsRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(java.util.Map,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest$Builder:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(int,java.util.Map,org.apache.kafka.common.requests.IsolationLevel,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(int,java.util.Map,org.apache.kafka.common.requests.IsolationLevel,short,org.apache.kafka.common.requests.ListOffsetRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:void <init>(short,java.lang.String,long,short,org.apache.kafka.common.requests.TransactionResult)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(short,java.lang.String,long,short,org.apache.kafka.common.requests.TransactionResult,org.apache.kafka.common.requests.EndTxnRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.message.ControlledShutdownRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.message.ControlledShutdownRequestData,short,org.apache.kafka.common.requests.ControlledShutdownRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(short,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(short,java.util.List,org.apache.kafka.common.requests.WriteTxnMarkersRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$Builder:void <init>(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$Builder:void <init>(org.apache.kafka.common.message.ListPartitionReassignmentsRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$30:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:void <init>(org.apache.kafka.common.acl.AclBindingFilter,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeAclsRequest$Builder:org.apache.kafka.common.requests.DescribeAclsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.message.MetadataRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest$Builder:org.apache.kafka.common.requests.MetadataRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest$Builder:void <init>(org.apache.kafka.common.message.OffsetCommitRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:void <init>(java.util.Collection)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest$Builder:void <init>(org.apache.kafka.common.message.SaslAuthenticateRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(short,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:org.apache.kafka.common.requests.DescribeConfigsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:void <init>(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatRequest$Builder:void <init>(org.apache.kafka.common.message.HeartbeatRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendHeartbeatRequest()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:void <init>(org.apache.kafka.common.message.DescribeGroupsRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.message.SaslAuthenticateRequestData)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.message.SaslAuthenticateRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslAuthenticateRequest$Builder:org.apache.kafka.common.requests.SaslAuthenticateRequest build(short)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.message.SaslAuthenticateRequestData)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.SaslAuthenticateRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.requests.ExpireDelegationTokenResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.message.ListPartitionReassignmentsRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.message.ListPartitionReassignmentsRequestData,short,org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest:void <init>(org.apache.kafka.common.message.ElectLeadersRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersRequest:void <init>(org.apache.kafka.common.message.ElectLeadersRequestData,short,org.apache.kafka.common.requests.ElectLeadersRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:void <init>(short,int,int,int,int,java.util.Map,org.apache.kafka.common.requests.IsolationLevel,java.util.List,org.apache.kafka.common.requests.FetchMetadata,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:void <init>(short,int,int,int,int,java.util.Map,org.apache.kafka.common.requests.IsolationLevel,java.util.List,org.apache.kafka.common.requests.FetchMetadata,java.lang.String,org.apache.kafka.common.requests.FetchRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:void <init>(short,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$Builder:org.apache.kafka.common.requests.CreateAclsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.CreateAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(short,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsRequest$Builder:org.apache.kafka.common.requests.AlterConfigsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AlterConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:void <init>(short,int,int,long,java.util.List,java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(java.util.Map,int,boolean,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreatePartitionsRequest$Builder:org.apache.kafka.common.requests.CreatePartitionsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.message.SyncGroupRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SyncGroupRequest$Builder:org.apache.kafka.common.requests.SyncGroupRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest:void <init>(org.apache.kafka.common.message.ApiVersionsRequestData,short,java.lang.Short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsRequest:void <init>(org.apache.kafka.common.message.ApiVersionsRequestData,short)",
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest:void <init>(org.apache.kafka.common.message.DeleteGroupsRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:org.apache.kafka.common.requests.DeleteGroupsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.message.OffsetFetchRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.message.OffsetFetchRequestData,short,org.apache.kafka.common.requests.OffsetFetchRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(int,java.util.Map,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteRecordsRequest$Builder:org.apache.kafka.common.requests.DeleteRecordsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.requests.DescribeDelegationTokenResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest$Builder:void <init>(org.apache.kafka.common.acl.AclBindingFilter)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$6:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest$1:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest$1:void <clinit>()",
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData,short,org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:void <init>(org.apache.kafka.common.message.DeleteTopicsRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:void <init>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:void <init>(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest$Builder:void <init>(java.lang.String,long,short,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler addPartitionsToTransactionHandler()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest$Builder:void <init>(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.message.LeaveGroupRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.message.LeaveGroupRequestData,short,org.apache.kafka.common.requests.LeaveGroupRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest$Builder:void <init>(short,int,int,long,boolean,java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest$Builder forConsumer(boolean,org.apache.kafka.common.requests.IsolationLevel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetRequest(org.apache.kafka.common.Node,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest$Builder:void <init>(short,short,int,org.apache.kafka.common.requests.IsolationLevel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest$Builder forReplica(short,int)",
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest$Builder forConsumer(boolean,org.apache.kafka.common.requests.IsolationLevel)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.message.DescribeGroupsRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.message.DescribeGroupsRequestData,short,org.apache.kafka.common.requests.DescribeGroupsRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest$Builder:void <init>(org.apache.kafka.common.message.CreateTopicsRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:void <init>(org.apache.kafka.common.message.DeleteGroupsRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$26:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse$1:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AbstractResponse$1:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest$Builder:void <init>(java.util.Map,int,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest$Builder:void <init>(org.apache.kafka.common.message.OffsetDeleteRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$27:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.message.HeartbeatRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.message.HeartbeatRequestData,short,org.apache.kafka.common.requests.HeartbeatRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.FetchRequest$Builder forConsumer(int,int,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest$Builder:void <init>(short,short,int,int,int,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.FetchRequest$Builder forConsumer(int,int,java.util.Map)",
            "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.FetchRequest$Builder forReplica(short,int,int,int,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest$Builder:void <init>(org.apache.kafka.common.message.CreateDelegationTokenRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.message.CreateDelegationTokenRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.message.CreateDelegationTokenRequestData,short,org.apache.kafka.common.requests.CreateDelegationTokenRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest:void <init>(org.apache.kafka.common.message.RenewDelegationTokenRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest$Builder:org.apache.kafka.common.requests.RenewDelegationTokenRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.RenewDelegationTokenRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest$Builder forMagic(byte,short,int,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest$Builder forCurrentMagic(short,int,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:void <init>(short,short,short,int,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest$Builder forMagic(byte,short,int,java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest$Builder:void <init>(org.apache.kafka.common.message.ExpireDelegationTokenRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.RequestContext:boolean isUnsupportedApiVersionsRequest()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)",
            "org.apache.kafka.common.requests.RequestContext:short apiVersion()"
        ]
    },
    "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.protocol.ApiKeys apiKey()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void cancelInFlightRequests(java.lang.String,long,java.util.Collection)",
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.requests.AbstractResponse parseResponse(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])",
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)",
            "org.apache.kafka.common.requests.RequestContext:boolean isUnsupportedApiVersionsRequest()",
            "org.apache.kafka.common.requests.RequestContext:int requestType()",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.ResponseHeader toResponseHeader()",
            "org.apache.kafka.common.requests.RequestHeader:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest$Builder:void <init>(org.apache.kafka.common.message.TxnOffsetCommitRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(java.util.Map,int,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(short,java.lang.String,long,short,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(short,java.lang.String,long,short,java.util.List,org.apache.kafka.common.requests.AddPartitionsToTxnRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.message.OffsetCommitRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitRequest$Builder:org.apache.kafka.common.requests.OffsetCommitRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.message.TxnOffsetCommitRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest$Builder:org.apache.kafka.common.requests.TxnOffsetCommitRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$Builder:void <init>(org.apache.kafka.common.message.IncrementalAlterConfigsRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest$Builder:void <init>(org.apache.kafka.common.message.SyncGroupRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinFollower()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest$Builder:void <init>(org.apache.kafka.common.message.RenewDelegationTokenRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(short,java.lang.String,long,short,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(short,java.lang.String,long,short,java.lang.String,org.apache.kafka.common.requests.AddOffsetsToTxnRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:void <init>(org.apache.kafka.common.message.DescribeDelegationTokenRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:org.apache.kafka.common.requests.DescribeDelegationTokenRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:void <init>(short,short,java.util.Map,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder forConsumer(java.util.Map)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder forFollower(short,java.util.Map,int)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder forConsumer(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.common.requests.AbstractRequest$Builder prepareRequest(org.apache.kafka.common.Node,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.message.CreateTopicsRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.message.CreateTopicsRequestData,short,org.apache.kafka.common.requests.CreateTopicsRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest$Builder:void <init>(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsRequest:void <init>(org.apache.kafka.common.message.ListGroupsRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListGroupsRequest$Builder:org.apache.kafka.common.requests.ListGroupsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.requests.SaslHandshakeResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(java.util.Set,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeLogDirsRequest$Builder:org.apache.kafka.common.requests.DescribeLogDirsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.message.DeleteTopicsRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.message.DeleteTopicsRequestData,short,org.apache.kafka.common.requests.DeleteTopicsRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest$Builder:void <init>(int,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest$Builder:void <init>(java.lang.String,long,short,org.apache.kafka.common.requests.TransactionResult)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult beginCompletingTransaction(org.apache.kafka.common.requests.TransactionResult)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.message.StopReplicaRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.message.StopReplicaRequestData,short,org.apache.kafka.common.requests.StopReplicaRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest$Builder:void <init>(org.apache.kafka.common.message.ControlledShutdownRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.message.ExpireDelegationTokenRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.message.ExpireDelegationTokenRequestData,short,org.apache.kafka.common.requests.ExpireDelegationTokenRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.ExpireDelegationTokenRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$Builder:void <init>(org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$29:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:void <init>(org.apache.kafka.common.message.IncrementalAlterConfigsRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:void <init>(org.apache.kafka.common.message.IncrementalAlterConfigsRequestData,short,org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest$Builder:void <init>(org.apache.kafka.common.message.InitProducerIdRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.clients.ClientResponse sendAndAwaitInitProducerIdRequest(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult lambda$initializeTransactions$1()"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.message.JoinGroupRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.JoinGroupRequest$Builder:org.apache.kafka.common.requests.JoinGroupRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest$Builder:void <init>(org.apache.kafka.common.message.JoinGroupRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.requests.RenewDelegationTokenResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:void <init>(java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:org.apache.kafka.common.requests.LeaveGroupRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture maybeLeaveGroup(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:void <init>(java.lang.String,java.util.List,short,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:void <init>(java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest$Builder:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:void <init>(org.apache.kafka.common.ElectionType,java.util.Collection,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$28:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.requests.TxnOffsetCommitResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.message.InitProducerIdRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.message.InitProducerIdRequestData,short,org.apache.kafka.common.requests.InitProducerIdRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:void <init>(short,int,int,long,java.util.List,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest$Builder:void <init>(org.apache.kafka.common.message.FindCoordinatorRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void lookupCoordinator(org.apache.kafka.common.requests.FindCoordinatorRequest$CoordinatorType,java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:org.apache.kafka.common.requests.FindCoordinatorRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendFindCoordinatorRequest(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.message.FindCoordinatorRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.message.FindCoordinatorRequestData,short,org.apache.kafka.common.requests.FindCoordinatorRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest$Builder:void <init>(org.apache.kafka.common.message.SaslHandshakeRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.SaslHandshakeRequest createSaslHandshakeRequest(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest:void <init>(org.apache.kafka.common.message.OffsetDeleteRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetDeleteRequest$Builder:org.apache.kafka.common.requests.OffsetDeleteRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest$Builder:void <init>(java.lang.String,long,short,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult sendOffsetsToTransaction(java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(org.apache.kafka.common.message.MetadataRequestData)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:org.apache.kafka.common.requests.MetadataRequest$Builder allTopics()"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(java.util.List,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerMetadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)",
            "org.apache.kafka.clients.consumer.internals.ConsumerMetadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersResponse:void <init>(int,short,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.message.SaslHandshakeRequestData)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.message.SaslHandshakeRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslHandshakeRequest$Builder:org.apache.kafka.common.requests.SaslHandshakeRequest build(short)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.message.SaslHandshakeRequestData)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.SaslHandshakeRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest$Builder:void <init>(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(short,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:org.apache.kafka.common.requests.DeleteAclsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.requests.SaslAuthenticateResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.message.ApiMessageType[] values()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ApiMessageType:org.apache.kafka.common.message.ApiMessageType fromApiKey(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:short requestHeaderVersion(short)",
            "org.apache.kafka.common.protocol.ApiKeys:short responseHeaderVersion(short)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:short requestHeaderVersion(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientRequest:org.apache.kafka.common.requests.RequestHeader makeHeader(short)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.RequestHeader nextRequestHeader(org.apache.kafka.common.protocol.ApiKeys,short)",
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.ApiKeys,short,java.lang.String,int)",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.RequestHeader parse(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:short responseHeaderVersion(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.ResponseHeader toResponseHeader()"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.MetadataRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.MetadataRequest$lambda_convertToMetadataRequestTopic_0__172:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder$lambda_new_0__144:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$21:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$31$toMemberIdentity__248:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.LeaveGroupRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$lambda_initializeTransactions_1__208:java.lang.Object get()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult handleCachedTransactionRequestResult(java.util.function.Supplier,org.apache.kafka.clients.producer.internals.TransactionManager$State)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void updatePreferredReadReplica(int,java.util.function.Supplier)",
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:java.lang.String toString()",
            "org.apache.kafka.common.network.KafkaChannel:void <init>(java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.function.Supplier,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginServerReauthentication(org.apache.kafka.common.network.NetworkReceive,java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginClientReauthentication(java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.utils.SystemTime:void waitObject(java.lang.Object,java.util.function.Supplier,long)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey apiVersion(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void sendHandshakeRequest(org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void saslAuthenticateVersion(org.apache.kafka.common.requests.ApiVersionsResponse)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$27$lambda_null_0__257:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:org.apache.kafka.common.requests.ApiVersionsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$lambda_getErrorResponse_0__174:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse$lambda_new_1__109:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.SyncGroupRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder$lambda_new_0__202:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse prepareResponse(int,java.util.Collection,java.lang.String,int,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse prepareResponse(java.util.Collection,java.lang.String,int,java.util.List)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse prepareResponse(int,org.apache.kafka.common.protocol.Errors,org.apache.kafka.common.security.auth.KafkaPrincipal)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.MetadataResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Optional topicAuthorizedOperations(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetFetchRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.ListGroupsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaveGroupResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.StopReplicaRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.StopReplicaRequest$Builder$lambda_build_0__201:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void lookupCoordinator(org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void lookupCoordinatorAndRetry(org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void access$1600(org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.common.requests.FindCoordinatorRequest$CoordinatorType,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$EndTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$InitProducerIdHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddOffsetsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$22:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder$lambda_build_0__193:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateTopicsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ElectLeadersRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(int,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetFetchResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder$lambda_groupByTopic_1__194:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:void <init>(java.util.List,boolean,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.Metadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.Metadata$MetadataRequestAndVersion newMetadataRequestAndVersion()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerMetadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.Metadata$MetadataRequestAndVersion newMetadataRequestAndVersion()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$3:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerMetadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.Metadata$MetadataRequestAndVersion newMetadataRequestAndVersion()"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:org.apache.kafka.common.requests.MetadataRequest$Builder allTopics()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.consumer.internals.ConsumerMetadata:org.apache.kafka.common.requests.MetadataRequest$Builder newMetadataRequestBuilder()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getAllTopicMetadata(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse$lambda_null_0__112:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.ListOffsetResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetCommitRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.JoinGroupResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.CreateAclsResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.FetchResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.ResponseHeader:int sizeOf()"
        ]
    },
    "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.ResponseHeader toResponseHeader()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.network.Send buildResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest$Builder$lambda_build_1__200:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetCommitResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder$lambda_groupByTopic_1__196:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest$lambda_getTopics_0__175:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.message.LeaderAndIsrResponseData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(org.apache.kafka.common.protocol.ApiKeys,short,int)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void <init>(org.apache.kafka.common.protocol.Readable,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void read(org.apache.kafka.common.protocol.Readable,short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$lambda_getErrorResponse_0__173:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$lambda_collectPartitions_6__285:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$lambda_fetchablePartitions_1__279:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,short,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,long,short,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$27$lambda_null_3__256:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ConfigEntry$ConfigSource configSource(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigSource)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ConfigEntry$ConfigSource access$2400(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigSource)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext$lambda_hasCoordinatorMoved_0__235:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater$lambda_null_0__149:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse$lambda_errorCounts_0__133:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:boolean isFailure()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse$AclDeletionResult:void <init>(org.apache.kafka.common.acl.AclBinding)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse$AclFilterResponse:void <init>(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse$lambda_errorCounts_0__113:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse$lambda_errorCounts_0__127:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConsumerGroupOperationContext:boolean hasCoordinatorMoved(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.network.NetworkReceive read()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void attemptRead(java.nio.channels.SelectionKey,org.apache.kafka.common.network.KafkaChannel)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:void completeCloseOnAuthenticationFailure()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void handleCloseOnAuthenticationFailure(org.apache.kafka.common.network.KafkaChannel)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor$RecordingLevel)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.Metadata$LeaderAndEpoch leaderAndEpoch(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seek(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seek(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetAndMetadata)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetIfNeeded(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetResetStrategy,org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetData)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$prepareFetchRequests$8(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$validateOffsetsIfNeeded$1(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpochIfNewer(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void lambda$updateLastSeenEpochIfNewer$2(org.apache.kafka.common.TopicPartition,java.lang.Integer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void lambda$refreshCommittedOffsetsIfNeeded$1(java.util.Map$Entry,java.lang.Integer)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$resetOffsetIfNeeded$4(org.apache.kafka.common.TopicPartition,java.lang.Integer)"
        ]
    },
    "org.apache.kafka.clients.Metadata$lambda_handleMetadataResponse_3__139:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:java.lang.Integer sequenceNumber(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void incrementSequenceNumber(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List drainBatchesForOneNode(org.apache.kafka.common.Cluster,org.apache.kafka.common.Node,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void incrementSequenceNumber(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List drainBatchesForOneNode(org.apache.kafka.common.Cluster,org.apache.kafka.common.Node,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void addInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List drainBatchesForOneNode(org.apache.kafka.common.Cluster,org.apache.kafka.common.Node,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:int firstInFlightSequence(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean shouldStopDrainBatchesForPartition(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.ProducerBatch nextBatchBySequence(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void insertInSequenceOrder(java.util.Deque,org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void removeInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void handleCompletedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void handleFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void maybeUpdateLastAckedSequence(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void handleCompletedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void updateLastAckedOffset(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void handleCompletedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:boolean hasInflightBatches(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:int firstInFlightSequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void removeInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void setNextSequence(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:java.util.OptionalLong lastAckedOffset(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void updateLastAckedOffset(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean canRetry(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:java.util.OptionalInt lastAckedSequence(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void maybeUpdateLastAckedSequence(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void handleCompletedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean isNextSequence(org.apache.kafka.common.TopicPartition,int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void maybeRemoveAndDeallocateBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)",
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.Metadata:boolean lambda$update$2(long,org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata$lambda_update_2__138:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.Metadata:boolean lambda$update$1(long,org.apache.kafka.common.requests.MetadataResponse$TopicMetadata)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata$lambda_update_1__137:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List drainBatchesForOneNode(org.apache.kafka.common.Cluster,org.apache.kafka.common.Node,int,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean canConnect(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.Node leastLoadedNode(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:long connectionDelay(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean isUnavailable(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:long pollDelayMs(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:long pollDelayMs(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.Node leastLoadedNode(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.Node awaitNodeReady(org.apache.kafka.common.requests.FindCoordinatorRequest$CoordinatorType)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$MetadataUpdateNodeIdProvider:org.apache.kafka.common.Node provide()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$LeastLoadedNodeProvider:org.apache.kafka.common.Node provide()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.common.Node leastLoadedNode()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void maybeThrottle(org.apache.kafka.common.requests.AbstractResponse,short,java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:long throttleDelayMs(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.NetworkClient:boolean canSendRequest(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean isReady(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.Node leastLoadedNode(long)",
            "org.apache.kafka.clients.NetworkClient:boolean access$400(org.apache.kafka.clients.NetworkClient,java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean connectionFailed(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean isUnavailable(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$connectionFailed__236:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.errors.AuthenticationException authenticationException(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void maybeThrowAuthFailure(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:java.net.InetAddress currentAddress(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void disconnected(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void checkingApiVersions(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleConnections()"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void ready(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void authenticationFailed(java.lang.String,long,org.apache.kafka.common.errors.AuthenticationException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ConnectionState connectionState(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest completeNext(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest lastSent(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest completeLastSent(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:int inFlightRequestCount(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean hasInFlightRequests(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer$lambda_committed_3__276:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$SubscriptionComparator:int compare(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$lambda_assign_1__298:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$lambda_assign_0__297:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$PartitionComparator:int compare(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.KafkaLZ4BlockInputStream:void <init>(java.nio.ByteBuffer,org.apache.kafka.common.record.BufferSupplier,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.CompressionType$4:java.io.InputStream wrapForInput(java.nio.ByteBuffer,byte,org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.record.KafkaLZ4BlockInputStream:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslEngineBuilder$SecurityStore:java.security.KeyStore load()",
            "org.apache.kafka.common.utils.AppInfoParser:void <clinit>()",
            "org.apache.kafka.common.utils.Utils:java.util.Properties loadProps(java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String,java.util.concurrent.atomic.AtomicReference)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:int lambda$sortedConfigs$1(java.util.Map,org.apache.kafka.common.config.ConfigDef$ConfigKey,org.apache.kafka.common.config.ConfigDef$ConfigKey)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$lambda_sortedConfigs_1__9:int compare(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramServerCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyToken()",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:void identifyExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:org.apache.kafka.common.security.auth.SaslExtensions retrieveCustomExtensions()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.util.Map processExtensions(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,org.apache.kafka.common.security.auth.SaslExtensions)",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:java.lang.String listenerNameFromSecurityProtocol(org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void normalize()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:java.lang.String access$000(org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void lambda$handle$0(org.apache.kafka.common.security.oauthbearer.OAuthBearerExtensionsValidatorCallback,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler$lambda_handle_0__17:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String optionValue(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleTokenCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String optionValue(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String principalClaimName()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String scopeClaimName()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.util.List requiredScope()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:int allowableClockSkewMs()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:boolean isClaimType(java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object claim(java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Number expirationTime()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Number issuedAt()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.String subject()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Long calculateStartTimeMs()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateClaimForExistenceAndType(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,boolean,java.lang.String,java.lang.Class[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient$OAuthBearerSaslClientFactory:java.lang.String[] getMechanismNames(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient$OAuthBearerSaslClientFactory:javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer$OAuthBearerSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer$OAuthBearerSaslServerFactory:javax.security.sasl.SaslServer createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslServer$ScramSaslServerFactory:javax.security.sasl.SaslServer createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslClient$ScramSaslClientFactory:javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo:long access$100(org.apache.kafka.common.security.authenticator.SaslServerAuthenticator$ReauthInfo)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.serialization.ExtendedDeserializer$Wrapper:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.common.serialization.ExtendedDeserializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.serialization.ExtendedSerializer$Wrapper:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.serialization.ExtendedSerializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void unmute(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void attemptRead(java.nio.channels.SelectionKey,org.apache.kafka.common.network.KafkaChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void lambda$pollSelectionKeys$0(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.NetworkReceive)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector$lambda_pollSelectionKeys_0__215:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.StickyPartitionCache:int partition(java.lang.String,org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.DefaultPartitioner:int partition(java.lang.String,java.lang.Object,byte[],java.lang.Object,byte[],org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.producer.UniformStickyPartitioner:int partition(java.lang.String,java.lang.Object,byte[],java.lang.Object,byte[],org.apache.kafka.common.Cluster)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.StickyPartitionCache:int nextPartition(java.lang.String,org.apache.kafka.common.Cluster,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.StickyPartitionCache:int partition(java.lang.String,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.producer.internals.DefaultPartitioner:void onNewBatch(java.lang.String,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.producer.UniformStickyPartitioner:void onNewBatch(java.lang.String,org.apache.kafka.common.Cluster,int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getDeque(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List drainBatchesForOneNode(org.apache.kafka.common.Cluster,org.apache.kafka.common.Node,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getOrCreateDeque(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long,boolean)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void reenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void put(org.apache.kafka.common.Node,org.apache.kafka.clients.ClientRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.clients.consumer.internals.RequestFuture send(org.apache.kafka.common.Node,org.apache.kafka.common.requests.AbstractRequest$Builder,int)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Iterator requestIterator(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor getSensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:org.apache.kafka.common.metrics.Sensor getSensor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesSent(java.lang.String,long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesReceived(java.lang.String,int)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric metric(org.apache.kafka.common.MetricName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void maybeUpdateAssignment(org.apache.kafka.clients.consumer.internals.SubscriptionState)"
        ]
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:float[] getAndCreateEstimationIfAbsent(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.CompressionRatioEstimator:float updateEstimation(java.lang.String,org.apache.kafka.common.record.CompressionType,float)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:float estimation(java.lang.String,org.apache.kafka.common.record.CompressionType)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:void resetEstimation(java.lang.String)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:void setEstimation(java.lang.String,org.apache.kafka.common.record.CompressionType,float)"
        ]
    },
    "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.StickyPartitionCache:int nextPartition(java.lang.String,org.apache.kafka.common.Cluster,int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getOrCreateDeque(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:float[] getAndCreateEstimationIfAbsent(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.utils.CopyOnWriteMap:boolean remove(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.utils.CopyOnWriteMap:boolean replace(java.lang.Object,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.StickyPartitionCache:int nextPartition(java.lang.String,org.apache.kafka.common.Cluster,int)"
        ]
    },
    "org.apache.kafka.common.protocol.types.TaggedFields:java.lang.Object read(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.NavigableMap read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Type$16:org.apache.kafka.common.record.MemoryRecords read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct read(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Object get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct getStruct(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:byte getByte(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.record.BaseRecords getRecords(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getShort(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getInt(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getUnsignedInt(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getLong(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.util.UUID getUUID(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getArray(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getString(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Boolean getBoolean(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.nio.ByteBuffer getBytes(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:byte[] getByteArray(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:boolean hasField(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData deserializeTopicPartitionAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getOrElse(org.apache.kafka.common.protocol.types.Field$Int64,long)",
            "org.apache.kafka.common.protocol.types.Struct:java.util.UUID getOrElse(org.apache.kafka.common.protocol.types.Field$UUID,java.util.UUID)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getOrElse(org.apache.kafka.common.protocol.types.Field$Int16,short)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte getOrElse(org.apache.kafka.common.protocol.types.Field$Int8,byte)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getOrElse(org.apache.kafka.common.protocol.types.Field$Int32,int)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:boolean getOrElse(org.apache.kafka.common.protocol.types.Field$Bool,boolean)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getOrEmpty(org.apache.kafka.common.protocol.types.Field$Array)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getOrEmpty(org.apache.kafka.common.protocol.types.Field$ComplexArray)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:boolean hasField(org.apache.kafka.common.protocol.types.Field)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:boolean hasField(org.apache.kafka.common.protocol.types.Field$ComplexArray)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscriptionV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV0(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignmentV1(org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:void <clinit>()",
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.protocol.types.Struct buildRecordValue()",
            "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.protocol.types.Struct recordKey()",
            "org.apache.kafka.common.message.ElectLeadersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.RequestHeaderData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.EndTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.EndTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ResponseHeaderData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int8,byte)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int32,int)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int64,long)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$UUID,java.util.UUID)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int16,short)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Bool,boolean)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Array,java.lang.Object[])",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$ComplexArray,java.lang.Object[])",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setByteArray(java.lang.String,byte[])",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(org.apache.kafka.common.protocol.types.Field$Array,java.lang.Object[])",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(org.apache.kafka.common.protocol.types.Field$ComplexArray,java.lang.Object[])",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(org.apache.kafka.common.protocol.types.Field,java.lang.Object)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct instance(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct instance(org.apache.kafka.common.protocol.types.Field)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct instance(org.apache.kafka.common.protocol.types.Field$ComplexArray)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.clients.admin.internals.AdminMetadataManager:org.apache.kafka.common.Node nodeById(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConstantNodeIdProvider:org.apache.kafka.common.Node provide()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleServerDisconnect(long,java.lang.String,java.util.Optional)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.common.Cluster:java.util.Optional nodeIfOnline(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Optional lambda$selectReadReplica$7(org.apache.kafka.common.TopicPartition,java.lang.Integer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.common.Node lambda$regroupPartitionMapByNode$10(java.util.Map$Entry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_regroupPartitionMapByNode_10__326:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$fromCode__229:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:void <init>(java.lang.String,int,int,java.lang.String,boolean,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <init>(java.lang.String,int,int,java.lang.String,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[])",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(int,java.util.Map,org.apache.kafka.common.requests.IsolationLevel,short,org.apache.kafka.common.requests.ListOffsetRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:void <init>(short,java.lang.String,long,short,org.apache.kafka.common.requests.TransactionResult,org.apache.kafka.common.requests.EndTxnRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.EndTxnRequest$Builder:org.apache.kafka.common.requests.EndTxnRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.message.ControlledShutdownRequestData,short,org.apache.kafka.common.requests.ControlledShutdownRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownRequest$Builder:org.apache.kafka.common.requests.ControlledShutdownRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(short,java.util.List,org.apache.kafka.common.requests.WriteTxnMarkersRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest$Builder:org.apache.kafka.common.requests.WriteTxnMarkersRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$7:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:org.apache.kafka.common.requests.MetadataRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$8:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest$Builder:org.apache.kafka.common.requests.SaslAuthenticateRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.message.ListPartitionReassignmentsRequestData,short,org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$Builder:org.apache.kafka.common.requests.ListPartitionReassignmentsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ElectLeadersRequest:void <init>(org.apache.kafka.common.message.ElectLeadersRequestData,short,org.apache.kafka.common.requests.ElectLeadersRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ElectLeadersRequest$Builder:org.apache.kafka.common.requests.ElectLeadersRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:void <init>(short,int,int,int,int,java.util.Map,org.apache.kafka.common.requests.IsolationLevel,java.util.List,org.apache.kafka.common.requests.FetchMetadata,java.lang.String,org.apache.kafka.common.requests.FetchRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.FetchRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest$Builder:org.apache.kafka.common.requests.SyncGroupRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SyncGroupRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest:void <init>(org.apache.kafka.common.message.ApiVersionsRequestData,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:org.apache.kafka.common.requests.ApiVersionsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:org.apache.kafka.common.requests.DeleteGroupsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.message.OffsetFetchRequestData,short,org.apache.kafka.common.requests.OffsetFetchRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:org.apache.kafka.common.requests.OffsetFetchRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$6:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:void <init>(org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData,short,org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$Builder:org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler addPartitionsToTransactionHandler()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult beginCompletingTransaction(org.apache.kafka.common.requests.TransactionResult)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler nextRequestHandler(boolean)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$14:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$15:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.message.LeaveGroupRequestData,short,org.apache.kafka.common.requests.LeaveGroupRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaveGroupRequest$Builder:org.apache.kafka.common.requests.LeaveGroupRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest$Builder forReplica(short,int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.message.DescribeGroupsRequestData,short,org.apache.kafka.common.requests.DescribeGroupsRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:org.apache.kafka.common.requests.DescribeGroupsRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$16:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.message.HeartbeatRequestData,short,org.apache.kafka.common.requests.HeartbeatRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.HeartbeatRequest$Builder:org.apache.kafka.common.requests.HeartbeatRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest$Builder:org.apache.kafka.common.requests.FetchRequest$Builder forReplica(short,int,int,int,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.message.CreateDelegationTokenRequestData,short,org.apache.kafka.common.requests.CreateDelegationTokenRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest$Builder:org.apache.kafka.common.requests.CreateDelegationTokenRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest$Builder:org.apache.kafka.common.requests.RenewDelegationTokenRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest$Builder forCurrentMagic(short,int,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.RequestContext:short apiVersion()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.network.Send buildResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.RequestContext:int requestType()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.RequestHeader:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.Map propsToMap(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,java.util.Map,boolean)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.protocol.MessageUtil:java.lang.String deepToString(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(short,java.lang.String,long,short,java.util.List,org.apache.kafka.common.requests.AddPartitionsToTxnRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest$Builder:org.apache.kafka.common.requests.AddPartitionsToTxnRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest$Builder:org.apache.kafka.common.requests.OffsetCommitRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest$Builder:org.apache.kafka.common.requests.TxnOffsetCommitRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(short,java.lang.String,long,short,java.lang.String,org.apache.kafka.common.requests.AddOffsetsToTxnRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest$Builder:org.apache.kafka.common.requests.AddOffsetsToTxnRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:org.apache.kafka.common.requests.DescribeDelegationTokenRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder forFollower(short,java.util.Map,int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.common.requests.AbstractRequest$Builder prepareRequest(org.apache.kafka.common.Node,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.common.requests.AbstractRequest$Builder prepareRequest(org.apache.kafka.common.Node,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.message.CreateTopicsRequestData,short,org.apache.kafka.common.requests.CreateTopicsRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateTopicsRequest$Builder:org.apache.kafka.common.requests.CreateTopicsRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$11:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsRequest$Builder:org.apache.kafka.common.requests.ListGroupsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListGroupsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.message.DeleteTopicsRequestData,short,org.apache.kafka.common.requests.DeleteTopicsRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:org.apache.kafka.common.requests.DeleteTopicsRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$17$1:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult beginCompletingTransaction(org.apache.kafka.common.requests.TransactionResult)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult lambda$beginAbort$3()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult lambda$beginCommit$2()"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.message.StopReplicaRequestData,short,org.apache.kafka.common.requests.StopReplicaRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder:org.apache.kafka.common.requests.StopReplicaRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.message.ExpireDelegationTokenRequestData,short,org.apache.kafka.common.requests.ExpireDelegationTokenRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest$Builder:org.apache.kafka.common.requests.ExpireDelegationTokenRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:void <init>(org.apache.kafka.common.message.IncrementalAlterConfigsRequestData,short,org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$Builder:org.apache.kafka.common.requests.IncrementalAlterConfigsRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest$Builder:org.apache.kafka.common.requests.JoinGroupRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.JoinGroupRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$31:org.apache.kafka.common.requests.LeaveGroupRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$31:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$13:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$28:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.message.InitProducerIdRequestData,short,org.apache.kafka.common.requests.InitProducerIdRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdRequest$Builder:org.apache.kafka.common.requests.InitProducerIdRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.message.FindCoordinatorRequestData,short,org.apache.kafka.common.requests.FindCoordinatorRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FindCoordinatorRequest$Builder:org.apache.kafka.common.requests.FindCoordinatorRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest$Builder:org.apache.kafka.common.requests.OffsetDeleteRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetDeleteRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult sendOffsetsToTransaction(java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest$Builder:org.apache.kafka.common.requests.SaslHandshakeRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.SaslHandshakeRequest createSaslHandshakeRequest(short)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse prepareResponse(java.util.Collection,java.lang.String,int,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.Sender:void lookupCoordinatorAndRetry(org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendAndPollTransactionalRequest()"
        ]
    },
    "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.Metadata$MetadataRequestAndVersion newMetadataRequestAndVersion()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$lambda_collectPartitions_6__285:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState$lambda_fetchablePartitions_1__279:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ConfigEntry$ConfigSource access$2400(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigSource)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:org.apache.kafka.clients.admin.ConfigEntry lambda$handleResponse$0(org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor$RecordingLevel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void lambda$updateLastSeenEpochIfNewer$2(org.apache.kafka.common.TopicPartition,java.lang.Integer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer$lambda_updateLastSeenEpochIfNewer_2__305:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void lambda$refreshCommittedOffsetsIfNeeded$1(java.util.Map$Entry,java.lang.Integer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$lambda_refreshCommittedOffsetsIfNeeded_1__310:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void lambda$resetOffsetIfNeeded$4(org.apache.kafka.common.TopicPartition,java.lang.Integer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_resetOffsetIfNeeded_4__318:void accept(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean shouldStopDrainBatchesForPartition(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List drainBatchesForOneNode(org.apache.kafka.common.Cluster,org.apache.kafka.common.Node,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void insertInSequenceOrder(java.util.Deque,org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void reenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void handleCompletedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:boolean isNextSequence(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean canRetry(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.Metadata$lambda_update_2__138:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.Metadata$lambda_update_1__137:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean isUnavailable(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.common.Node checkAndGetCoordinator()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:long pollDelayMs(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$MetadataUpdateNodeIdProvider:org.apache.kafka.common.Node provide()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$LeastLoadedNodeProvider:org.apache.kafka.common.Node provide()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.common.Node leastLoadedNode()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture lookupCoordinator()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean isReady(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean ready(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean isReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean access$400(org.apache.kafka.clients.NetworkClient,java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$connectionFailed__236:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void maybeThrowAuthFailure(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitPendingRequests(org.apache.kafka.common.Node,org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.common.record.CompressionType$4:java.io.InputStream wrapForInput(java.nio.ByteBuffer,byte,org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator compressedIterator(org.apache.kafka.common.record.BufferSupplier,boolean)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslEngineBuilder$SecurityStore:java.security.KeyStore load()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslEngineBuilder createNewSslEngineBuilder(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslEngineBuilder:javax.net.ssl.SSLContext createSSLContext()"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.KafkaProducer:void close(java.time.Duration,boolean)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void close(java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>(long)",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getVersion()",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getCommitId()",
            "org.apache.kafka.common.utils.AppInfoParser:java.lang.String getVersion()",
            "org.apache.kafka.common.utils.AppInfoParser:java.lang.String getCommitId()",
            "org.apache.kafka.common.utils.AppInfoParser:void registerAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics,long)",
            "org.apache.kafka.common.utils.AppInfoParser:void unregisterAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)",
            "org.apache.kafka.common.utils.AppInfoParser:void registerMetrics(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.AppInfoParser$AppInfo)",
            "org.apache.kafka.common.utils.AppInfoParser:void unregisterMetrics(org.apache.kafka.common.metrics.Metrics)",
            "org.apache.kafka.common.utils.AppInfoParser:org.slf4j.Logger access$000()",
            "org.apache.kafka.common.utils.AppInfoParser:void <clinit>()",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.util.Properties loadProps(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef$lambda_sortedConfigs_1__9:int compare(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:java.lang.String access$000(org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:boolean lambda$build$0(org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler$lambda_handle_0__17:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:void ensureValid(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String optionValue(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleTokenCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Number expirationTime()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateExpirationTime(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,long,int)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateTimeConsistency(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Number issuedAt()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateIssuedAt(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,boolean,long,int)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateTimeConsistency(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.String subject()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Long calculateStartTimeMs()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient$OAuthBearerSaslClientFactory:javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer$OAuthBearerSaslServerFactory:javax.security.sasl.SaslServer createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector$lambda_pollSelectionKeys_0__215:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.DefaultPartitioner:int partition(java.lang.String,java.lang.Object,byte[],java.lang.Object,byte[],org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.producer.KafkaProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,byte[],byte[],org.apache.kafka.common.Cluster)"
        ]
    },
    "org.apache.kafka.clients.producer.UniformStickyPartitioner:int partition(java.lang.String,java.lang.Object,byte[],java.lang.Object,byte[],org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.producer.KafkaProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,byte[],byte[],org.apache.kafka.common.Cluster)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.DefaultPartitioner:void onNewBatch(java.lang.String,org.apache.kafka.common.Cluster,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.UniformStickyPartitioner:void onNewBatch(java.lang.String,org.apache.kafka.common.Cluster,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void reenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void reenqueueBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.clients.consumer.internals.RequestFuture send(org.apache.kafka.common.Node,org.apache.kafka.common.requests.AbstractRequest$Builder,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.clients.consumer.internals.RequestFuture send(org.apache.kafka.common.Node,org.apache.kafka.common.requests.AbstractRequest$Builder)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:org.apache.kafka.common.metrics.Sensor getSensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordRetries(java.lang.String,int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordErrors(java.lang.String,int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordLatency(java.lang.String,long)"
        ]
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:float updateEstimation(java.lang.String,org.apache.kafka.common.record.CompressionType,float)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void close()"
        ]
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:float estimation(java.lang.String,org.apache.kafka.common.record.CompressionType)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecordsBuilder,long,boolean)"
        ]
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:void resetEstimation(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:void setEstimation(java.lang.String,org.apache.kafka.common.record.CompressionType,float)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object read(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.NavigableMap read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Type$16:org.apache.kafka.common.record.MemoryRecords read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct read(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object read(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.NavigableMap read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Type$16:org.apache.kafka.common.record.MemoryRecords read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct read(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Type$16:org.apache.kafka.common.record.MemoryRecords read(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Type$16:java.lang.Object read(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct read(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData deserializeTopicPartitionAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.lang.Short deserializeVersion(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV0(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV1(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignmentV0(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Schema:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.types.Struct parseRequest(short,java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.types.Struct parseResponse(short,java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.types.Struct parseResponse(short,java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.requests.CreateAclsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.requests.ExpireDelegationTokenResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.requests.ProduceResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.requests.DescribeDelegationTokenResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.requests.DescribeAclsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.requests.DescribeLogDirsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse:org.apache.kafka.common.requests.AlterPartitionReassignmentsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.requests.FindCoordinatorResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.requests.DeleteRecordsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse:org.apache.kafka.common.requests.IncrementalAlterConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.requests.AlterReplicaLogDirsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.requests.ListGroupsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.requests.CreateTopicsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.requests.DeleteAclsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsResponse:org.apache.kafka.common.requests.ListPartitionReassignmentsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.requests.RenewDelegationTokenResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ElectLeadersResponse:org.apache.kafka.common.requests.ElectLeadersResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct getStruct(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:byte getByte(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte get(org.apache.kafka.common.protocol.types.Field$Int8)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte getOrElse(org.apache.kafka.common.protocol.types.Field$Int8,byte)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.record.BaseRecords getRecords(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getShort(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.lang.Short deserializeVersion(java.nio.ByteBuffer)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData$ApiVersionsResponseKey:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Short get(org.apache.kafka.common.protocol.types.Field$Int16)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getOrElse(org.apache.kafka.common.protocol.types.Field$Int16,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getInt(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData deserializeTopicPartitionAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.EndTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ResponseHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer get(org.apache.kafka.common.protocol.types.Field$Int32)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getOrElse(org.apache.kafka.common.protocol.types.Field$Int32,int)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getUnsignedInt(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getLong(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long get(org.apache.kafka.common.protocol.types.Field$Int64)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getOrElse(org.apache.kafka.common.protocol.types.Field$Int64,long)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.util.UUID getUUID(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:java.util.UUID get(org.apache.kafka.common.protocol.types.Field$UUID)",
            "org.apache.kafka.common.protocol.types.Struct:java.util.UUID getOrElse(org.apache.kafka.common.protocol.types.Field$UUID,java.util.UUID)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getArray(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData deserializeTopicPartitionAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV0(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV1(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignmentV0(java.nio.ByteBuffer)",
            "org.apache.kafka.common.message.ElectLeadersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingPartitionReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableReplicaAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignablePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] get(org.apache.kafka.common.protocol.types.Field$Array)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] get(org.apache.kafka.common.protocol.types.Field$ComplexArray)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getOrEmpty(org.apache.kafka.common.protocol.types.Field$Array)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getOrEmpty(org.apache.kafka.common.protocol.types.Field$ComplexArray)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String getString(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor$MemberData deserializeTopicPartitionAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV1(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignmentV0(java.nio.ByteBuffer)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData$MetadataRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupRequestData$MemberIdentity:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$TopicProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.InitProducerIdRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteGroupsResponseData$DeletableGroupResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ApiVersionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsRequestData$ListPartitionReassignmentsTopics:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RequestHeaderData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.HeartbeatRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData$OngoingTopicReassignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData$OffsetFetchRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListGroupsResponseData$ListedGroup:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaveGroupResponseData$MemberResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$ReplicaElectionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FindCoordinatorRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrLiveLeader:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData$ReassignableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersResponseData$PartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ElectLeadersRequestData$TopicPartitions:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SaslHandshakeRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaResponseData$StopReplicaPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ControlledShutdownResponseData$RemainingPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchResponseData$OffsetFetchResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreateableTopicConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData$OffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData$CreatableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteTopicsResponseData$DeletableTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetFetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenRequestData$CreatableRenewers:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchableTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseBroker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitResponseData$OffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataTopicState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrResponseData$LeaderAndIsrPartitionError:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.OffsetCommitRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData$ReassignablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String get(org.apache.kafka.common.protocol.types.Field$Str)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String get(org.apache.kafka.common.protocol.types.Field$NullableStr)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Boolean getBoolean(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.EndTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataResponseData$MetadataResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.MetadataRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.IncrementalAlterConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreatePartitionsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.LeaderAndIsrRequestData$LeaderAndIsrPartitionState:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateTopicsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Boolean get(org.apache.kafka.common.protocol.types.Field$Bool)",
            "org.apache.kafka.common.protocol.types.Struct:boolean getOrElse(org.apache.kafka.common.protocol.types.Field$Bool,boolean)",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.nio.ByteBuffer getBytes(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV0(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Subscription deserializeSubscriptionV1(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.ConsumerPartitionAssignor$Assignment deserializeAssignmentV0(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:byte[] getByteArray(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getOrElse(org.apache.kafka.common.protocol.types.Field$Int64,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.util.UUID getOrElse(org.apache.kafka.common.protocol.types.Field$UUID,java.util.UUID)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getOrElse(org.apache.kafka.common.protocol.types.Field$Int16,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte getOrElse(org.apache.kafka.common.protocol.types.Field$Int8,byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getOrElse(org.apache.kafka.common.protocol.types.Field$Int32,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RequestUtils:java.util.Optional getLeaderEpoch(org.apache.kafka.common.protocol.types.Struct,org.apache.kafka.common.protocol.types.Field$Int32)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:boolean getOrElse(org.apache.kafka.common.protocol.types.Field$Bool,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getOrEmpty(org.apache.kafka.common.protocol.types.Field$Array)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getOrEmpty(org.apache.kafka.common.protocol.types.Field$ComplexArray)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternSetStructFields(org.apache.kafka.common.resource.ResourcePattern,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceSetStructFields(org.apache.kafka.common.acl.AccessControlEntry,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternFilterSetStructFields(org.apache.kafka.common.resource.ResourcePatternFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceFilterSetStructFields(org.apache.kafka.common.acl.AccessControlEntryFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int8,byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternSetStructFields(org.apache.kafka.common.resource.ResourcePattern,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternFilterSetStructFields(org.apache.kafka.common.resource.ResourcePatternFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceSetStructFields(org.apache.kafka.common.acl.AccessControlEntry,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceFilterSetStructFields(org.apache.kafka.common.acl.AccessControlEntryFilter,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int32,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int64,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$UUID,java.util.UUID)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int16,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ApiError:void write(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Bool,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Array,java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$ComplexArray,java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setByteArray(java.lang.String,byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupRequestData$SyncGroupRequestAssignment:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.CreateDelegationTokenResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.DescribeGroupsResponseData$DescribedGroupMember:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupResponseData$JoinGroupResponseMember:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.JoinGroupRequestData$JoinGroupRequestProtocol:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.message.SyncGroupResponseData:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(org.apache.kafka.common.protocol.types.Field$Array,java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(org.apache.kafka.common.protocol.types.Field$ComplexArray,java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(org.apache.kafka.common.protocol.types.Field,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternSetStructFields(org.apache.kafka.common.resource.ResourcePattern,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternFilterSetStructFields(org.apache.kafka.common.resource.ResourcePatternFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void setLeaderEpochIfExists(org.apache.kafka.common.protocol.types.Struct,org.apache.kafka.common.protocol.types.Field$Int32,java.util.Optional)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ApiError:void write(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ConstantNodeIdProvider:org.apache.kafka.common.Node provide()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Optional lambda$selectReadReplica$7(org.apache.kafka.common.TopicPartition,java.lang.Integer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_selectReadReplica_7__321:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_regroupPartitionMapByNode_10__326:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:void <init>(java.lang.String,int,int,java.lang.String,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <init>(java.lang.String,int,int,java.lang.String,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.ApiKeys$1)",
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest$Builder:org.apache.kafka.common.requests.ControlledShutdownRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ControlledShutdownRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$Builder:org.apache.kafka.common.requests.ListPartitionReassignmentsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:org.apache.kafka.common.requests.OffsetFetchRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$Builder:org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler nextRequestHandler(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendAndPollTransactionalRequest()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:org.apache.kafka.common.requests.DescribeGroupsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatRequest$Builder:org.apache.kafka.common.requests.HeartbeatRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.HeartbeatRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest$Builder:org.apache.kafka.common.requests.CreateDelegationTokenRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochClient:org.apache.kafka.common.requests.AbstractRequest$Builder prepareRequest(org.apache.kafka.common.Node,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AsyncClient:org.apache.kafka.clients.consumer.internals.RequestFuture sendAsyncRequest(org.apache.kafka.common.Node,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest$Builder:org.apache.kafka.common.requests.CreateTopicsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateTopicsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:org.apache.kafka.common.requests.DeleteTopicsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult lambda$beginAbort$3()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$lambda_beginAbort_3__210:java.lang.Object get()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult lambda$beginCommit$2()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$lambda_beginCommit_2__209:java.lang.Object get()"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest$Builder:org.apache.kafka.common.requests.ExpireDelegationTokenRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$Builder:org.apache.kafka.common.requests.IncrementalAlterConfigsRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$31:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest$Builder:org.apache.kafka.common.requests.InitProducerIdRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest$Builder:org.apache.kafka.common.requests.FindCoordinatorRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FindCoordinatorRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetDeleteRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$1:org.apache.kafka.clients.admin.ConfigEntry lambda$handleResponse$0(org.apache.kafka.common.message.CreateTopicsResponseData$CreatableTopicConfigs)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1$lambda_handleResponse_0__266:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.BufferPool:void <init>(long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void registerMetrics(org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.producer.internals.ProducerMetadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.producer.internals.ProducerInterceptors,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.KafkaConsumerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector$SelectorMetrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer$lambda_updateLastSeenEpochIfNewer_2__305:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$lambda_refreshCommittedOffsetsIfNeeded_1__310:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_resetOffsetIfNeeded_4__318:void accept(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void updatePartitionInfo(java.lang.String,org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata,boolean,java.util.function.Consumer)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TopicPartitionEntry:void resetSequenceNumbers(java.util.function.Consumer)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.common.Node checkAndGetCoordinator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean coordinatorUnknown()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(org.apache.kafka.common.utils.Timer)"
        ]
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator compressedIterator(org.apache.kafka.common.record.BufferSupplier,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator skipKeyValueIterator(org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslEngineBuilder:javax.net.ssl.SSLContext createSSLContext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslEngineBuilder:void <init>(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser:void registerAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics,long)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getVersion()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser:void registerMetrics(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.AppInfoParser$AppInfo)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getCommitId()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser:void registerMetrics(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.AppInfoParser$AppInfo)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:java.lang.String getVersion()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>(long)",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getVersion()",
            "org.apache.kafka.common.requests.ApiVersionsRequest$Builder:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:java.lang.String getCommitId()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>(long)",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getCommitId()"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:org.slf4j.Logger access$000()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>(long)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:boolean lambda$build$0(org.apache.kafka.common.message.UpdateMetadataRequestData$UpdateMetadataEndpoint)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder$lambda_build_0__195:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateExpirationTime(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,long,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateTimeConsistency(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateIssuedAt(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,boolean,long,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,byte[],byte[],org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.clients.consumer.internals.RequestFuture send(org.apache.kafka.common.Node,org.apache.kafka.common.requests.AbstractRequest$Builder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendFindCoordinatorRequest(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture maybeLeaveGroup(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendHeartbeatRequest()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetRequest(org.apache.kafka.common.Node,java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.AsyncClient:org.apache.kafka.clients.consumer.internals.RequestFuture sendAsyncRequest(org.apache.kafka.common.Node,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List drainBatchesForOneNode(org.apache.kafka.common.Cluster,org.apache.kafka.common.Node,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecordsBuilder,long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecordsBuilder,long)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:org.apache.kafka.clients.producer.internals.ProducerBatch createBatchOffAccumulatorForRecord(org.apache.kafka.common.record.Record,int)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Type$16:java.lang.Object read(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.NavigableMap read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Type$16:org.apache.kafka.common.record.MemoryRecords read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct read(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Schema:java.lang.Object read(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.ArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.TaggedFields:java.util.NavigableMap read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.CompactArrayOf:java.lang.Object read(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.Struct read(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.types.Struct parseRequest(short,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.ListOffsetRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.DescribeAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.MetadataRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.SaslAuthenticateRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest:org.apache.kafka.common.requests.ListPartitionReassignmentsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ElectLeadersRequest:org.apache.kafka.common.requests.ElectLeadersRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.FetchRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.CreateAclsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AlterConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.CreatePartitionsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.SyncGroupRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.DeleteGroupsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.DeleteRecordsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest:org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.LeaveGroupRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.DescribeGroupsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.HeartbeatRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.CreateDelegationTokenRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.RenewDelegationTokenRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.CreateTopicsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.DescribeLogDirsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.DeleteTopicsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.ExpireDelegationTokenRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest:org.apache.kafka.common.requests.IncrementalAlterConfigsRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.JoinGroupRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.InitProducerIdRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.FindCoordinatorRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetDeleteRequest:org.apache.kafka.common.requests.OffsetDeleteRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.SaslHandshakeRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.DeleteAclsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.types.Struct parseResponse(short,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.requests.AlterConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.requests.OffsetFetchResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.requests.StopReplicaResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.requests.HeartbeatResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.requests.WriteTxnMarkersResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.requests.ListOffsetResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.requests.ControlledShutdownResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:org.apache.kafka.common.requests.OffsetDeleteResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.requests.SyncGroupResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.requests.AddPartitionsToTxnResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.requests.CreatePartitionsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.requests.LeaveGroupResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.requests.DeleteTopicsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.requests.SaslHandshakeResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.requests.LeaderAndIsrResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.requests.UpdateMetadataResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.requests.AddOffsetsToTxnResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.requests.JoinGroupResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.requests.InitProducerIdResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.requests.OffsetCommitResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.requests.TxnOffsetCommitResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.requests.DeleteGroupsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.requests.SaslAuthenticateResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.requests.EndTxnResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:org.apache.kafka.common.protocol.types.Struct parseResponse(short,java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys$1:org.apache.kafka.common.protocol.types.Struct parseResponse(short,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte get(org.apache.kafka.common.protocol.types.Field$Int8)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslAuthenticateResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SaslAuthenticateResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.RenewDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.RenewDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SaslHandshakeResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.EndTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.EndTxnRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.EndTxnResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.EndTxnResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Short get(org.apache.kafka.common.protocol.types.Field$Int16)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchPartition:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$FetchPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer get(org.apache.kafka.common.protocol.types.Field$Int32)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.RenewDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.RenewDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Long get(org.apache.kafka.common.protocol.types.Field$Int64)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.util.UUID get(org.apache.kafka.common.protocol.types.Field$UUID)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] get(org.apache.kafka.common.protocol.types.Field$Array)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] get(org.apache.kafka.common.protocol.types.Field$ComplexArray)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SaslHandshakeRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String get(org.apache.kafka.common.protocol.types.Field$Str)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String get(org.apache.kafka.common.protocol.types.Field$NullableStr)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Boolean get(org.apache.kafka.common.protocol.types.Field$Bool)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.SaslAuthenticateRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.SaslAuthenticateRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:java.util.Optional getLeaderEpoch(org.apache.kafka.common.protocol.types.Struct,org.apache.kafka.common.protocol.types.Field$Int32)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:void setLeaderEpochIfExists(org.apache.kafka.common.protocol.types.Struct,org.apache.kafka.common.protocol.types.Field$Int32,java.util.Optional)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$lambda_selectReadReplica_7__321:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys:void <init>(java.lang.String,int,int,java.lang.String,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.ApiKeys$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys$1:void <init>(java.lang.String,int,int,java.lang.String,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[])"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.ListPartitionReassignmentsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.AlterPartitionReassignmentsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$lambda_beginAbort_3__210:java.lang.Object get()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult handleCachedTransactionRequestResult(java.util.function.Supplier,org.apache.kafka.clients.producer.internals.TransactionManager$State)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void updatePreferredReadReplica(int,java.util.function.Supplier)",
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:java.lang.String toString()",
            "org.apache.kafka.common.network.KafkaChannel:void <init>(java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.function.Supplier,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginServerReauthentication(org.apache.kafka.common.network.NetworkReceive,java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginClientReauthentication(java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.utils.SystemTime:void waitObject(java.lang.Object,java.util.function.Supplier,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$lambda_beginCommit_2__209:java.lang.Object get()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionalRequestResult handleCachedTransactionRequestResult(java.util.function.Supplier,org.apache.kafka.clients.producer.internals.TransactionManager$State)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState$TopicPartitionState:void updatePreferredReadReplica(int,java.util.function.Supplier)",
            "org.apache.kafka.common.config.ConfigDef$LambdaValidator:java.lang.String toString()",
            "org.apache.kafka.common.network.KafkaChannel:void <init>(java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.function.Supplier,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginServerReauthentication(org.apache.kafka.common.network.NetworkReceive,java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:boolean maybeBeginClientReauthentication(java.util.function.Supplier)",
            "org.apache.kafka.common.network.KafkaChannel:void swapAuthenticatorsAndBeginReauthentication(org.apache.kafka.common.network.ReauthenticationContext)",
            "org.apache.kafka.common.utils.SystemTime:void waitObject(java.lang.Object,java.util.function.Supplier,long)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.IncrementalAlterConfigsRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$1$lambda_handleResponse_0__266:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.MappedIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.FlattenedIterator:java.lang.Object makeNext()",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$1(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.utils.Utils:java.lang.Object lambda$transformMap$0(java.util.function.Function,java.util.Map$Entry)",
            "org.apache.kafka.common.protocol.Errors:void <init>(java.lang.String,int,int,java.lang.String,java.util.function.Function)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.errors.ApiException exception(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean coordinatorUnknown()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(org.apache.kafka.common.utils.Timer)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture maybeLeaveGroup(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()"
        ]
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator skipKeyValueIterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder$lambda_build_0__195:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:boolean updateLastSeenEpoch(org.apache.kafka.common.TopicPartition,int,java.util.function.Predicate,boolean)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.clients.MetadataCache handleMetadataResponse(org.apache.kafka.common.requests.MetadataResponse,java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$collectPartitions$6(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean lambda$fetchablePartitions$1(java.util.function.Predicate,org.apache.kafka.common.internals.PartitionStates$PartitionState)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecordsBuilder,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:org.apache.kafka.clients.producer.internals.ProducerBatch createBatchOffAccumulatorForRecord(org.apache.kafka.common.record.Record,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys$1:org.apache.kafka.common.protocol.types.Struct parseResponse(short,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.requests.AlterConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.requests.OffsetFetchResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.requests.StopReplicaResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.requests.HeartbeatResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.requests.WriteTxnMarkersResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.requests.ListOffsetResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.requests.ControlledShutdownResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetDeleteResponse:org.apache.kafka.common.requests.OffsetDeleteResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.requests.SyncGroupResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.requests.AddPartitionsToTxnResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.requests.CreatePartitionsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.requests.LeaveGroupResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.requests.DeleteTopicsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.requests.SaslHandshakeResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.requests.LeaderAndIsrResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.requests.UpdateMetadataResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.requests.AddOffsetsToTxnResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.requests.JoinGroupResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.requests.InitProducerIdResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.requests.OffsetCommitResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.requests.TxnOffsetCommitResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.requests.DeleteGroupsResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.requests.SaslAuthenticateResponse parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.requests.EndTxnResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsResponseData$AlterConfigsResourceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsSynonym:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsResponseData$DescribeConfigsResourceResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsMatchingAcl:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsResponseData$DeleteAclsFilterResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsRequestData$CreatableAcl:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeAclsResponseData$AclDescription:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeAclsResponseData$DescribeAclsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeConfigsRequestData$DescribeConfigsResource:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeConfigsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteAclsRequestData$DeleteAclsFilter:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteAclsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetPartitionResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetResponseData$ListOffsetTopicResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslAuthenticateResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.RenewDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteResponseData$OffsetDeleteResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsResponseData$CreatePartitionsTopicResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslHandshakeResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.EndTxnRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochResponseData$OffsetForLeaderTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddOffsetsToTxnResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnResponseData$AddPartitionsToTxnTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponsePartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitResponseData$TxnOffsetCommitResponseTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsResponseData$DeleteRecordsTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.EndTxnResponseData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersResponseData$WritableTxnMarkerTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreateAclsResponseData$CreatableAclResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreateAclsResponseData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirPartitionResult:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsResponseData$AlterReplicaLogDirTopicResult:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetForLeaderEpochRequestData$OffsetForLeaderTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.OffsetDeleteRequestData$OffsetDeleteRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceResponseData$BatchIndexAndErrorMessage:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceResponseData$PartitionProduceResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.TxnOffsetCommitRequestData$TxnOffsetCommitRequestTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ProduceRequestData$PartitionProduceData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ProduceRequestData$TopicProduceData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DeleteRecordsRequestData$DeleteRecordsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsResponseData$DescribeLogDirsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.StopReplicaRequestData$StopReplicaPartitionV0:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.StopReplicaRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.ListOffsetRequestData$ListOffsetTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$FetchPartition:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData$FetchableTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchResponseData$AbortedTransaction:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchResponseData$FetchablePartitionResponse:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.RenewDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.ExpireDelegationTokenRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarkerTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.WriteTxnMarkersRequestData$WritableTxnMarker:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.FetchRequestData$ForgottenTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.FetchRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeLogDirsRequestData$DescribableLogDirTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeLogDirsRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDirTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterReplicaLogDirsRequestData$AlterReplicaLogDir:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsAssignment:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.CreatePartitionsRequestData$CreatePartitionsTopic:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AddPartitionsToTxnRequestData$AddPartitionsToTxnTopic:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AddPartitionsToTxnRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenRequestData$DescribeDelegationTokenOwner:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenRequestData:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslHandshakeRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationTokenRenewer:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.DescribeDelegationTokenResponseData$DescribedDelegationToken:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.AlterConfigsRequestData$AlterableConfig:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.message.AlterConfigsRequestData$AlterConfigsResource:void fromStruct(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.message.SaslAuthenticateRequestData:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.ApiKeys$1:void <init>(java.lang.String,int,int,java.lang.String,org.apache.kafka.common.protocol.types.Schema[],org.apache.kafka.common.protocol.types.Schema[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.ApiKeys:void <clinit>()"
        ]
    }
}