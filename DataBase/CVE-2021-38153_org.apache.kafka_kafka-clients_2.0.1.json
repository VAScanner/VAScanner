{
    "org.apache.kafka.common.security.plain.internals.PlainServerCallbackHandler:boolean authenticate(java.lang.String,char[])": {
        "isVulRoot": true,
        "vulCaller": [
            "org.apache.kafka.common.security.plain.internals.PlainServerCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.plain.internals.PlainServerCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$2:byte[] run()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$2:byte[] run()"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$2:byte[] run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$2:java.lang.Object run()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] evaluateResponse(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$2:java.lang.Object run()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void prepare()"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:void prepare()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void poll(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean isReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()",
            "org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void pollNoWakeup()"
        ]
    },
    "org.apache.kafka.clients.NetworkClientUtils:boolean isReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendTransactionalRequest(long)",
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.Node awaitLeastLoadedNodeReady(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.clients.ClientResponse sendAndAwaitInitProducerIdRequest(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void run(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)"
        ]
    },
    "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslTransportLayer:void doHandshake()",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult handshakeWrap(boolean)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult handshakeUnwrap(boolean)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine:void validate(org.apache.kafka.common.security.ssl.SslFactory,javax.net.ssl.SSLContext,javax.net.ssl.SSLContext)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean poll(org.apache.kafka.clients.consumer.internals.RequestFuture,long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollForFetches(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void pollNoWakeup()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void maybeLeaveGroup()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$2:void onSuccess(java.lang.Void)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendTransactionalRequest(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.Node awaitLeastLoadedNodeReady(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendTransactionalRequest(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.clients.ClientResponse sendAndAwaitInitProducerIdRequest(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()",
            "org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SslTransportLayer:void doHandshake()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslTransportLayer:void handshake()"
        ]
    },
    "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult handshakeWrap(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslTransportLayer:void doHandshake()"
        ]
    },
    "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult handshakeUnwrap(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslTransportLayer:void handshake()",
            "org.apache.kafka.common.network.SslTransportLayer:void doHandshake()"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine:void validate(org.apache.kafka.common.security.ssl.SslFactory,javax.net.ssl.SSLContext,javax.net.ssl.SSLContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:javax.net.ssl.SSLContext createSSLContext(org.apache.kafka.common.security.ssl.SslFactory$SecurityStore,org.apache.kafka.common.security.ssl.SslFactory$SecurityStore)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean poll(org.apache.kafka.clients.consumer.internals.RequestFuture,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(long,long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult fetchOffsetsByTimes(java.util.Map,long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitMetadataUpdate(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitPendingRequests(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollForFetches(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void startHeartbeatThreadIfNeeded()",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.common.memory.GarbageCollectedMemoryPool:void <init>(long,int,boolean,org.apache.kafka.common.metrics.Sensor)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine)",
            "org.apache.kafka.common.utils.Shell:void runCommand()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void maybeLeaveGroup()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void unsubscribe()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$2:void onSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$2:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doAutoCommitOffsetsAsync()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void maybeWaitForProducerId()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.common.network.SslTransportLayer:void handshake()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void prepare()"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:javax.net.ssl.SSLContext createSSLContext(org.apache.kafka.common.security.ssl.SslFactory$SecurityStore,org.apache.kafka.common.security.ssl.SslFactory$SecurityStore)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void validateReconfiguration(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void reconfigure(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(long,long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(long,long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsSync(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getAllTopicMetadata(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult fetchOffsetsByTimes(java.util.Map,long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsByTimes(java.util.Map,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitMetadataUpdate(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean ensureFreshMetadata(long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult fetchOffsetsByTimes(java.util.Map,long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitPendingRequests(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void startHeartbeatThreadIfNeeded()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)"
        ]
    },
    "org.apache.kafka.common.memory.GarbageCollectedMemoryPool:void <init>(long,int,boolean,org.apache.kafka.common.metrics.Sensor)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.login.LoginContext login()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:javax.security.auth.login.LoginContext login()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin:javax.security.auth.login.LoginContext login()"
        ]
    },
    "org.apache.kafka.common.utils.Shell:void runCommand()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Shell:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void unsubscribe()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$2:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doAutoCommitOffsetsAsync()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsAsync(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:void validateReconfiguration(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void validateReconfiguration(java.util.Map)",
            "org.apache.kafka.common.network.SslChannelBuilder:void validateReconfiguration(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:void reconfigure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void reconfigure(java.util.Map)",
            "org.apache.kafka.common.network.SslChannelBuilder:void reconfigure(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateAssignmentMetadataIfNeeded(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateFetchPositions(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsSync(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinPrepare(int,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void close(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getAllTopicMetadata(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics(java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsByTimes(java.util.Map,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOffsets(java.util.Collection,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map endOffsets(java.util.Collection,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean ensureFreshMetadata(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Properties)",
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin:javax.security.auth.login.LoginContext login()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)"
        ]
    },
    "org.apache.kafka.common.utils.Shell:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Shell$ShellCommandExecutor:void execute()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void complete(java.lang.Object)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void addListener(org.apache.kafka.clients.consumer.internals.RequestFutureListener)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsAsync(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync()"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.PlaintextTransportLayer,org.apache.kafka.common.network.ListenerName)",
            "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.SslTransportLayer,org.apache.kafka.common.network.ListenerName)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder:void configure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void validateReconfiguration(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SslChannelBuilder:void validateReconfiguration(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void reconfigure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.SslChannelBuilder:void reconfigure(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureActiveGroup(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void ensureActiveGroup()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateAssignmentMetadataIfNeeded(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateFetchPositions(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateAssignmentMetadataIfNeeded(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinPrepare(int,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOffsets(java.util.Collection,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map endOffsets(java.util.Collection,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.utils.Shell$ShellCommandExecutor:void execute()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Shell:java.lang.String execCommand(java.lang.String[],long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void complete(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(org.apache.kafka.common.requests.LeaveGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$RequestFutureCompletionHandler:void fireCompletion()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture$2:void onSuccess(java.lang.Object)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture voidSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void addListener(org.apache.kafka.clients.consumer.internals.RequestFutureListener)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture initiateJoinGroup()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doCommitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture compose(org.apache.kafka.clients.consumer.internals.RequestFutureAdapter)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void chain(org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class)"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.PlaintextTransportLayer,org.apache.kafka.common.network.ListenerName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.PlaintextTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.network.PlaintextChannelBuilder$1)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.SslTransportLayer,org.apache.kafka.common.network.ListenerName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.SslTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.network.SslChannelBuilder$1)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.security.authenticator.SaslServerAuthenticator buildServerAuthenticator(java.util.Map,java.util.Map,java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder clientChannelBuilder(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,java.lang.String,boolean)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder serverChannelBuilder(org.apache.kafka.common.network.ListenerName,boolean,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void ensureActiveGroup()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)",
            "org.apache.kafka.clients.producer.KafkaProducer:void close(long,java.util.concurrent.TimeUnit,boolean)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void close()"
        ]
    },
    "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void close()",
            "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void close()",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.FileRecords:boolean deleteIfExists()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void close()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,java.util.concurrent.TimeUnit)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map listTopics()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1100(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.requests.JoinGroupResponse)"
        ]
    },
    "org.apache.kafka.common.utils.Shell:java.lang.String execCommand(java.lang.String[],long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Shell:java.lang.String execCommand(java.lang.String[])"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(org.apache.kafka.common.requests.LeaveGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$RequestFutureCompletionHandler:void fireCompletion()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void firePendingCompletedRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void access$2400(org.apache.kafka.clients.consumer.internals.Fetcher,java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture$2:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture voidSuccess()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture initiateJoinGroup()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doCommitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void access$1000(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long,boolean)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollForFetches(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult fetchOffsetsByTimes(java.util.Map,long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture compose(org.apache.kafka.clients.consumer.internals.RequestFutureAdapter)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendFindCoordinatorRequest(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void maybeLeaveGroup()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendHeartbeatRequest()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetRequest(org.apache.kafka.common.Node,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void chain(org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.PlaintextTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.network.PlaintextChannelBuilder$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.PlaintextChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.network.SslTransportLayer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.network.SslChannelBuilder$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.security.authenticator.SaslServerAuthenticator buildServerAuthenticator(java.util.Map,java.util.Map,java.lang.String,org.apache.kafka.common.network.TransportLayer,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)"
        ]
    },
    "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder clientChannelBuilder(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,java.lang.String,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:org.apache.kafka.common.network.ChannelBuilder createChannelBuilder(org.apache.kafka.common.config.AbstractConfig)"
        ]
    },
    "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder serverChannelBuilder(org.apache.kafka.common.network.ListenerName,boolean,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void close(long,java.util.concurrent.TimeUnit,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.clients.producer.KafkaProducer:void close(long,java.util.concurrent.TimeUnit)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void doClose(org.apache.kafka.common.network.KafkaChannel,boolean)"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier,org.apache.kafka.common.record.AbstractLegacyRecordBatch$1)"
        ]
    },
    "org.apache.kafka.common.record.FileRecords:boolean deleteIfExists()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map beginningOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map endOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1100(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.requests.JoinGroupResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.utils.Shell:java.lang.String execCommand(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin$1:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void firePendingCompletedRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void access$2400(org.apache.kafka.clients.consumer.internals.Fetcher,java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doCommitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void access$1000(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$2:void onSuccess(java.lang.Void)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateFetchPositions(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture initiateJoinGroup()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinFollower()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendFindCoordinatorRequest(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture lookupCoordinator()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendHeartbeatRequest()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map fetchCommittedOffsets(java.util.Set,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetRequest(org.apache.kafka.common.Node,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel buildAndAttachKafkaChannel(java.nio.channels.SocketChannel,java.lang.String,java.nio.channels.SelectionKey)"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel buildAndAttachKafkaChannel(java.nio.channels.SocketChannel,java.lang.String,java.nio.channels.SelectionKey)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel buildAndAttachKafkaChannel(java.nio.channels.SocketChannel,java.lang.String,java.nio.channels.SelectionKey)"
        ]
    },
    "org.apache.kafka.clients.ClientUtils:org.apache.kafka.common.network.ChannelBuilder createChannelBuilder(org.apache.kafka.common.config.AbstractConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void close(long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void close()"
        ]
    },
    "org.apache.kafka.common.network.Selector:void doClose(org.apache.kafka.common.network.KafkaChannel,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:void close(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void close(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.Selector$CloseMode)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier,org.apache.kafka.common.record.AbstractLegacyRecordBatch$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator iterator(org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin$1:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()",
            "org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinFollower()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1200(org.apache.kafka.clients.consumer.internals.AbstractCoordinator)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture lookupCoordinator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel buildAndAttachKafkaChannel(java.nio.channels.SocketChannel,java.lang.String,java.nio.channels.SelectionKey)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:java.nio.channels.SelectionKey registerChannel(java.lang.String,java.nio.channels.SocketChannel,int)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void clear()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void close(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.common.network.Selector:void close()"
        ]
    },
    "org.apache.kafka.common.network.Selector:void close(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.Selector$CloseMode)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void send(org.apache.kafka.common.network.Send)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)",
            "org.apache.kafka.common.network.Selector:void close(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator iterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$4:void onSuccess(java.lang.Object,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture access$1200(org.apache.kafka.clients.consumer.internals.AbstractCoordinator)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.common.network.Selector:java.nio.channels.SelectionKey registerChannel(java.lang.String,java.nio.channels.SocketChannel,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void connect(java.lang.String,java.net.InetSocketAddress,int,int)",
            "org.apache.kafka.common.network.Selector:void register(java.lang.String,java.nio.channels.SocketChannel)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void handlePendingDisconnects()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void close()",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void send(org.apache.kafka.common.network.Send)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long,org.apache.kafka.common.requests.AbstractRequest)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()",
            "org.apache.kafka.common.record.AbstractRecords$2:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords$2:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.network.Selector:void connect(java.lang.String,java.net.InetSocketAddress,int,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void register(java.lang.String,java.nio.channels.SocketChannel)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void handlePendingDisconnects()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void close()",
            "org.apache.kafka.clients.producer.internals.Sender:void run()",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long,org.apache.kafka.common.requests.AbstractRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable:java.util.Iterator iterator()"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:java.lang.Object makeNext()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map fetchedRecords()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void flush()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches()",
            "org.apache.kafka.clients.producer.internals.Sender:void maybeAbortBatches(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)",
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendTransactionalRequest(long)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Long,java.lang.Object,java.lang.Object,java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>()"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerMetrics:void main(java.lang.String[])",
            "org.apache.kafka.clients.producer.internals.ProducerMetrics:void main(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:void maybeEnsureValid(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$LegacyFileChannelRecordBatch:long baseOffset()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords$2:void <init>(org.apache.kafka.common.record.AbstractRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords:java.util.Iterator recordsIterator()"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords$2:org.apache.kafka.common.record.Record makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords$2:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords$2:java.lang.Object makeNext()"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.TimestampType,long,short,int,int,boolean,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords$2:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords$2:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)"
        ]
    },
    "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:int validBytes()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.ConvertedRecords downConvert(byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.ConvertedRecords downConvert(byte,long,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:java.util.List fetchRecords(int)"
        ]
    },
    "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean ready(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClient:void access$700(org.apache.kafka.clients.NetworkClient,org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void send(org.apache.kafka.clients.ClientRequest,long)",
            "org.apache.kafka.clients.NetworkClient:void sendInternalMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.Iterator iterator()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords$2:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:java.lang.Object makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map fetchedRecords()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map pollForFetches(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:void flush()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortIncompleteBatches()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void maybeAbortBatches(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Long,java.lang.Object,java.lang.Object,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Long,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Object,java.lang.Object,java.lang.Iterable)",
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders:void <init>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecord:void <init>(java.lang.String,int,long,long,org.apache.kafka.common.record.TimestampType,long,int,int,java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerMetrics:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.ProducerMetrics:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:void maybeEnsureValid(org.apache.kafka.common.record.RecordBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()"
        ]
    },
    "org.apache.kafka.common.record.AbstractLegacyRecordBatch$LegacyFileChannelRecordBatch:long baseOffset()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:void maybeEnsureValid(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$LegacyFileChannelRecordBatch:long baseOffset()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords:java.util.Iterator recordsIterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords:java.util.Iterator access$000(org.apache.kafka.common.record.AbstractRecords)"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords$2:java.lang.Object makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.TimestampType,long,short,int,int,boolean,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(org.apache.kafka.common.record.CompressionType,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(long,org.apache.kafka.common.record.CompressionType,java.lang.Integer,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(org.apache.kafka.common.record.CompressionType,long,short,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(byte,long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(org.apache.kafka.common.record.CompressionType,long,short,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(byte,long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.TimestampType,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.ConvertedRecords downConvert(byte,long,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:java.lang.Object makeNext()"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.ConvertedRecords downConvert(byte,long,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String,org.apache.kafka.common.requests.ProduceRequest$1)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:java.util.List fetchRecords(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:java.util.List access$1400(org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords,int)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean ready(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void tryConnect(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void access$700(org.apache.kafka.clients.NetworkClient,org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void send(org.apache.kafka.clients.ClientRequest,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.producer.internals.Sender:boolean maybeSendTransactionalRequest(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void sendInternalMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void access$600(org.apache.kafka.clients.NetworkClient,org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords$2:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)"
        ]
    },
    "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:boolean hasNext()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortIncompleteBatches()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run()"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Long,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Object,java.lang.Object,java.lang.Iterable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Integer,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerRecord:void <init>(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerRecord:void <init>(java.lang.String,int,long,long,org.apache.kafka.common.record.TimestampType,long,int,int,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecord:void <init>(java.lang.String,int,long,java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.record.AbstractRecords:java.util.Iterator access$000(org.apache.kafka.common.record.AbstractRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractRecords$1:java.util.Iterator iterator()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(org.apache.kafka.common.record.CompressionType,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(long,org.apache.kafka.common.record.CompressionType,java.lang.Integer,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(org.apache.kafka.common.record.CompressionType,long,short,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(byte,long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withIdempotentRecords(long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(org.apache.kafka.common.record.CompressionType,long,short,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(byte,long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.TimestampType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClientConfig:void <init>(java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void getConfigKeyRst(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.StringBuilder)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:java.lang.Object makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String,org.apache.kafka.common.requests.ProduceRequest$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:java.util.List access$1400(org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords,int)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void tryConnect(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void access$600(org.apache.kafka.clients.NetworkClient,org.apache.kafka.common.requests.MetadataRequest$Builder,java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.common.utils.AbstractIterator:boolean hasNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.DeleteAclsResult$1:java.util.Collection apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void completeAllExceptionally(java.util.Collection,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.Map assign(org.apache.kafka.common.Cluster,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.List metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void updatePatternSubscription(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.PartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void updatePartitionLagAndLeadSensors(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsByTimes(java.util.Map,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set pausedPartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map allConsumed()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setResetPending(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean hasAllFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set missingFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetMissingPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set partitionsNeedingReset(long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void fireOnAssignment(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map partitionToStateMap(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToBeginning(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToEnd(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void seekToBeginning(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void seekToEnd(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List sortPartitions(java.util.Map,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.lang.String assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(java.util.List)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.Metadata:void setTopics(java.util.Collection)",
            "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.Cluster,java.util.Set,long)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.common.Cluster getClusterForCurrentTopics(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$3:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.header.internals.RecordHeaders$2:boolean hasNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Count:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Rate$SampledTotal:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Sum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.record.AbstractRecords$2:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:java.util.Map buildApiKeyToApiVersion(java.util.List)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest build(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Node getControllerNode(int,java.util.Collection)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set unavailableTopics()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void maybeThrowFirstPartitionError()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Object next()",
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Object peek()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.List)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashSet:void changeCapacity(int)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void access$100(org.apache.kafka.clients.producer.internals.Sender,org.apache.kafka.clients.ClientResponse,java.util.Map,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecord:void <init>(java.lang.String,int,long,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.AbstractRecords$1:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords$2:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withTransactionalRecords(long,org.apache.kafka.common.record.CompressionType,long,short,int,int,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(byte,long,org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Properties)",
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Properties)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:void getConfigKeyRst(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.StringBuilder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.ProduceRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.requests.RequestAndSize parseRequest(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map fetchedRecords()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteAclsResult$1:java.util.Collection apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DeleteAclsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$23$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void access$2000(org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable,java.util.function.Predicate)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean threadShouldExit(long,long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutPendingCalls(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void completeAllExceptionally(java.util.Collection,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void access$2200(java.util.Collection,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List access$2500(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Object apply(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ApiVersions:void update(java.lang.String,org.apache.kafka.clients.NodeApiVersions)",
            "org.apache.kafka.clients.ApiVersions:void remove(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean hasReadyNodes(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords:int count()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.Map assign(org.apache.kafka.common.Cluster,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.List metadata()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void updatePatternSubscription(org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1:void onMetadataUpdate(org.apache.kafka.common.Cluster,java.util.Set)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.PartitionAssignor lookupAssignor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean joinGroupIfNeeded(long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$3:void onSuccess(java.lang.Void)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection access$300(org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void poll(long,long,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$PollCondition,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void handlePendingDisconnects()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void updatePartitionLagAndLeadSensors(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$3000(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:void drain()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromUser(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void assign(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.MockConsumer:void rebalance(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set pausedPartitions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Set paused()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.List fetchablePartitions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map allConsumed()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void doAutoCommitOffsetsAsync()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void maybeAutoCommitOffsetsSync(long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitSync(java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync()",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setResetPending(java.util.Set,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean hasAllFetchPositions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateFetchPositions(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set missingFetchPositions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetMissingPositions()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:boolean updateFetchPositions(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set partitionsNeedingReset(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetFailed(java.util.Set,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onFailure(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void fireOnAssignment(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void unsubscribe()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map partitionToStateMap(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToBeginning(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToEnd(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void seekToBeginning(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void seekToEnd(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void addEndOffsets(java.util.Map)",
            "org.apache.kafka.clients.consumer.MockConsumer:void updateEndOffsets(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.Map assign(org.apache.kafka.common.Cluster,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.Map assign(org.apache.kafka.common.Cluster,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair:boolean in(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair:boolean access$600(org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair,java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isSticky()"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isSticky()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean access$300(org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.Map assign(org.apache.kafka.common.Cluster,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:int getBalanceScore(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List sortPartitions(java.util.Map,boolean,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:java.lang.String assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription subscription(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:boolean hasIdenticalListElements(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean areSubscriptionsIdentical(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:void deepCopy(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map deepCopy(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyFullFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyIncrementalFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:boolean handleResponse(org.apache.kafka.common.requests.FetchResponse)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean hasInFlightRequests()"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.Metadata:void setTopics(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void updatePatternSubscription(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.Cluster,java.util.Set,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleCompletedMetadataResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.Metadata:org.apache.kafka.common.Cluster getClusterForCurrentTopics(org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.Cluster,java.util.Set,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void handleConnections()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:java.util.List poll(long,long)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create()"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void abort(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:boolean done(long,long,java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer$InterceptorCallback:void onCompletion(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(int,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean canRetry(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void run(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler access$2100(org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:void logAll()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void logUnused()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$3:java.util.Map unprefixed(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$3:java.util.List validValues(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$3:boolean visible(java.lang.String,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$2:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$2:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.List validate(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)"
        ]
    },
    "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$2:boolean hasNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.DeleteAclsResult$1:java.util.Collection apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void completeAllExceptionally(java.util.Collection,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.Map assign(org.apache.kafka.common.Cluster,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.List metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void updatePatternSubscription(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.PartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void updatePartitionLagAndLeadSensors(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsByTimes(java.util.Map,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set pausedPartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map allConsumed()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setResetPending(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean hasAllFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set missingFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetMissingPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set partitionsNeedingReset(long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void fireOnAssignment(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map partitionToStateMap(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToBeginning(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToEnd(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void seekToBeginning(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void seekToEnd(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List sortPartitions(java.util.Map,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.lang.String assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(java.util.List)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.Metadata:void setTopics(java.util.Collection)",
            "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.Cluster,java.util.Set,long)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.common.Cluster getClusterForCurrentTopics(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$3:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.header.internals.RecordHeaders$2:boolean hasNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Count:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Rate$SampledTotal:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Sum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.record.AbstractRecords$2:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:java.util.Map buildApiKeyToApiVersion(java.util.List)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest build(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Node getControllerNode(int,java.util.Collection)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set unavailableTopics()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void maybeThrowFirstPartitionError()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.List)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashSet:void changeCapacity(int)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:java.lang.Object makeNext()"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.internals.ClusterResourceListeners configureClusterResourceListeners(org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,java.util.List[])",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.common.internals.ClusterResourceListeners configureClusterResourceListeners(org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,java.util.List[])"
        ]
    },
    "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.Cluster,java.util.Set,long)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void tryComplete()",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void maybeComplete()",
            "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture completedFuture(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23$1:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void completeAllExceptionally(java.util.Collection,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:boolean handleFindCoordinatorError(org.apache.kafka.common.requests.FindCoordinatorResponse,org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean cancel(boolean)",
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set pausedPartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map allConsumed()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean hasAllFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set missingFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetMissingPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set partitionsNeedingReset(long)"
        ]
    },
    "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.PartitionStates:void set(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:void addReporter(org.apache.kafka.common.metrics.MetricsReporter)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter:void metricRemoval(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean addAttribute(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void removeReporter(org.apache.kafka.common.metrics.MetricsReporter)",
            "org.apache.kafka.common.metrics.Metrics:void close()"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()",
            "org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void updatePartitionLagAndLeadSensors(java.util.Set)",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.utils.AppInfoParser:void unregisterMetrics(org.apache.kafka.common.metrics.Metrics)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.MetricValueProvider)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MeasurableStat,org.apache.kafka.common.metrics.MetricConfig)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:void record(double,long)",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas()"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Count:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Frequencies$1:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Frequencies:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Percentiles$1:double measure(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Rate$SampledTotal:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Rate:long windowSize(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SimpleRate:long windowSize(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Sum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void <init>(int,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.memory.MemoryPool,org.apache.kafka.common.utils.LogContext)"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void close()"
        ]
    },
    "org.apache.kafka.common.network.Selector:void muteAll()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void unmuteAll()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void addToCompletedReceives()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()"
        ]
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:void <init>(org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords parseCompletedFetch(org.apache.kafka.clients.consumer.internals.Fetcher$CompletedFetch)",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords$2:void <init>(org.apache.kafka.common.record.AbstractRecords)",
            "org.apache.kafka.common.record.AbstractRecords$2:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.RecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)"
        ]
    },
    "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)"
        ]
    },
    "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.StopReplicaResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:java.util.Map buildApiKeyToApiVersion(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:void <init>(java.util.Collection)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(org.apache.kafka.common.protocol.Errors,java.util.List)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchResponse:int sizeOf(short,java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Node getControllerNode(int,java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(int,java.util.List,java.lang.String,int,java.util.List)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleCompletedMetadataResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.Set unavailableTopics()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleCompletedMetadataResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleCompletedMetadataResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:void maybeThrowFirstPartitionError()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.lang.String,javax.security.auth.Subject,java.lang.String,java.lang.String,java.lang.String,boolean,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:javax.security.sasl.SaslServer createSaslKerberosServer(org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.util.Map,javax.security.auth.Subject)"
        ]
    },
    "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin:java.lang.String getServiceName(java.util.Map,java.lang.String,javax.security.auth.login.Configuration)",
            "org.apache.kafka.common.security.plain.internals.PlainServerCallbackHandler:boolean authenticate(java.lang.String,char[])"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket access$200(org.apache.kafka.common.security.kerberos.KerberosLogin)"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:org.apache.kafka.common.security.kerberos.KerberosShortNamer fromUnparsedRules(java.lang.String,java.util.List)"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal applyKerberosShortNamer(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void <init>(java.util.Collection)"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCache(org.apache.kafka.common.security.token.delegation.DelegationToken,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void removeCache(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.AbstractIterator:java.lang.Object next()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.DeleteAclsResult$1:java.util.Collection apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void completeAllExceptionally(java.util.Collection,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.Map assign(org.apache.kafka.common.Cluster,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.List metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void updatePatternSubscription(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.PartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void updatePartitionLagAndLeadSensors(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsByTimes(java.util.Map,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set pausedPartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map allConsumed()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setResetPending(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean hasAllFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set missingFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetMissingPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set partitionsNeedingReset(long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void fireOnAssignment(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map partitionToStateMap(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToBeginning(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToEnd(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void seekToBeginning(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void seekToEnd(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.NoOffsetForPartitionException:org.apache.kafka.common.TopicPartition partition()",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List sortPartitions(java.util.Map,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.lang.String assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(java.util.List)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.Metadata:void setTopics(java.util.Collection)",
            "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.Cluster,java.util.Set,long)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.common.Cluster getClusterForCurrentTopics(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$3:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.header.internals.RecordHeaders$2:org.apache.kafka.common.header.Header next()",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Count:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Rate$SampledTotal:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Sum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.Selector$IdleExpiryManager:java.util.Map$Entry pollExpiredConnection(long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()",
            "org.apache.kafka.common.record.AbstractRecords$2:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:void <init>(org.apache.kafka.common.record.LazyDownConversionRecords,org.apache.kafka.common.record.Records,long,org.apache.kafka.common.record.ConvertedRecords)",
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:java.util.Map buildApiKeyToApiVersion(java.util.List)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest build(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Node getControllerNode(int,java.util.Collection)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set unavailableTopics()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void maybeThrowFirstPartitionError()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin$1:org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredential expiringCredential()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.List)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashSet:void changeCapacity(int)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.utils.AbstractIterator:java.lang.Object peek()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:org.apache.kafka.common.record.ConvertedRecords makeNext()"
        ]
    },
    "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(java.util.List)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashSet:void changeCapacity(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.ImplicitLinkedHashSet:boolean add(org.apache.kafka.common.utils.ImplicitLinkedHashSet$Element)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.ConsumerGroupDescription:java.lang.String toString()",
            "org.apache.kafka.clients.admin.MemberAssignment:java.lang.String toString()",
            "org.apache.kafka.clients.admin.TopicDescription:java.lang.String toString()",
            "org.apache.kafka.clients.CommonClientConfigs:void <clinit>()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String partitionsToLogString(java.util.Collection)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyFullFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyIncrementalFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.common.config.ConfigDef$NonEmptyStringWithoutControlChars:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ValidString:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ValidString:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.requests.CreateAclsRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.DeleteAclsResponse$AclFilterResponse:java.lang.String toString()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.lang.String toString()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.FetchRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.JoinGroupRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.JoinGroupResponse:java.lang.String toString()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest$PartitionState:java.lang.String toString()",
            "org.apache.kafka.common.requests.ListOffsetResponse$PartitionData:java.lang.String toString()",
            "org.apache.kafka.common.requests.MetadataRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata:java.lang.String toString()",
            "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.StopReplicaRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.SyncGroupRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Broker:java.lang.String toString()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.lang.String toString()",
            "org.apache.kafka.common.TopicPartitionInfo:java.lang.String toString()",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.lang.Object[],java.lang.String)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceRequest:java.lang.String toString(boolean)",
            "org.apache.kafka.common.security.scram.internals.ScramExtensions:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.Sender:void access$100(org.apache.kafka.clients.producer.internals.Sender,org.apache.kafka.clients.ClientResponse,java.util.Map,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$1:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withRecords(org.apache.kafka.common.record.CompressionType,org.apache.kafka.common.record.SimpleRecord[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClientConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.producer.ProducerConfig:void main(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.clients.admin.DeleteAclsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void access$2000(org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable,java.util.function.Predicate)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean threadShouldExit(long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutPendingCalls(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void access$2200(java.util.Collection,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleFailure(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List access$2500(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Object apply(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.ApiVersions:void update(java.lang.String,org.apache.kafka.clients.NodeApiVersions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)"
        ]
    },
    "org.apache.kafka.clients.ApiVersions:void remove(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean hasReadyNodes(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasReadyNodes(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1:void onMetadataUpdate(org.apache.kafka.common.Cluster,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.lang.String,int,int,org.apache.kafka.clients.consumer.internals.Heartbeat,java.util.List,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,long,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors,boolean,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1:void onMetadataUpdate(org.apache.kafka.common.Cluster,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.Cluster,java.util.Set,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.regex.Pattern)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$3:void onSuccess(java.lang.Void)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$3:void onSuccess(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection access$300(org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$3000(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void onAssignment(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:void drain()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:void access$1700(org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void assign(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void rebalance(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Set paused()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(org.apache.kafka.clients.consumer.OffsetCommitCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitSync()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.SubscriptionState:void unsubscribe()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void unsubscribe()",
            "org.apache.kafka.clients.consumer.MockConsumer:void unsubscribe()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync()",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.util.Map,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void addEndOffsets(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void updateEndOffsets(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair:boolean access$600(org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean access$300(org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean isSticky()"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription subscription(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.List metadata()"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:boolean areSubscriptionsIdentical(java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List sortPartitions(java.util.Map,boolean,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map deepCopy(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List sortPartitions(java.util.Map,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyFullFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:boolean handleResponse(org.apache.kafka.common.requests.FetchResponse)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String verifyIncrementalFetchResponsePartitions(org.apache.kafka.common.requests.FetchResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:boolean handleResponse(org.apache.kafka.common.requests.FetchResponse)"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:boolean handleResponse(org.apache.kafka.common.requests.FetchResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean hasInFlightRequests()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleCompletedMetadataResponse(org.apache.kafka.common.requests.RequestHeader,long,org.apache.kafka.common.requests.MetadataResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void abort(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:boolean done(long,long,java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)",
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer$InterceptorCallback:void onCompletion(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.KafkaProducer$InterceptorCallback:void onCompletion(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.clients.producer.MockProducer$Completion:void complete(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientResponse:void onComplete()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:boolean canRetry(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:boolean canRetry(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler access$2100(org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddOffsetsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.Cluster:void <init>(java.lang.String,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.internals.AdminMetadataManager:void clearController()",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.common.Cluster getClusterForCurrentTopics(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster empty()",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster withPartitions(java.util.Map)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef$3:java.util.List validValues(java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$3:java.util.List validValues(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$3:boolean visible(java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$3:boolean visible(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$2:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$2:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef defineInternal(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance)",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:java.util.List validate(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:java.lang.Object makeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AbstractIterator:java.lang.Boolean maybeComputeNext()"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.common.internals.ClusterResourceListeners configureClusterResourceListeners(org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,java.util.List[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.common.internals.ClusterResourceListeners configureClusterResourceListeners(org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,java.util.List[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void tryComplete()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void <init>(java.util.Collection,org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void tryComplete(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void maybeComplete()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void <init>(int,org.apache.kafka.common.KafkaFuture)",
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture completedFuture(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$17:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$18:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$19:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$20:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$23$1:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$5:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$6:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:boolean handleFindCoordinatorError(org.apache.kafka.common.requests.FindCoordinatorResponse,org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:boolean access$2600(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.requests.FindCoordinatorResponse,org.apache.kafka.common.internals.KafkaFutureImpl)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:boolean cancel(boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.internals.PartitionStates:void set(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addReporter(org.apache.kafka.common.metrics.MetricsReporter)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.JmxReporter:void metricRemoval(org.apache.kafka.common.metrics.KafkaMetric)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean addAttribute(org.apache.kafka.common.metrics.KafkaMetric)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:void metricChange(org.apache.kafka.common.metrics.KafkaMetric)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void removeReporter(org.apache.kafka.common.metrics.MetricsReporter)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void unregisterMetrics(org.apache.kafka.common.metrics.Metrics)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser:void unregisterAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.MetricValueProvider)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Measurable)",
            "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricValueProvider)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MeasurableStat,org.apache.kafka.common.metrics.MetricConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MeasurableStat)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void record(double,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.clients.producer.internals.BufferPool:java.nio.ByteBuffer allocate(int,long)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordRetries(java.lang.String,int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordErrors(java.lang.String,int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordLatency(java.lang.String,long)",
            "org.apache.kafka.common.metrics.Sensor:void record(double)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesSent(java.lang.String,long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesReceived(java.lang.String,int)",
            "org.apache.kafka.common.network.Selector:void poll(long)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void checkQuotas()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void <init>(long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void registerMetrics(org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.Sender,org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()",
            "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)",
            "org.apache.kafka.common.metrics.stats.Rate:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Frequencies$1:double measure(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()",
            "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Frequencies:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Percentiles$1:double measure(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()",
            "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Percentiles:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.SampledStat:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Rate:long windowSize(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Rate:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.SimpleRate:long windowSize(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.stats.Rate:double measure(org.apache.kafka.common.metrics.MetricConfig,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void <init>(int,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.memory.MemoryPool,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void <init>(int,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Protocol:void main(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.record.RecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:boolean send(org.apache.kafka.common.network.Send)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.MultiRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBuffer()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBuffer()"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.network.Send buildResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsResponse:java.util.Map errorCounts()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(int,org.apache.kafka.common.protocol.Errors,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:void <init>(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(org.apache.kafka.common.protocol.Errors,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:int sizeOf(short,java.util.Iterator)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:void <init>(int,java.util.List,java.lang.String,int,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(java.util.List,java.lang.String,int,java.util.List)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void <init>(java.util.Map,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.lang.String,javax.security.auth.Subject,java.lang.String,java.lang.String,java.lang.String,boolean,org.apache.kafka.common.network.TransportLayer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.security.authenticator.SaslClientAuthenticator buildClientAuthenticator(java.util.Map,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.lang.String,java.lang.String,java.lang.String,org.apache.kafka.common.network.TransportLayer,javax.security.auth.Subject)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:javax.security.sasl.SaslServer createSaslKerberosServer(org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.util.Map,javax.security.auth.Subject)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void createSaslServer(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:java.lang.String getServiceName(java.util.Map,java.lang.String,javax.security.auth.login.Configuration)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket access$200(org.apache.kafka.common.security.kerberos.KerberosLogin)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.kerberos.KerberosLogin$1:void run()"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosShortNamer:org.apache.kafka.common.security.kerberos.KerberosShortNamer fromUnparsedRules(java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal applyKerberosShortNamer(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal build(org.apache.kafka.common.security.auth.AuthenticationContext)"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void <init>(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCache(org.apache.kafka.common.security.token.delegation.DelegationToken,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void removeCache(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.NoOffsetForPartitionException:org.apache.kafka.common.TopicPartition partition()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition access$100(org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements,org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$2:org.apache.kafka.common.header.Header next()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.header.internals.RecordHeaders$2:java.lang.Object next()"
        ]
    },
    "org.apache.kafka.common.network.Selector$IdleExpiryManager:java.util.Map$Entry pollExpiredConnection(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:void <init>(org.apache.kafka.common.record.LazyDownConversionRecords,org.apache.kafka.common.record.Records,long,org.apache.kafka.common.record.ConvertedRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:void <init>(org.apache.kafka.common.record.LazyDownConversionRecords,org.apache.kafka.common.record.Records,long,org.apache.kafka.common.record.ConvertedRecords,org.apache.kafka.common.record.LazyDownConversionRecords$1)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin$1:org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredential expiringCredential()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:void reLogin()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashSet:boolean add(org.apache.kafka.common.utils.ImplicitLinkedHashSet$Element)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.ImplicitLinkedHashSet:void mustAdd(org.apache.kafka.common.utils.ImplicitLinkedHashSet$Element)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashSet:boolean add(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.admin.ConsumerGroupDescription:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.clients.admin.MemberAssignment:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.clients.admin.TopicDescription:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.clients.CommonClientConfigs:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.CommonClientConfigs:java.util.Map postProcessReconnectBackoffConfigs(org.apache.kafka.common.config.AbstractConfig,java.util.Map)",
            "org.apache.kafka.clients.CommonClientConfigs:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.clients.producer.ProducerConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String partitionsToLogString(java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String access$200(org.apache.kafka.clients.FetchSessionHandler,java.util.Collection)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$NonEmptyStringWithoutControlChars:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$2:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ValidString:void ensureValid(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$2:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ConfigKey:void <init>(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender,boolean)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.Object parseValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.Object,boolean)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ValidString:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:java.lang.String toString()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse$AclFilterResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest$PartitionState:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse$PartitionData:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse$PartitionMetadata:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Broker:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.TopicPartitionInfo:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.String join(java.lang.Object[],java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:java.lang.Object newParameterizedInstance(java.lang.String,java.lang.Object[])"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:java.lang.String toString(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramExtensions:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:java.lang.String clientFirstMessageBare()",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$1:void onComplete(org.apache.kafka.clients.ClientResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientResponse:void onComplete()"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AbstractRequest$Builder:org.apache.kafka.common.requests.AbstractRequest build()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasReadyNodes(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.lang.String,int,int,org.apache.kafka.clients.consumer.internals.Heartbeat,java.util.List,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,long,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors,boolean,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.regex.Pattern)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$3:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireSuccess()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void onAssignment(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void fireOnAssignment(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:void access$1700(org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void close()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void raise(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void addListener(org.apache.kafka.clients.consumer.internals.RequestFutureListener)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void unsubscribe()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void commitSync(java.util.Map,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:boolean isSticky()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer$Completion:void complete(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.clients.producer.MockProducer:boolean errorNext(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.ClientResponse:void onComplete()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,java.lang.RuntimeException,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:boolean canRetry(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager$AddOffsetsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnRequestHandler:void onComplete(org.apache.kafka.clients.ClientResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.internals.AdminMetadataManager:void clearController()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster empty()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.internals.AdminMetadataManager:void <init>(org.apache.kafka.common.utils.LogContext,long,long)",
            "org.apache.kafka.clients.Metadata:void <init>(long,long,boolean,boolean,org.apache.kafka.common.internals.ClusterResourceListeners)",
            "org.apache.kafka.clients.producer.MockProducer:void <init>(boolean,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)",
            "org.apache.kafka.clients.producer.MockProducer:void <init>(boolean,org.apache.kafka.clients.producer.Partitioner,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)",
            "org.apache.kafka.clients.producer.MockProducer:void <init>()"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster withPartitions(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef defineInternal(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void enqueue(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void call(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void <init>(java.util.Collection,org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void tryComplete(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleFailure(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl$Applicant:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void <init>(int,org.apache.kafka.common.KafkaFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture allOf(org.apache.kafka.common.KafkaFuture[])"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:boolean access$2600(org.apache.kafka.clients.admin.KafkaAdminClient,org.apache.kafka.common.requests.FindCoordinatorResponse,org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.KafkaFuture$AllOfAdapter:void accept(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl$WhenCompleteBiConsumer:void accept(java.lang.Object,java.lang.Throwable)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:void metricChange(org.apache.kafka.common.metrics.KafkaMetric)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.utils.Time)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerMetrics:void main(java.lang.String[])",
            "org.apache.kafka.common.metrics.Metrics:void <init>()"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void unregisterAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void close(long,java.util.concurrent.TimeUnit)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)",
            "org.apache.kafka.clients.producer.KafkaProducer:void close(long,java.util.concurrent.TimeUnit,boolean)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Measurable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.Measurable)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MetricValueProvider)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser:void registerMetrics(org.apache.kafka.common.metrics.Metrics)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.MeasurableStat)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.Sender,org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)",
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.requests.AbstractResponse parseResponse(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.BufferPool:java.nio.ByteBuffer allocate(int,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordRetries(java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void reenqueueBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordErrors(java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordLatency(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void record(double)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.common.memory.SimpleMemoryPool:void maybeRecordEndOfDrySpell()",
            "org.apache.kafka.common.metrics.Sensor:void record()"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesSent(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesReceived(java.lang.String,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives(org.apache.kafka.common.network.KafkaChannel,java.util.Deque)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.lang.String,int,int,org.apache.kafka.clients.consumer.internals.Heartbeat,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,long,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry,org.apache.kafka.clients.consumer.internals.Fetcher$1)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$3900(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,java.lang.String,int,int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.BufferPool:void <init>(long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void <init>(org.apache.kafka.common.utils.LogContext,int,long,org.apache.kafka.common.record.CompressionType,long,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.ApiVersions,org.apache.kafka.clients.producer.internals.TransactionManager)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void registerMetrics(org.apache.kafka.common.metrics.Metrics,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void <init>(org.apache.kafka.common.utils.LogContext,int,long,org.apache.kafka.common.record.CompressionType,long,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.ApiVersions,org.apache.kafka.clients.producer.internals.TransactionManager)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.Sender,org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.producer.internals.RecordAccumulator,boolean,int,short,int,org.apache.kafka.clients.producer.internals.SenderMetricsRegistry,org.apache.kafka.common.utils.Time,int,long,org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.ApiVersions)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:java.lang.Object getAttribute(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:double value()",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)"
        ]
    },
    "org.apache.kafka.common.metrics.stats.Rate:double measure(org.apache.kafka.common.metrics.MetricConfig,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.KafkaMetric:java.lang.Object metricValue()",
            "org.apache.kafka.common.metrics.KafkaMetric:double measurableValue(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void <init>(int,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,java.util.Map,boolean,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void <init>(long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:void main(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.KafkaChannel:boolean send(org.apache.kafka.common.network.Send)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.network.Send write()"
        ]
    },
    "org.apache.kafka.common.record.MultiRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:boolean send(org.apache.kafka.common.network.Send)",
            "org.apache.kafka.common.record.MultiRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBuffer()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBuffer()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBuffer()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBufferAndUpdateInterestOps()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBuffer()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBufferAndUpdateInterestOps()"
        ]
    },
    "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.network.Send buildResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.RequestHeader)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long,org.apache.kafka.common.requests.AbstractRequest)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.network.Send buildResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleApiVersionsRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.ApiVersionsRequest)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.Errors,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse createApiVersionsResponse(int,byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse(int,byte)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse defaultApiVersionsResponse()"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.requests.AbstractResponse parseResponse(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$10:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$9:org.apache.kafka.common.requests.AbstractRequest$Builder createRequest(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:void <init>(java.util.List,java.lang.String,int,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.requests.MetadataResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.security.authenticator.SaslClientAuthenticator buildClientAuthenticator(java.util.Map,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.lang.String,java.lang.String,java.lang.String,org.apache.kafka.common.network.TransportLayer,javax.security.auth.Subject)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void createSaslServer(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.common.security.kerberos.KerberosLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder:org.apache.kafka.common.security.auth.KafkaPrincipal build(org.apache.kafka.common.security.auth.AuthenticationContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()",
            "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition access$100(org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements,org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.header.internals.RecordHeaders$2:java.lang.Object next()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Config:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.admin.DeleteAclsResult$1:java.util.Collection apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$3:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:int timeoutCallsToSend(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void timeoutCallsInFlight(org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls(java.util.Collection)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean hasActiveExternalCalls()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessor:int handleTimeouts(java.util.Collection,java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void completeAllExceptionally(java.util.Collection,java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List configSynonyms(org.apache.kafka.common.requests.DescribeConfigsResponse$ConfigEntry)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterConfigsResult alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult$1:java.lang.Void apply(java.util.Collection)",
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()",
            "org.apache.kafka.clients.ClientUtils:java.util.List parseAndValidateAddresses(java.util.List)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean hasReadyNodes(long)",
            "org.apache.kafka.clients.consumer.ConsumerRecords$ConcatenatedIterable$1:org.apache.kafka.clients.consumer.ConsumerRecord makeNext()",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.lang.Iterable records(java.lang.String)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:int count()",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.Map assign(org.apache.kafka.common.Cluster,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.List metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void updatePatternSubscription(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.PartitionAssignor lookupAssignor(java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean refreshCommittedOffsetsIfNeeded(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:org.apache.kafka.clients.consumer.ConsumerRecords onConsume(org.apache.kafka.clients.consumer.ConsumerRecords)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void onCommit(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors:void close()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Collection removeExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void clean()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failExpiredRequests(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void failUnsentRequests(org.apache.kafka.common.Node,java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void updatePartitionLagAndLeadSensors(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:boolean containsAbortMarker(org.apache.kafka.common.record.RecordBatch)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsIfNeeded()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map offsetsByTimes(java.util.Map,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map beginningOrEndOffset(java.util.Collection,long,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void resetOffsetsAsync(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromUser(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void assignFromSubscribed(java.util.Collection)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set pausedPartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.List fetchablePartitions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map allConsumed()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void setResetPending(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:boolean hasAllFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set missingFetchPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetMissingPositions()",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Set partitionsNeedingReset(long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void resetFailed(java.util.Set,long)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:void fireOnAssignment(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.SubscriptionState:java.util.Map partitionToStateMap(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void subscribe(java.util.Collection,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void assign(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToBeginning(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void seekToEnd(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.Map offsetsForTimes(java.util.Map,java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void commitAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.MockConsumer:void seekToBeginning(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void seekToEnd(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resume(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.NoOffsetForPartitionException:org.apache.kafka.common.TopicPartition partition()",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair:boolean in(java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isLinked(java.lang.String,java.lang.String,java.util.Set,java.util.List)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean in(java.util.List,java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean hasCycles(java.util.Set)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:boolean isSticky()",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:int getBalanceScore(java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List sortPartitions(java.util.Map,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.lang.String assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(java.util.List)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean hasIdenticalListElements(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void deepCopy(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()",
            "org.apache.kafka.clients.FetchSessionHandler$FetchRequestData:java.lang.String toString()",
            "org.apache.kafka.clients.FetchSessionHandler:java.util.Set findMissing(java.util.Set,java.util.Set)",
            "org.apache.kafka.clients.FetchSessionHandler:java.lang.String responseDataToLogString(org.apache.kafka.common.requests.FetchResponse)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty()",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Boolean hasExpiredRequest(long,java.util.Deque)",
            "org.apache.kafka.clients.InFlightRequests:java.util.List nodesWithTimedOutRequests(long)",
            "org.apache.kafka.clients.Metadata:void setTopics(java.util.Collection)",
            "org.apache.kafka.clients.Metadata:void update(org.apache.kafka.common.Cluster,java.util.Set,long)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.common.Cluster getClusterForCurrentTopics(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()",
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void completeResponses(java.util.List)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.NetworkClient:void handleTimedOutRequests(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleDisconnections(java.util.List,long)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)",
            "org.apache.kafka.clients.NetworkClientUtils:org.apache.kafka.clients.ClientResponse sendAndReceive(org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.ClientRequest,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.clients.NodeApiVersions create(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:void <init>(java.util.Collection)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void completeFutureAndFireCallbacks(long,long,java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:org.apache.kafka.clients.producer.ProducerRecord onSend(org.apache.kafka.clients.producer.ProducerRecord)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onAcknowledgement(org.apache.kafka.clients.producer.RecordMetadata,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void onSendError(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.TopicPartition,java.lang.Exception)",
            "org.apache.kafka.clients.producer.internals.ProducerInterceptors:void close()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean hasUndrained()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void awaitFlushCompletion()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequests(java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void sendProduceRequest(long,int,short,int,java.util.List)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$AddPartitionsToTxnHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void authenticationFailed(org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.TransactionManager$TxnOffsetCommitHandler txnOffsetCommitHandler(org.apache.kafka.clients.producer.internals.TransactionalRequestResult,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Cluster bootstrap(java.util.List)",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsStrings()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map originalsWithPrefix(java.lang.String,boolean)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void logAll()",
            "org.apache.kafka.common.config.AbstractConfig:void logUnused()",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.util.List,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$3:java.util.Map unprefixed(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef$CompositeValidator:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef$ValidList:void ensureValid(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map defaultValues()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validateAll(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parseForValidate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map validate(java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List undefinedDependentConfigs()",
            "org.apache.kafka.common.config.ConfigDef:java.util.Set getConfigsWithNoParent()",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map convertToStringMapWithPasswordValues(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toRst()",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toEnrichedRst()",
            "org.apache.kafka.common.config.ConfigDef:java.util.List sortedConfigs()",
            "org.apache.kafka.common.config.ConfigDef:void embed(java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.ConfigDef:java.util.List embeddedDependents(java.lang.String,java.util.List)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String,java.util.Set)",
            "org.apache.kafka.common.header.internals.RecordHeaders$2:org.apache.kafka.common.header.Header next()",
            "org.apache.kafka.common.header.internals.RecordHeaders$FilterByKeyIterator:org.apache.kafka.common.header.Header makeNext()",
            "org.apache.kafka.common.header.internals.RecordHeaders:void <init>(java.lang.Iterable)",
            "org.apache.kafka.common.header.internals.RecordHeaders:org.apache.kafka.common.header.Headers remove(java.lang.String)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void maybeAddAll(java.util.List)",
            "org.apache.kafka.common.internals.ClusterResourceListeners:void onUpdate(org.apache.kafka.common.ClusterResource)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean complete(java.lang.Object)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:boolean completeExceptionally(java.lang.Throwable)",
            "org.apache.kafka.common.internals.PartitionStates:java.util.List partitionStates()",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.MBeanInfo getMBeanInfo()",
            "org.apache.kafka.common.metrics.JmxReporter:void init(java.util.List)",
            "org.apache.kafka.common.metrics.JmxReporter:java.lang.String getMBeanName(java.lang.String,org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.JmxReporter:void close()",
            "org.apache.kafka.common.metrics.Metrics$ExpireSensorTask:void run()",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric removeMetric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.metrics.Metrics:void registerMetric(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:void close()",
            "org.apache.kafka.common.metrics.Sensor:void record(double,long,boolean)",
            "org.apache.kafka.common.metrics.Sensor:void checkQuotas(long)",
            "org.apache.kafka.common.metrics.Sensor:boolean add(org.apache.kafka.common.metrics.CompoundStat,org.apache.kafka.common.metrics.MetricConfig)",
            "org.apache.kafka.common.metrics.stats.Avg:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Count:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double frequency(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Frequencies:double totalCount()",
            "org.apache.kafka.common.metrics.stats.Max:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Min:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Percentiles:double value(org.apache.kafka.common.metrics.MetricConfig,long,double)",
            "org.apache.kafka.common.metrics.stats.Rate$SampledTotal:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.SampledStat:void purgeObsoleteSamples(org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.metrics.stats.Sum:double combine(java.util.List,org.apache.kafka.common.metrics.MetricConfig,long)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void close()",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.Selector$IdleExpiryManager:java.util.Map$Entry pollExpiredConnection(long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void close()",
            "org.apache.kafka.common.network.Selector:void close()",
            "org.apache.kafka.common.network.Selector:void poll(long)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void muteAll()",
            "org.apache.kafka.common.network.Selector:void unmuteAll()",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:boolean hasStagedReceives()",
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()",
            "org.apache.kafka.common.protocol.Protocol:void schemaToBnfHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder,int)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)",
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch:long baseOffset()",
            "org.apache.kafka.common.record.AbstractRecords$2:org.apache.kafka.common.record.Record makeNext()",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasMatchingMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:boolean hasCompatibleMagic(byte)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,long,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.AbstractRecords:int estimateSizeInBytes(byte,org.apache.kafka.common.record.CompressionType,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(long,java.lang.Iterable)",
            "org.apache.kafka.common.record.DefaultRecordBatch:int sizeInBytes(java.lang.Iterable)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$LogOffsetPosition searchForOffsetWithSize(long,int)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset searchForTimestamp(long,int,long)",
            "org.apache.kafka.common.record.FileRecords:org.apache.kafka.common.record.FileRecords$TimestampAndOffset largestTimestampAfter(int)",
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:long writeTo(java.nio.channels.GatheringByteChannel,long,int)",
            "org.apache.kafka.common.record.MemoryRecords:int validBytes()",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecordsBuilder buildRetainedRecordsInto(org.apache.kafka.common.record.RecordBatch,java.util.List,org.apache.kafka.common.utils.ByteBufferOutputStream)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()",
            "org.apache.kafka.common.record.MultiRecordsSend:void <init>(java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.ConvertedRecords downConvert(java.lang.Iterable,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.RecordsUtil:org.apache.kafka.common.record.MemoryRecordsBuilder convertRecordBatch(byte,java.nio.ByteBuffer,org.apache.kafka.common.record.RecordsUtil$RecordBatchAndRecords)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:java.util.Map buildApiKeyToApiVersion(java.util.List)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest$Builder:java.util.Map toResourceToConfigNames(java.util.Collection)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse fromError(int,org.apache.kafka.common.protocol.Errors,java.util.List)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchRequest$TopicAndPartitionData:java.util.List batchByTopic(java.util.Iterator)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest$Builder:org.apache.kafka.common.requests.ListOffsetRequest build(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Node getControllerNode(int,java.util.Collection)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errors()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set topicsByError(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Set unavailableTopics()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.Cluster cluster()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void maybeThrowFirstPartitionError()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(short,short,int,java.util.Map,java.lang.String)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map createPartitionSizes(java.util.Map)",
            "org.apache.kafka.common.requests.ProduceRequest:void validateRecords(short,org.apache.kafka.common.record.MemoryRecords)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest$Builder:org.apache.kafka.common.requests.UpdateMetadataRequest build(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.security.authenticator.LoginManager:void closeAll()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:java.lang.String firstPrincipal(javax.security.auth.Subject)",
            "org.apache.kafka.common.security.authenticator.SaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.kerberos.KerberosTicket getTGT()",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.util.List parseRules(java.lang.String,java.util.List)",
            "org.apache.kafka.common.security.kerberos.KerberosShortNamer:java.lang.String shortName(org.apache.kafka.common.security.kerberos.KerberosName)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin$1:org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredential expiringCredential()",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Map toMap(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object convert(com.fasterxml.jackson.databind.JsonNode)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateScope(org.apache.kafka.common.security.oauthbearer.OAuthBearerToken,java.util.List)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean logout()",
            "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils:void createCache(org.apache.kafka.common.security.authenticator.CredentialCache,java.util.Collection)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.TokenInformation:java.util.Collection renewersAsString()",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.List)",
            "org.apache.kafka.common.utils.ImplicitLinkedHashSet:void changeCapacity(int)",
            "org.apache.kafka.common.utils.Utils:java.lang.String join(java.util.Collection,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.lang.String mkString(java.util.Map,java.lang.String,java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)",
            "org.apache.kafka.common.utils.Utils:java.util.Properties mkProperties(java.util.Map)",
            "org.apache.kafka.common.utils.Utils:java.util.List toList(java.util.Iterator)"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords$Iterator:void <init>(org.apache.kafka.common.record.LazyDownConversionRecords,org.apache.kafka.common.record.Records,long,org.apache.kafka.common.record.ConvertedRecords,org.apache.kafka.common.record.LazyDownConversionRecords$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords:java.util.Iterator iterator(long)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:void reLogin()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:void access$600(org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashSet:void mustAdd(org.apache.kafka.common.utils.ImplicitLinkedHashSet$Element)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.ImplicitLinkedHashSet:boolean add(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:void consumeAbortedTransactionsUpTo(long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.MockConsumer:void pause(java.util.Collection)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:void addPartitionMovementRecord(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair)",
            "org.apache.kafka.clients.producer.internals.IncompleteBatches:void add(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void maybeAddPartitionToTransaction(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void markSequenceUnresolved(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object get(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:void ignore(java.lang.String)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.metrics.Sensor:void checkForest(java.util.Set)",
            "org.apache.kafka.common.network.Selector:void connect(java.lang.String,java.net.InetSocketAddress,int,int)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void mute(org.apache.kafka.common.network.KafkaChannel)",
            "org.apache.kafka.common.protocol.Protocol:void populateSchemaFields(org.apache.kafka.common.protocol.types.Schema,java.util.Set)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:javax.security.sasl.SaslServer createSaslKerberosServer(org.apache.kafka.common.security.auth.AuthenticateCallbackHandler,java.util.Map,javax.security.auth.Subject)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean commit()",
            "org.apache.kafka.common.security.plain.PlainLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.scram.ScramLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Map postProcessParsedConfig(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Properties)",
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.AdminClient create(java.util.Map)",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <init>(java.util.Map)",
            "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Set configNames()",
            "org.apache.kafka.clients.admin.AdminClientConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.clients.CommonClientConfigs:java.util.Map postProcessReconnectBackoffConfigs(org.apache.kafka.common.config.AbstractConfig,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Map postProcessParsedConfig(java.util.Map)",
            "org.apache.kafka.clients.producer.ProducerConfig:java.util.Map postProcessParsedConfig(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Map postProcessParsedConfig(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Set configNames()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerConfig:java.util.Map postProcessParsedConfig(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Map,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(java.util.Properties,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Properties)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map)",
            "org.apache.kafka.clients.producer.ProducerConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.clients.producer.ProducerConfig:java.util.Set configNames()",
            "org.apache.kafka.clients.producer.ProducerConfig:void main(java.lang.String[])",
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.clients.FetchSessionHandler:java.lang.String access$200(org.apache.kafka.clients.FetchSessionHandler,java.util.Collection)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.FetchSessionHandler$Builder:org.apache.kafka.clients.FetchSessionHandler$FetchRequestData build()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$ValidList:java.lang.String toString()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.ProducerRecord:java.lang.String toString()",
            "org.apache.kafka.common.config.AbstractConfig:void <init>(org.apache.kafka.common.config.ConfigDef,java.util.Map,boolean)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String convertToString(java.lang.Object,org.apache.kafka.common.config.ConfigDef$Type)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String getConfigValue(org.apache.kafka.common.config.ConfigDef$ConfigKey,java.lang.String)",
            "org.apache.kafka.common.config.provider.FileConfigProvider:org.apache.kafka.common.config.ConfigData get(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.utils.Utils:java.util.Map propsToStringMap(java.util.Properties)"
        ]
    },
    "org.apache.kafka.common.utils.Utils:java.lang.Object newParameterizedInstance(java.lang.String,java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:java.lang.String clientFirstMessageBare()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] authMessage(org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:java.lang.String toMessage()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void raise(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$RequestFutureCompletionHandler:void fireCompletion()",
            "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onFailure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture$2:void onFailure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void raise(org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture failure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.RequestFutureAdapter:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:boolean errorNext(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:boolean completeNext()"
        ]
    },
    "org.apache.kafka.clients.admin.internals.AdminMetadataManager:void <init>(org.apache.kafka.common.utils.LogContext,long,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.Metadata:void <init>(long,long,boolean,boolean,org.apache.kafka.common.internals.ClusterResourceListeners)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.Metadata:void <init>(long,long,boolean)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:void <init>(boolean,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:void <init>(boolean,org.apache.kafka.clients.producer.Partitioner,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:void <init>()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,java.util.List)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String,org.apache.kafka.common.config.ConfigDef$Recommender)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long maybeDrainPendingCalls(long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void run()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void enqueue(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void call(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void call(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateTopicsResult createTopics(java.util.Collection,org.apache.kafka.clients.admin.CreateTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteTopicsResult deleteTopics(java.util.Collection,org.apache.kafka.clients.admin.DeleteTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListTopicsResult listTopics(org.apache.kafka.clients.admin.ListTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeTopicsResult describeTopics(java.util.Collection,org.apache.kafka.clients.admin.DescribeTopicsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeClusterResult describeCluster(org.apache.kafka.clients.admin.DescribeClusterOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeAclsResult describeAcls(org.apache.kafka.common.acl.AclBindingFilter,org.apache.kafka.clients.admin.DescribeAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConfigsResult describeConfigs(java.util.Collection,org.apache.kafka.clients.admin.DescribeConfigsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeLogDirsResult describeLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreatePartitionsResult createPartitions(java.util.Map,org.apache.kafka.clients.admin.CreatePartitionsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteRecordsResult deleteRecords(java.util.Map,org.apache.kafka.clients.admin.DeleteRecordsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.RenewDelegationTokenResult renewDelegationToken(byte[],org.apache.kafka.clients.admin.RenewDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ExpireDelegationTokenResult expireDelegationToken(byte[],org.apache.kafka.clients.admin.ExpireDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeDelegationTokenResult describeDelegationToken(org.apache.kafka.clients.admin.DescribeDelegationTokenOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeConsumerGroupsResult describeConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DescribeConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups(org.apache.kafka.clients.admin.ListConsumerGroupsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult listConsumerGroupOffsets(java.lang.String,org.apache.kafka.clients.admin.ListConsumerGroupOffsetsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$Call:void fail(long,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:void addWaiter(org.apache.kafka.common.KafkaFuture$BiConsumer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture thenApply(org.apache.kafka.common.KafkaFuture$BaseFunction)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:void copyWith(org.apache.kafka.common.KafkaFuture,org.apache.kafka.common.KafkaFuture$BaseFunction)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture whenComplete(org.apache.kafka.common.KafkaFuture$BiConsumer)",
            "org.apache.kafka.common.internals.KafkaFutureImpl:java.lang.Object get()",
            "org.apache.kafka.common.internals.KafkaFutureImpl:java.lang.Object get(long,java.util.concurrent.TimeUnit)",
            "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture allOf(org.apache.kafka.common.KafkaFuture[])"
        ]
    },
    "org.apache.kafka.common.KafkaFuture:org.apache.kafka.common.KafkaFuture allOf(org.apache.kafka.common.KafkaFuture[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AlterConfigsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.AlterReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.CreateAclsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.CreatePartitionsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteAclsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteRecordsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DeleteTopicsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeConfigsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeTopicsResult:org.apache.kafka.common.KafkaFuture all()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$23:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void <init>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:java.lang.String toHtmlTable(java.lang.String,java.lang.Iterable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:void close(long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:void close()"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.Measurable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void registerMetrics(org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.Measurable)",
            "org.apache.kafka.common.metrics.Metrics:void <init>(org.apache.kafka.common.metrics.MetricConfig,java.util.List,org.apache.kafka.common.utils.Time,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void registerMetrics(org.apache.kafka.common.metrics.Metrics)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser:void registerAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$1600(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.common.TopicPartition,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$1500(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.common.TopicPartition,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.requests.AbstractResponse parseResponse(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.AbstractResponse receiveKafkaResponse()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void reenqueueBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.common.memory.SimpleMemoryPool:void maybeRecordEndOfDrySpell()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.memory.SimpleMemoryPool:java.nio.ByteBuffer tryAllocate(int)",
            "org.apache.kafka.common.memory.SimpleMemoryPool:void release(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void record()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordBatchSplit()",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.common.network.Selector:void register(java.lang.String,java.nio.channels.SocketChannel)",
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)",
            "org.apache.kafka.common.network.Selector:void doClose(org.apache.kafka.common.network.KafkaChannel,boolean)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void addToCompletedReceives(org.apache.kafka.common.network.KafkaChannel,java.util.Deque)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void addToCompletedReceives()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.lang.String,int,int,org.apache.kafka.clients.consumer.internals.Heartbeat,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.lang.String,int,int,int,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,long,boolean)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.lang.String,int,int,org.apache.kafka.clients.consumer.internals.Heartbeat,java.util.List,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,long,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors,boolean,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.lang.String,int,int,org.apache.kafka.clients.consumer.internals.Heartbeat,java.util.List,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,long,boolean,int,org.apache.kafka.clients.consumer.internals.ConsumerInterceptors,boolean,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry,org.apache.kafka.clients.consumer.internals.Fetcher$1)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,int,int,int,int,int,boolean,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry,org.apache.kafka.common.utils.Time,long,long,org.apache.kafka.common.requests.IsolationLevel)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$3900(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,java.lang.String,int,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void <init>(org.apache.kafka.common.utils.LogContext,int,long,org.apache.kafka.common.record.CompressionType,long,long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.ApiVersions,org.apache.kafka.clients.producer.internals.TransactionManager)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.producer.internals.RecordAccumulator,boolean,int,short,int,org.apache.kafka.clients.producer.internals.SenderMetricsRegistry,org.apache.kafka.common.utils.Time,int,long,org.apache.kafka.clients.producer.internals.TransactionManager,org.apache.kafka.clients.ApiVersions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:java.lang.Object getAttribute(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.AttributeList getAttributes(java.lang.String[])"
        ]
    },
    "org.apache.kafka.common.metrics.KafkaMetric:double value()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void <init>(long,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String,org.apache.kafka.common.network.ChannelBuilder,org.apache.kafka.common.utils.LogContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.network.Send write()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean flushNetOutBufferAndUpdateInterestOps()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void send(org.apache.kafka.common.network.Send)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean flushNetOutBufferAndUpdateInterestOps()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.network.Send)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.AbstractResponse)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:java.lang.String handleHandshakeRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.SaslHandshakeRequest)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleApiVersionsRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.ApiVersionsRequest)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:void prepare()"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleApiVersionsRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.ApiVersionsRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse(int,byte)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse defaultApiVersionsResponse()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse(int,byte)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse()"
        ]
    },
    "org.apache.kafka.common.network.PlaintextChannelBuilder$PlaintextAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.security.auth.KafkaPrincipal principal()"
        ]
    },
    "org.apache.kafka.common.network.SslChannelBuilder$SslAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.security.auth.KafkaPrincipal principal()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.security.auth.KafkaPrincipal principal()"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords:java.util.Iterator iterator(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.Records,byte,long,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.common.record.LazyDownConversionRecordsSend:void <init>(java.lang.String,org.apache.kafka.common.record.LazyDownConversionRecords)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin:void access$600(org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin$Refresher:void run()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:void consumeAbortedTransactionsUpTo(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:void addPartitionMovementRecord(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:void movePartition(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.IncompleteBatches:void add(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void maybeAddPartitionToTransaction(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void markSequenceUnresolved(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Object get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Short getShort(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Integer getInt(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Long getLong(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Double getDouble(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getList(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Boolean getBoolean(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.String getString(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.types.Password getPassword(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Class getClass(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:void ignore(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.common.config.AbstractConfig$RecordingMap:java.lang.Object get(java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void checkForest(java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Sensor:void <init>(org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.metrics.Sensor[],org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.utils.Time,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel)",
            "org.apache.kafka.common.metrics.Sensor:void checkForest(java.util.Set)"
        ]
    },
    "org.apache.kafka.common.network.Selector:void mute(org.apache.kafka.common.network.KafkaChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void mute(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void muteAll()"
        ]
    },
    "org.apache.kafka.common.protocol.Protocol:void populateSchemaFields(org.apache.kafka.common.protocol.types.Schema,java.util.Set)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.Protocol:void populateSchemaFields(org.apache.kafka.common.protocol.types.Schema,java.util.Set)",
            "org.apache.kafka.common.protocol.Protocol:void schemaToFieldTableHtml(org.apache.kafka.common.protocol.types.Schema,java.lang.StringBuilder)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.requests.DescribeAclsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.DescribeLogDirsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean commit()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.plain.PlainLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.ScramLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClientConfig:java.util.Set configNames()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.ConsumerConfig:java.util.Set configNames()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.ProducerConfig:java.util.Set configNames()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] authMessage(org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] clientSignature(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)",
            "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] clientProof(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)",
            "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] serverSignature(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:java.lang.String toMessage()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramMessages$AbstractScramMessage:byte[] toBytes()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$CoordinatorResponseHandler:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onFailure(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$3:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture$2:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:void raise(org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onSuccess(org.apache.kafka.clients.ClientResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatResponseHandler:void handle(org.apache.kafka.common.requests.HeartbeatResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$JoinGroupResponseHandler:void handle(org.apache.kafka.common.requests.JoinGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$LeaveGroupResponseHandler:void handle(org.apache.kafka.common.requests.LeaveGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$SyncGroupResponseHandler:void handle(org.apache.kafka.common.requests.SyncGroupResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetFetchResponseHandler:void handle(org.apache.kafka.common.requests.OffsetFetchResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture failure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture onJoinLeader(org.apache.kafka.common.requests.JoinGroupResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetsRequests(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture coordinatorNotAvailable()",
            "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture noBrokersAvailable()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFutureAdapter:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onFailure(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:boolean completeNext()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:void flush()"
        ]
    },
    "org.apache.kafka.clients.Metadata:void <init>(long,long,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String,java.lang.String,int,org.apache.kafka.common.config.ConfigDef$Width,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListTopicsResult listTopics(org.apache.kafka.clients.admin.ListTopicsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.ListTopicsResult listTopics()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeClusterResult describeCluster(org.apache.kafka.clients.admin.DescribeClusterOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeClusterResult describeCluster()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeAclsResult describeAcls(org.apache.kafka.common.acl.AclBindingFilter,org.apache.kafka.clients.admin.DescribeAclsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeAclsResult describeAcls(org.apache.kafka.common.acl.AclBindingFilter)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken(org.apache.kafka.clients.admin.CreateDelegationTokenOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.RenewDelegationTokenResult renewDelegationToken(byte[],org.apache.kafka.clients.admin.RenewDelegationTokenOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.RenewDelegationTokenResult renewDelegationToken(byte[])"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ExpireDelegationTokenResult expireDelegationToken(byte[],org.apache.kafka.clients.admin.ExpireDelegationTokenOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.ExpireDelegationTokenResult expireDelegationToken(byte[])"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeDelegationTokenResult describeDelegationToken(org.apache.kafka.clients.admin.DescribeDelegationTokenOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeDelegationTokenResult describeDelegationToken()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups(org.apache.kafka.clients.admin.ListConsumerGroupsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups()"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult listConsumerGroupOffsets(java.lang.String,org.apache.kafka.clients.admin.ListConsumerGroupOffsetsOptions)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult listConsumerGroupOffsets(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture thenApply(org.apache.kafka.common.KafkaFuture$BaseFunction)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DeleteAclsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeConfigsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.DescribeTopicsResult:org.apache.kafka.common.KafkaFuture all()",
            "org.apache.kafka.clients.admin.ListConsumerGroupsResult:void <init>(org.apache.kafka.common.internals.KafkaFutureImpl)",
            "org.apache.kafka.clients.admin.ListTopicsResult:org.apache.kafka.common.KafkaFuture listings()",
            "org.apache.kafka.clients.admin.ListTopicsResult:org.apache.kafka.common.KafkaFuture names()",
            "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture thenApply(org.apache.kafka.common.KafkaFuture$Function)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:void copyWith(org.apache.kafka.common.KafkaFuture,org.apache.kafka.common.KafkaFuture$BaseFunction)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture whenComplete(org.apache.kafka.common.KafkaFuture$BiConsumer)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:java.lang.Object get()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.DeleteAclsResult$1:java.util.Collection apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConfigsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult$1:java.util.Map apply(java.lang.Void)",
            "org.apache.kafka.clients.admin.DescribeTopicsResult$1:java.util.Map apply(java.lang.Void)"
        ]
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:java.lang.Object get(long,java.util.concurrent.TimeUnit)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AlterConfigsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AlterReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.CreateAclsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.CreatePartitionsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.CreateTopicsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DeleteAclsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DeleteConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DeleteRecordsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DeleteTopicsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeConfigsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeLogDirsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.DescribeTopicsResult:org.apache.kafka.common.KafkaFuture all()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:void addMetric(org.apache.kafka.common.MetricName,org.apache.kafka.common.metrics.Measurable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.Sender,org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void registerAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$1600(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords,int)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void access$1500(org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics,org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.List fetchRecords(org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords,int)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.AbstractResponse receiveKafkaResponse()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveToken()"
        ]
    },
    "org.apache.kafka.common.memory.SimpleMemoryPool:java.nio.ByteBuffer tryAllocate(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.NetworkReceive:long readFrom(java.nio.channels.ScatteringByteChannel)"
        ]
    },
    "org.apache.kafka.common.memory.SimpleMemoryPool:void release(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.NetworkReceive:void close()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordBatchSplit()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,java.lang.String,int,int,int,org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.utils.Time,long,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:void <init>(org.apache.kafka.common.utils.LogContext,org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient,int,int,int,int,int,boolean,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry,org.apache.kafka.common.utils.Time,long,long,org.apache.kafka.common.requests.IsolationLevel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:javax.management.AttributeList getAttributes(java.lang.String[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void send(org.apache.kafka.common.network.Send)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.network.Send)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void sendKafkaResponse(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:java.lang.String handleHandshakeRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.SaslHandshakeRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.requests.ApiVersionsResponse apiVersionsResponse()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleApiVersionsRequest(org.apache.kafka.common.requests.RequestContext,org.apache.kafka.common.requests.ApiVersionsRequest)"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.security.auth.KafkaPrincipal principal()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.LazyDownConversionRecordsSend:void <init>(java.lang.String,org.apache.kafka.common.record.LazyDownConversionRecords)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords:org.apache.kafka.common.record.LazyDownConversionRecordsSend toSend(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin$Refresher:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.common.network.SslTransportLayer:javax.net.ssl.SSLEngineResult$HandshakeStatus runDelegatedTasks()",
            "org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine:void handshake(org.apache.kafka.common.security.ssl.SslFactory$SSLConfigValidatorEngine)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:void movePartition(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:void access$200(org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements,org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Short getShort(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Integer getInt(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)",
            "org.apache.kafka.clients.producer.KafkaProducer:int configureRetries(org.apache.kafka.clients.producer.ProducerConfig,boolean,org.slf4j.Logger)",
            "org.apache.kafka.clients.producer.KafkaProducer:int configureInflightRequests(org.apache.kafka.clients.producer.ProducerConfig,boolean)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Long getLong(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Double getDouble(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.util.List getList(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.List getConfiguredInstances(java.lang.String,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Boolean getBoolean(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.String getString(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.lang.String generateClientId(org.apache.kafka.clients.admin.AdminClientConfig)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.ClientUtils:org.apache.kafka.common.network.ChannelBuilder createChannelBuilder(org.apache.kafka.common.config.AbstractConfig)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)",
            "org.apache.kafka.clients.producer.KafkaProducer:short configureAcks(org.apache.kafka.clients.producer.ProducerConfig,boolean,org.slf4j.Logger)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.types.Password getPassword(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.AbstractConfig:java.lang.Class getClass(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object getConfiguredInstance(java.lang.String,java.lang.Class)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig$RecordingMap:java.lang.Object get(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Config:org.apache.kafka.clients.admin.ConfigEntry get(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List getOrCreateListValue(java.util.Map,java.lang.Object)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.CreateAclsResult createAcls(java.util.Collection,org.apache.kafka.clients.admin.CreateAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteAclsResult deleteAcls(java.util.Collection,org.apache.kafka.clients.admin.DeleteAclsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.AlterReplicaLogDirsResult alterReplicaLogDirs(java.util.Map,org.apache.kafka.clients.admin.AlterReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DescribeReplicaLogDirsResult describeReplicaLogDirs(java.util.Collection,org.apache.kafka.clients.admin.DescribeReplicaLogDirsOptions)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.DeleteConsumerGroupsResult deleteConsumerGroups(java.util.Collection,org.apache.kafka.clients.admin.DeleteConsumerGroupsOptions)",
            "org.apache.kafka.clients.ApiVersions:org.apache.kafka.clients.NodeApiVersions get(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean canConnect(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isBlackedOut(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long connectionDelay(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnecting(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void connecting(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:void throttle(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long throttleDelayMs(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isReady(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isDisconnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.common.errors.AuthenticationException authenticationException(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ClusterConnectionStates$NodeConnectionState nodeState(java.lang.String)",
            "org.apache.kafka.clients.CommonClientConfigs:java.util.Map postProcessReconnectBackoffConfigs(org.apache.kafka.common.config.AbstractConfig,java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.List records(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:void put(java.util.Map,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map fetchedRecords()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.FetchSessionHandler sessionHandler(int)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void addRecord(org.apache.kafka.clients.consumer.ConsumerRecord)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resetOffsetPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionComparator:int compare(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair removeMovementRecordOfPartition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:void addPartitionMovementRecord(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.StickyAssignor$SubscriptionComparator:int compare(java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List sortPartitions(java.util.Map,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.lang.String assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(org.apache.kafka.common.TopicPartition,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void processPartitionMovement(org.apache.kafka.common.TopicPartition,java.lang.String,java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.InFlightRequests:void add(org.apache.kafka.clients.NetworkClient$InFlightRequest)",
            "org.apache.kafka.clients.InFlightRequests:java.util.Deque requestQueue(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean canSendMore(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:int count(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Iterable clearAll(java.lang.String)",
            "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys,short,short)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.common.requests.ApiVersionsResponse$ApiVersion)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.common.requests.ApiVersionsResponse$ApiVersion apiVersion(org.apache.kafka.common.protocol.ApiKeys)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean isMuted(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:java.lang.Integer sequenceNumber(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void incrementSequenceNumber(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void addInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:int firstInFlightSequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.ProducerBatch nextBatchBySequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void removeInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:int lastAckedSequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:long lastAckedOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean hasInflightBatches(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.clients.producer.MockProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:long nextOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.acl.AclOperation:org.apache.kafka.common.acl.AclOperation fromCode(byte)",
            "org.apache.kafka.common.acl.AclPermissionType:org.apache.kafka.common.acl.AclPermissionType fromCode(byte)",
            "org.apache.kafka.common.Cluster:void <init>(java.lang.String,boolean,java.util.Collection,java.util.Collection,java.util.Set,java.util.Set,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node nodeById(int)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node leaderFor(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.PartitionInfo partition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:java.util.List partitionsForTopic(java.lang.String)",
            "org.apache.kafka.common.Cluster:java.lang.Integer partitionCountForTopic(java.lang.String)",
            "org.apache.kafka.common.Cluster:java.util.List availablePartitionsForTopic(java.lang.String)",
            "org.apache.kafka.common.Cluster:java.util.List partitionsForNode(int)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object get(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.ConfigDef$Type typeOf(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef$1:int compare(org.apache.kafka.common.config.ConfigDef$ConfigKey,org.apache.kafka.common.config.ConfigDef$ConfigKey)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:java.lang.String replace(java.util.Map,java.lang.String,java.util.regex.Pattern)",
            "org.apache.kafka.common.ConsumerGroupState:org.apache.kafka.common.ConsumerGroupState parse(java.lang.String)",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:java.lang.Object getAttribute(java.lang.String)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean removeAttribute(org.apache.kafka.common.metrics.KafkaMetric,java.lang.String)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean addAttribute(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createClientCallbackHandler(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:void close(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void close(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.Selector$CloseMode)",
            "org.apache.kafka.common.network.Selector:boolean isChannelReady(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel openOrClosingChannelOrFail(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel channel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel closingChannel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void addToStagedReceives(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.NetworkReceive)",
            "org.apache.kafka.common.network.Selector:int numStagedReceives(org.apache.kafka.common.network.KafkaChannel)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forCode(short)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forException(java.lang.Throwable)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.BoundField get(java.lang.String)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:java.nio.ByteBuffer get(int)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:void release(java.nio.ByteBuffer)",
            "org.apache.kafka.common.requests.AbstractResponse:void updateErrorCounts(java.util.Map,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse$ApiVersion apiVersion(short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:boolean hasError(java.lang.String)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.Errors get(java.lang.String)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:java.util.Collection configNames(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse$Config config(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.List convertToNodes(java.util.Map,java.lang.Object[])",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errors(long)",
            "org.apache.kafka.common.resource.ResourceType:org.apache.kafka.common.resource.ResourceType fromCode(byte)",
            "org.apache.kafka.common.security.auth.SecurityProtocol:org.apache.kafka.common.security.auth.SecurityProtocol forId(short)",
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.security.authenticator.LoginManager:java.lang.Class configuredClassOrDefault(java.util.Map,org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.RequestHeader nextRequestHeader(org.apache.kafka.common.protocol.ApiKeys,short)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void createSaslServer(java.lang.String)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadServerContext(org.apache.kafka.common.network.ListenerName,java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadClientContext(java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:java.lang.String getServiceName(java.util.Map,java.lang.String,javax.security.auth.login.Configuration)",
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:java.lang.String propertyValue(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.String[] mechanismNamesCompatibleWithPolicy(java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object rawClaim(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer$PlainSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)",
            "org.apache.kafka.common.security.plain.PlainLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.scram.internals.ScramExtensions:java.lang.String extensionValue(java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramExtensions:boolean tokenAuthenticated()",
            "org.apache.kafka.common.security.scram.internals.ScramMechanism:org.apache.kafka.common.security.scram.internals.ScramMechanism forMechanismName(java.lang.String)",
            "org.apache.kafka.common.security.scram.ScramLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslFactory$SecurityStore maybeCreateNewKeystore(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslFactory$SecurityStore maybeCreateNewTruststore(java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String owner(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation tokenForHmac(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation token(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.serialization.StringDeserializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.StringSerializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.Map)",
            "org.apache.kafka.common.utils.CollectionUtils:java.util.Map groupDataByTopic(java.util.List)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object get(java.lang.Object)",
            "org.apache.kafka.common.utils.LoggingSignalHandler$1:java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])"
        ]
    },
    "org.apache.kafka.common.metrics.Sensor:void <init>(org.apache.kafka.common.metrics.Metrics,java.lang.String,org.apache.kafka.common.metrics.Sensor[],org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.utils.Time,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.common.network.Selector:void mute(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.requests.DescribeAclsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.requests.DescribeLogDirsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] clientSignature(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:void verifyClientProof(org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] clientProof(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage handleServerFirstMessage(char[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramFormatter:byte[] serverSignature(byte[],org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage,org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:void handleServerFinalMessage(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$AbstractScramMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage:byte[] toBytes()",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:byte[] toBytes()",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFinalMessage:byte[] toBytes()",
            "org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage:byte[] toBytes()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture coordinatorNotAvailable()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.RequestFuture:org.apache.kafka.clients.consumer.internals.RequestFuture noBrokersAvailable()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture lookupCoordinator()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$FindCoordinatorResponseHandler:void onFailure(java.lang.RuntimeException,org.apache.kafka.clients.consumer.internals.RequestFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture$1:void onFailure(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:void flush()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:void commitTransaction()",
            "org.apache.kafka.clients.producer.MockProducer:void abortTransaction()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Validator,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)",
            "org.apache.kafka.common.config.SaslConfigs:void addClientSaslSupport(org.apache.kafka.common.config.ConfigDef)"
        ]
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.ListTopicsResult listTopics()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeClusterResult describeCluster()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeAclsResult describeAcls(org.apache.kafka.common.acl.AclBindingFilter)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.CreateDelegationTokenResult createDelegationToken()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.RenewDelegationTokenResult renewDelegationToken(byte[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.ExpireDelegationTokenResult expireDelegationToken(byte[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.DescribeDelegationTokenResult describeDelegationToken()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.AdminClient:org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult listConsumerGroupOffsets(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.ListConsumerGroupsResult:void <init>(org.apache.kafka.common.internals.KafkaFutureImpl)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.ListConsumerGroupsResult listConsumerGroups(org.apache.kafka.clients.admin.ListConsumerGroupsOptions)"
        ]
    },
    "org.apache.kafka.clients.admin.ListTopicsResult:org.apache.kafka.common.KafkaFuture listings()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.ListTopicsResult:org.apache.kafka.common.KafkaFuture names()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.internals.KafkaFutureImpl:org.apache.kafka.common.KafkaFuture thenApply(org.apache.kafka.common.KafkaFuture$Function)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveToken()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.network.NetworkReceive:long readFrom(java.nio.channels.ScatteringByteChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:long receive(org.apache.kafka.common.network.NetworkReceive)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveResponseOrToken()",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.network.NetworkReceive:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords:org.apache.kafka.common.record.LazyDownConversionRecordsSend toSend(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.LazyDownConversionRecords:org.apache.kafka.common.record.RecordsSend toSend(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:void access$200(org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements,org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void processPartitionMovement(org.apache.kafka.common.TopicPartition,java.lang.String,java.util.Map,java.util.TreeSet,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.internals.TransactionManager configureTransactionState(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.utils.LogContext,org.slf4j.Logger)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:int configureRetries(org.apache.kafka.clients.producer.ProducerConfig,boolean,org.slf4j.Logger)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:int configureInflightRequests(org.apache.kafka.clients.producer.ProducerConfig,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.lang.String generateClientId(org.apache.kafka.clients.admin.AdminClientConfig)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:org.apache.kafka.clients.admin.KafkaAdminClient createInternal(org.apache.kafka.clients.admin.AdminClientConfig,org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.utils.Time)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:short configureAcks(org.apache.kafka.clients.producer.ProducerConfig,boolean,org.slf4j.Logger)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)"
        ]
    },
    "org.apache.kafka.clients.admin.Config:org.apache.kafka.clients.admin.ConfigEntry get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List getOrCreateListValue(java.util.Map,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)"
        ]
    },
    "org.apache.kafka.clients.ApiVersions:org.apache.kafka.clients.NodeApiVersions get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean canConnect(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.NetworkClient:boolean ready(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClient:boolean canConnect(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isBlackedOut(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.Node leastLoadedNode(long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:long connectionDelay(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClusterConnectionStates:long pollDelayMs(java.lang.String,long)",
            "org.apache.kafka.clients.NetworkClient:long connectionDelay(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnecting(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:boolean isAnyNodeConnecting()"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void connecting(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void throttle(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void maybeThrottle(org.apache.kafka.common.requests.AbstractResponse,short,java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:long throttleDelayMs(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClusterConnectionStates:long pollDelayMs(java.lang.String,long)",
            "org.apache.kafka.clients.NetworkClient:long throttleDelayMs(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isReady(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean canSendRequest(java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnected(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClusterConnectionStates:long pollDelayMs(java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:boolean isDisconnected(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:boolean connectionFailed(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.common.errors.AuthenticationException authenticationException(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.errors.AuthenticationException authenticationException(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ClusterConnectionStates$NodeConnectionState nodeState(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClusterConnectionStates:void disconnected(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:void checkingApiVersions(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void ready(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void authenticationFailed(java.lang.String,long,org.apache.kafka.common.errors.AuthenticationException)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ConnectionState connectionState(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.List records(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:void put(java.util.Map,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map consumersPerTopic(java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.FetchSessionHandler sessionHandler(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onFailure(java.lang.RuntimeException)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void addRecord(org.apache.kafka.clients.consumer.ConsumerRecord)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.ConsumerRecords poll(java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:long position(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:void resetOffsetPosition(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionComparator:int compare(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionComparator:int compare(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair removeMovementRecordOfPartition(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:void movePartition(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$SubscriptionComparator:int compare(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor$SubscriptionComparator:int compare(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(org.apache.kafka.common.TopicPartition,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:void processPartitionMovement(org.apache.kafka.common.TopicPartition,java.lang.String,java.util.Map,java.util.TreeSet,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:void add(org.apache.kafka.clients.NetworkClient$InFlightRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long,org.apache.kafka.common.requests.AbstractRequest)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:java.util.Deque requestQueue(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest completeNext(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest lastSent(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest completeLastSent(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:boolean canSendMore(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean canSendRequest(java.lang.String,long)",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:int count(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:int inFlightRequestCount(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.Node leastLoadedNode(long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:boolean isEmpty(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean hasInFlightRequests(java.lang.String)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:java.lang.Iterable clearAll(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys,short,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.common.requests.ApiVersionsResponse$ApiVersion)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.common.requests.ApiVersionsResponse$ApiVersion apiVersion(org.apache.kafka.common.protocol.ApiKeys)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean isMuted(org.apache.kafka.common.TopicPartition,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.List expiredBatches(int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:java.lang.Integer sequenceNumber(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void incrementSequenceNumber(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void addInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:int firstInFlightSequence(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.ProducerBatch nextBatchBySequence(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void insertInSequenceOrder(java.util.Deque,org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void removeInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,long,long,long)",
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)",
            "org.apache.kafka.clients.producer.internals.Sender:void failBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long,long,java.lang.RuntimeException,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:int lastAckedSequence(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void maybeUpdateLastAckedSequence(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean isNextSequence(org.apache.kafka.common.TopicPartition,int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:long lastAckedOffset(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:void updateLastAckedOffset(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean canRetry(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:boolean hasInflightBatches(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:long nextOffset(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.common.acl.AclOperation:org.apache.kafka.common.acl.AclOperation fromCode(byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.acl.AclPermissionType:org.apache.kafka.common.acl.AclPermissionType fromCode(byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node nodeById(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.internals.AdminMetadataManager:org.apache.kafka.common.Node nodeById(int)",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleDisconnection(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node leaderFor(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$ReadyCheckResult ready(org.apache.kafka.common.Cluster,long)"
        ]
    },
    "org.apache.kafka.common.Cluster:org.apache.kafka.common.PartitionInfo partition(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)"
        ]
    },
    "org.apache.kafka.common.Cluster:java.util.List partitionsForTopic(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)",
            "org.apache.kafka.clients.Metadata:org.apache.kafka.common.Cluster getClusterForCurrentTopics(org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.producer.internals.DefaultPartitioner:int partition(java.lang.String,java.lang.Object,byte[],java.lang.Object,byte[],org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.List partitionsFor(java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.clients.producer.MockProducer:java.util.List partitionsFor(java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.Cluster)"
        ]
    },
    "org.apache.kafka.common.Cluster:java.lang.Integer partitionCountForTopic(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:java.util.Map assign(org.apache.kafka.common.Cluster,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$MetadataSnapshot:void <init>(org.apache.kafka.clients.consumer.internals.SubscriptionState,org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.KafkaProducer$ClusterAndWaitTime waitOnMetadata(java.lang.String,java.lang.Integer,long)"
        ]
    },
    "org.apache.kafka.common.Cluster:java.util.List availablePartitionsForTopic(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.DefaultPartitioner:int partition(java.lang.String,java.lang.Object,byte[],java.lang.Object,byte[],org.apache.kafka.common.Cluster)"
        ]
    },
    "org.apache.kafka.common.Cluster:java.util.List partitionsForNode(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)"
        ]
    },
    "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.ConfigDef$Type typeOf(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef$1:int compare(org.apache.kafka.common.config.ConfigDef$ConfigKey,org.apache.kafka.common.config.ConfigDef$ConfigKey)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef$1:int compare(java.lang.Object,java.lang.Object)"
        ]
    },
    "org.apache.kafka.common.config.ConfigTransformer:java.lang.String replace(java.util.Map,java.lang.String,java.util.regex.Pattern)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.ConsumerGroupState:org.apache.kafka.common.ConsumerGroupState parse(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean removeAttribute(org.apache.kafka.common.metrics.KafkaMetric,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.JmxReporter:void metricRemoval(org.apache.kafka.common.metrics.KafkaMetric)"
        ]
    },
    "org.apache.kafka.common.network.SaslChannelBuilder:void createClientCallbackHandler(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.network.Selector:boolean isChannelReady(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean canSendRequest(java.lang.String,long)",
            "org.apache.kafka.clients.NetworkClient:void handleInitiateApiVersionRequests(long)"
        ]
    },
    "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel openOrClosingChannelOrFail(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void send(org.apache.kafka.common.network.Send)",
            "org.apache.kafka.common.network.Selector:void mute(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void unmute(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel channel(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel closingChannel(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void addToStagedReceives(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.NetworkReceive)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void attemptRead(java.nio.channels.SelectionKey,org.apache.kafka.common.network.KafkaChannel)"
        ]
    },
    "org.apache.kafka.common.network.Selector:int numStagedReceives(org.apache.kafka.common.network.KafkaChannel)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forCode(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.HeartbeatResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forException(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiError:org.apache.kafka.common.requests.ApiError fromThrowable(java.lang.Throwable)",
            "org.apache.kafka.common.requests.ApiVersionsRequest:org.apache.kafka.common.requests.ApiVersionsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.requests.ProduceResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.ProduceRequest:java.util.Map errorCounts(java.lang.Throwable)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.requests.StopReplicaResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.BoundField get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object get(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:boolean hasField(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:boolean hasField(org.apache.kafka.common.protocol.types.Field)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(java.lang.String,java.lang.Object)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct instance(java.lang.String)",
            "org.apache.kafka.common.requests.ResponseHeader:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:java.nio.ByteBuffer get(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.KafkaLZ4BlockInputStream:void <init>(java.nio.ByteBuffer,org.apache.kafka.common.record.BufferSupplier,boolean)"
        ]
    },
    "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:void release(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.KafkaLZ4BlockInputStream:void close()"
        ]
    },
    "org.apache.kafka.common.requests.AbstractResponse:void updateErrorCounts(java.util.Map,org.apache.kafka.common.protocol.Errors)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map errorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.AbstractResponse:java.util.Map apiErrorCounts(java.util.Map)",
            "org.apache.kafka.common.requests.CreateAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.FetchResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ListOffsetResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.ProduceResponse:java.util.Map errorCounts()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errorCounts()"
        ]
    },
    "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse$ApiVersion apiVersion(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:boolean hasError(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.Errors get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:java.util.Collection configNames(org.apache.kafka.common.config.ConfigResource)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse$Config config(org.apache.kafka.common.config.ConfigResource)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$9:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataResponse:java.util.List convertToNodes(java.util.Map,java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errors(long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.resource.ResourceType:org.apache.kafka.common.resource.ResourceType fromCode(byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.security.auth.SecurityProtocol:org.apache.kafka.common.security.auth.SecurityProtocol forId(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.LoginManager:java.lang.Class configuredClassOrDefault(java.util.Map,org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.RequestHeader nextRequestHeader(org.apache.kafka.common.protocol.ApiKeys,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:void authenticate()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:boolean sendSaslClientToken(byte[],boolean)"
        ]
    },
    "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadServerContext(org.apache.kafka.common.network.ListenerName,java.lang.String,java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)"
        ]
    },
    "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadClientContext(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshConfig:void <init>(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:java.lang.String propertyValue(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.String[] mechanismNamesCompatibleWithPolicy(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient$OAuthBearerSaslClientFactory:java.lang.String[] getMechanismNames(java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer$OAuthBearerSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object rawClaim(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:boolean isClaimType(java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object claim(java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateClaimForExistenceAndType(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,boolean,java.lang.String,java.lang.Class[])"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String option(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String optionValue(java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String option(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String principalClaimName()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String scopeClaimName()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.util.List requiredScope()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:int allowableClockSkewMs()"
        ]
    },
    "org.apache.kafka.common.security.plain.internals.PlainSaslServer$PlainSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.internals.ScramExtensions:java.lang.String extensionValue(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramExtensions:boolean tokenAuthenticated()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMechanism:org.apache.kafka.common.security.scram.internals.ScramMechanism forMechanismName(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient$ScramSaslClientFactory:javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer$ScramSaslServerFactory:javax.security.sasl.SaslServer createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslFactory$SecurityStore maybeCreateNewKeystore(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:void validateReconfiguration(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void reconfigure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslFactory$SecurityStore maybeCreateNewTruststore(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.ssl.SslFactory:void validateReconfiguration(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void reconfigure(java.util.Map)"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String owner(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramServerCallbackHandler:void handle(javax.security.auth.callback.Callback[])"
        ]
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation tokenForHmac(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation token(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.serialization.StringDeserializer:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.common.serialization.ExtendedDeserializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.serialization.StringSerializer:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.serialization.ExtendedSerializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object get(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.Config:org.apache.kafka.clients.admin.ConfigEntry get(java.lang.String)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$10:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$11:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$12:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$13:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$14:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$15:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$16:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$2:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$21:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24$1:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$24:void handleFailure(java.lang.Throwable)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$4:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$7:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$8:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.List getOrCreateListValue(java.util.Map,java.lang.Object)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:java.util.Map alterConfigs(java.util.Map,org.apache.kafka.clients.admin.AlterConfigsOptions,java.util.Collection,org.apache.kafka.clients.admin.KafkaAdminClient$NodeProvider)",
            "org.apache.kafka.clients.ApiVersions:org.apache.kafka.clients.NodeApiVersions get(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean canConnect(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isBlackedOut(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long connectionDelay(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnecting(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:void connecting(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:void throttle(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:long throttleDelayMs(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isReady(java.lang.String,long)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isConnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:boolean isDisconnected(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.common.errors.AuthenticationException authenticationException(java.lang.String)",
            "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ClusterConnectionStates$NodeConnectionState nodeState(java.lang.String)",
            "org.apache.kafka.clients.CommonClientConfigs:java.util.Map postProcessReconnectBackoffConfigs(org.apache.kafka.common.config.AbstractConfig,java.util.Map)",
            "org.apache.kafka.clients.consumer.ConsumerRecords:java.util.List records(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor:void put(java.util.Map,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$OffsetCommitResponseHandler:void handle(org.apache.kafka.common.requests.OffsetCommitResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void put(org.apache.kafka.common.Node,org.apache.kafka.clients.ClientRequest)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Iterator requestIterator(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onSuccess(org.apache.kafka.clients.ClientResponse)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$2:void onSuccess(org.apache.kafka.clients.consumer.internals.Fetcher$ListOffsetResult)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchResponseMetricAggregator:void record(org.apache.kafka.common.TopicPartition,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:void handleListOffsetResponse(java.util.Map,org.apache.kafka.common.requests.ListOffsetResponse,org.apache.kafka.clients.consumer.internals.RequestFuture)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.FetchSessionHandler sessionHandler(int)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)",
            "org.apache.kafka.clients.consumer.MockConsumer:void subscribe(java.util.regex.Pattern,org.apache.kafka.clients.consumer.ConsumerRebalanceListener)",
            "org.apache.kafka.clients.consumer.MockConsumer:void addRecord(org.apache.kafka.clients.consumer.ConsumerRecord)",
            "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void innerUpdateEndOffsets(java.util.Map,boolean)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map beginningOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:java.util.Map endOffsets(java.util.Collection)",
            "org.apache.kafka.clients.consumer.MockConsumer:void updateFetchPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.MockConsumer:void resetOffsetPosition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.RangeAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.RoundRobinAssignor:java.util.List allPartitionsSorted(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionComparator:int compare(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair removeMovementRecordOfPartition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:void addPartitionMovementRecord(org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.StickyAssignor$ConsumerPair)",
            "org.apache.kafka.clients.consumer.StickyAssignor$PartitionMovements:org.apache.kafka.common.TopicPartition getTheActualPartitionToBeMoved(org.apache.kafka.common.TopicPartition,java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.StickyAssignor$SubscriptionComparator:int compare(java.lang.String,java.lang.String)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.Map assign(java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean isBalanced(java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List sortPartitions(java.util.Map,boolean,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.lang.String assignPartition(org.apache.kafka.common.TopicPartition,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(org.apache.kafka.common.TopicPartition,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean canParticipateInReassignment(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void balance(java.util.Map,java.util.List,java.util.List,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:boolean performReassignments(java.util.List,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void reassignPartition(org.apache.kafka.common.TopicPartition,java.util.Map,java.util.TreeSet,java.util.Map,java.util.Map)",
            "org.apache.kafka.clients.consumer.StickyAssignor:void processPartitionMovement(org.apache.kafka.common.TopicPartition,java.lang.String,java.util.Map,java.util.TreeSet,java.util.Map)",
            "org.apache.kafka.clients.InFlightRequests:void add(org.apache.kafka.clients.NetworkClient$InFlightRequest)",
            "org.apache.kafka.clients.InFlightRequests:java.util.Deque requestQueue(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean canSendMore(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:int count(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:boolean isEmpty(java.lang.String)",
            "org.apache.kafka.clients.InFlightRequests:java.lang.Iterable clearAll(java.lang.String)",
            "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys,short,short)",
            "org.apache.kafka.clients.NodeApiVersions:java.lang.String apiVersionToText(org.apache.kafka.common.requests.ApiVersionsResponse$ApiVersion)",
            "org.apache.kafka.clients.NodeApiVersions:org.apache.kafka.common.requests.ApiVersionsResponse$ApiVersion apiVersion(org.apache.kafka.common.protocol.ApiKeys)",
            "org.apache.kafka.clients.producer.internals.DefaultPartitioner:int nextValue(java.lang.String)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:boolean isMuted(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getDeque(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getOrCreateDeque(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.Sender:void handleProduceResponse(org.apache.kafka.clients.ClientResponse,java.util.Map,long)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:java.lang.Integer sequenceNumber(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void incrementSequenceNumber(org.apache.kafka.common.TopicPartition,int)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void addInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:int firstInFlightSequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:org.apache.kafka.clients.producer.internals.ProducerBatch nextBatchBySequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void removeInFlightBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:int lastAckedSequence(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:long lastAckedOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void adjustSequencesDueToFailedBatch(org.apache.kafka.clients.producer.internals.ProducerBatch)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:void startSequencesAtBeginning(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean hasInflightBatches(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.clients.producer.MockProducer:void sendOffsetsToTransaction(java.util.Map,java.lang.String)",
            "org.apache.kafka.clients.producer.MockProducer:long nextOffset(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node nodeById(int)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.Node leaderFor(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:org.apache.kafka.common.PartitionInfo partition(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.Cluster:java.util.List partitionsForTopic(java.lang.String)",
            "org.apache.kafka.common.Cluster:java.lang.Integer partitionCountForTopic(java.lang.String)",
            "org.apache.kafka.common.Cluster:java.util.List availablePartitionsForTopic(java.lang.String)",
            "org.apache.kafka.common.Cluster:java.util.List partitionsForNode(int)",
            "org.apache.kafka.common.config.AbstractConfig:java.lang.Object get(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:org.apache.kafka.common.config.ConfigDef$Type typeOf(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixOverride(java.lang.String)",
            "org.apache.kafka.common.config.AbstractConfig:java.util.Map valuesWithPrefixAllOrNothing(java.lang.String)",
            "org.apache.kafka.common.config.ConfigDef$1:int compare(org.apache.kafka.common.config.ConfigDef$ConfigKey,org.apache.kafka.common.config.ConfigDef$ConfigKey)",
            "org.apache.kafka.common.config.ConfigDef:java.util.Map parse(java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void parseForValidate(java.lang.String,java.util.Map,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:void validate(java.lang.String,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.config.ConfigDef:java.lang.String toHtmlTable(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:org.apache.kafka.common.config.ConfigTransformerResult transform(java.util.Map)",
            "org.apache.kafka.common.config.ConfigTransformer:java.lang.String replace(java.util.Map,java.lang.String,java.util.regex.Pattern)",
            "org.apache.kafka.common.internals.PartitionStates:void update(java.util.Map)",
            "org.apache.kafka.common.metrics.JmxReporter$KafkaMbean:java.lang.Object getAttribute(java.lang.String)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean removeAttribute(org.apache.kafka.common.metrics.KafkaMetric,java.lang.String)",
            "org.apache.kafka.common.metrics.JmxReporter:org.apache.kafka.common.metrics.JmxReporter$KafkaMbean addAttribute(org.apache.kafka.common.metrics.KafkaMetric)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor getSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])",
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric metric(org.apache.kafka.common.MetricName)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.network.ChannelBuilder create(org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.Mode,org.apache.kafka.common.security.JaasContext$Type,org.apache.kafka.common.config.AbstractConfig,org.apache.kafka.common.network.ListenerName,boolean,java.lang.String,boolean,org.apache.kafka.common.security.authenticator.CredentialCache,org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache)",
            "org.apache.kafka.common.network.ChannelBuilders:org.apache.kafka.common.security.auth.KafkaPrincipalBuilder createPrincipalBuilder(java.util.Map,org.apache.kafka.common.network.TransportLayer,org.apache.kafka.common.network.Authenticator,org.apache.kafka.common.security.kerberos.KerberosShortNamer)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void configure(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:org.apache.kafka.common.network.KafkaChannel buildChannel(java.lang.String,java.nio.channels.SelectionKey,int,org.apache.kafka.common.memory.MemoryPool)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createClientCallbackHandler(java.util.Map)",
            "org.apache.kafka.common.network.SaslChannelBuilder:void createServerCallbackHandlers(java.util.Map)",
            "org.apache.kafka.common.network.Selector:void maybeCloseOldestConnection(long)",
            "org.apache.kafka.common.network.Selector:void clear()",
            "org.apache.kafka.common.network.Selector:void close(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void close(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.Selector$CloseMode)",
            "org.apache.kafka.common.network.Selector:boolean isChannelReady(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel openOrClosingChannelOrFail(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel channel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:org.apache.kafka.common.network.KafkaChannel closingChannel(java.lang.String)",
            "org.apache.kafka.common.network.Selector:void addToStagedReceives(org.apache.kafka.common.network.KafkaChannel,org.apache.kafka.common.network.NetworkReceive)",
            "org.apache.kafka.common.network.Selector:int numStagedReceives(org.apache.kafka.common.network.KafkaChannel)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forCode(short)",
            "org.apache.kafka.common.protocol.Errors:org.apache.kafka.common.protocol.Errors forException(java.lang.Throwable)",
            "org.apache.kafka.common.protocol.types.Schema:org.apache.kafka.common.protocol.types.BoundField get(java.lang.String)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:java.nio.ByteBuffer get(int)",
            "org.apache.kafka.common.record.BufferSupplier$DefaultSupplier:void release(java.nio.ByteBuffer)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:float[] getAndCreateEstimationIfAbsent(java.lang.String)",
            "org.apache.kafka.common.requests.AbstractResponse:void updateErrorCounts(java.util.Map,org.apache.kafka.common.protocol.Errors)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.requests.ApiVersionsResponse$ApiVersion apiVersion(short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:boolean hasError(java.lang.String)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.Errors get(java.lang.String)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:java.util.Collection configNames(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.requests.DescribeConfigsResponse$Config config(org.apache.kafka.common.config.ConfigResource)",
            "org.apache.kafka.common.requests.MetadataResponse:java.util.List convertToNodes(java.util.Map,java.lang.Object[])",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:java.util.Map errors(long)",
            "org.apache.kafka.common.security.auth.SecurityProtocol:org.apache.kafka.common.security.auth.SecurityProtocol forId(short)",
            "org.apache.kafka.common.security.authenticator.LoginManager:org.apache.kafka.common.security.authenticator.LoginManager acquireLoginManager(org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.Class,java.util.Map)",
            "org.apache.kafka.common.security.authenticator.LoginManager:java.lang.Class configuredClassOrDefault(java.util.Map,org.apache.kafka.common.security.JaasContext,java.lang.String,java.lang.String,java.lang.Class)",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.RequestHeader nextRequestHeader(org.apache.kafka.common.protocol.ApiKeys,short)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void <init>(java.util.Map,java.util.Map,java.lang.String,java.util.Map,org.apache.kafka.common.security.kerberos.KerberosShortNamer,org.apache.kafka.common.network.ListenerName,org.apache.kafka.common.security.auth.SecurityProtocol,org.apache.kafka.common.network.TransportLayer)",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void createSaslServer(java.lang.String)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadServerContext(org.apache.kafka.common.network.ListenerName,java.lang.String,java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:org.apache.kafka.common.security.JaasContext loadClientContext(java.util.Map)",
            "org.apache.kafka.common.security.JaasContext:java.lang.String configEntryOption(java.util.List,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:javax.security.auth.login.LoginContext login()",
            "org.apache.kafka.common.security.kerberos.KerberosLogin:java.lang.String getServiceName(java.util.Map,java.lang.String,javax.security.auth.login.Configuration)",
            "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshConfig:void <init>(java.util.Map,boolean)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:void <init>(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse:java.lang.String propertyValue(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:java.lang.String[] mechanismNamesCompatibleWithPolicy(java.util.Map)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object rawClaim(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String option(java.lang.String)",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer$PlainSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)",
            "org.apache.kafka.common.security.plain.PlainLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.scram.internals.ScramExtensions:java.lang.String extensionValue(java.lang.String)",
            "org.apache.kafka.common.security.scram.internals.ScramExtensions:boolean tokenAuthenticated()",
            "org.apache.kafka.common.security.scram.internals.ScramMechanism:org.apache.kafka.common.security.scram.internals.ScramMechanism forMechanismName(java.lang.String)",
            "org.apache.kafka.common.security.scram.ScramLoginModule:void initialize(javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,java.util.Map,java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:void configure(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslFactory$SecurityStore maybeCreateNewKeystore(java.util.Map)",
            "org.apache.kafka.common.security.ssl.SslFactory:org.apache.kafka.common.security.ssl.SslFactory$SecurityStore maybeCreateNewTruststore(java.util.Map)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:java.lang.String owner(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation tokenForHmac(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:org.apache.kafka.common.security.token.delegation.TokenInformation token(java.lang.String)",
            "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache:void updateCredentials(java.lang.String,java.util.Map)",
            "org.apache.kafka.common.serialization.StringDeserializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.StringSerializer:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object get(java.lang.Object)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:boolean remove(java.lang.Object,java.lang.Object)",
            "org.apache.kafka.common.utils.CopyOnWriteMap:boolean replace(java.lang.Object,java.lang.Object,java.lang.Object)",
            "org.apache.kafka.common.utils.LoggingSignalHandler$1:java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])"
        ]
    },
    "org.apache.kafka.common.utils.LoggingSignalHandler$1:java.lang.Object invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslServer:void verifyClientProof(org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslClient:org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage handleServerFirstMessage(char[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslClient:void handleServerFinalMessage(byte[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFinalMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ClientFirstMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFinalMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramMessages$ServerFirstMessage:byte[] toBytes()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map getTopicMetadata(org.apache.kafka.common.requests.MetadataRequest$Builder,long)"
        ]
    },
    "org.apache.kafka.clients.producer.MockProducer:void commitTransaction()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:void abortTransaction()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,java.lang.Object,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()",
            "org.apache.kafka.common.config.SaslConfigs:void addClientSaslSupport(org.apache.kafka.common.config.ConfigDef)",
            "org.apache.kafka.common.config.SslConfigs:void addClientSslSupport(org.apache.kafka.common.config.ConfigDef)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef define(java.lang.String,org.apache.kafka.common.config.ConfigDef$Type,org.apache.kafka.common.config.ConfigDef$Importance,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.config.SaslConfigs:void addClientSaslSupport(org.apache.kafka.common.config.ConfigDef)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef withClientSaslSupport()"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:long receive(org.apache.kafka.common.network.NetworkReceive)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.network.NetworkReceive read()"
        ]
    },
    "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveResponseOrToken()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:byte[] receiveToken()",
            "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator:org.apache.kafka.common.requests.AbstractResponse receiveKafkaResponse()"
        ]
    },
    "org.apache.kafka.common.record.LazyDownConversionRecords:org.apache.kafka.common.record.RecordsSend toSend(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean canConnect(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.Node leastLoadedNode(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$LeastLoadedNodeProvider:org.apache.kafka.common.Node provide()",
            "org.apache.kafka.clients.admin.KafkaAdminClient$MetadataUpdateNodeIdProvider:org.apache.kafka.common.Node provide()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.common.Node leastLoadedNode()",
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long)",
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.Node awaitLeastLoadedNodeReady(long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:long pollDelayMs(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:long pollDelayMs(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:long connectionDelay(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean isUnavailable(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:void maybeThrottle(org.apache.kafka.common.requests.AbstractResponse,short,java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:long throttleDelayMs(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.NetworkClient:boolean canSendRequest(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean isReady(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClient:void doSend(org.apache.kafka.clients.ClientRequest,boolean,long)",
            "org.apache.kafka.clients.NetworkClient:boolean access$500(org.apache.kafka.clients.NetworkClient,java.lang.String,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean connectionFailed(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean isUnavailable(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$connectionFailed__1:boolean test(java.lang.Object)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.errors.AuthenticationException authenticationException(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void handleResponses(long,java.util.List)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void checkDisconnects(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void maybeThrowAuthFailure(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void disconnected(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)",
            "org.apache.kafka.clients.NetworkClient:void initiateConnect(org.apache.kafka.common.Node,long)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void checkingApiVersions(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleConnections()"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void ready(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleApiVersionsResponse(java.util.List,org.apache.kafka.clients.NetworkClient$InFlightRequest,long,org.apache.kafka.common.requests.ApiVersionsResponse)",
            "org.apache.kafka.clients.NetworkClient:void handleConnections()"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:void authenticationFailed(java.lang.String,long,org.apache.kafka.common.errors.AuthenticationException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)"
        ]
    },
    "org.apache.kafka.clients.ClusterConnectionStates:org.apache.kafka.clients.ConnectionState connectionState(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.Fetcher$1:void onFailure(java.lang.RuntimeException)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.RequestFuture:void fireFailure()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:org.apache.kafka.clients.consumer.OffsetAndMetadata committed(org.apache.kafka.common.TopicPartition,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:java.util.List partitionsFor(java.lang.String,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.MockConsumer:long position(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.MockConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$PartitionComparator:int compare(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.StickyAssignor$SubscriptionComparator:int compare(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest completeNext(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedReceives(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest lastSent(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.InFlightRequests:org.apache.kafka.clients.NetworkClient$InFlightRequest completeLastSent(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void handleCompletedSends(java.util.List,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:int inFlightRequestCount(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean hasInFlightRequests(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.NodeApiVersions:short latestUsableVersion(org.apache.kafka.common.protocol.ApiKeys)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ApiVersions:byte computeMaxUsableProduceMagic()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void insertInSequenceOrder(java.util.Deque,org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void reenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void maybeUpdateLastAckedSequence(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:boolean isNextSequence(org.apache.kafka.common.TopicPartition,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean shouldResetProducerStateAfterResolvingSequences()",
            "org.apache.kafka.clients.producer.internals.TransactionManager:boolean canRetry(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.TransactionManager:void updateLastAckedOffset(org.apache.kafka.common.requests.ProduceResponse$PartitionResponse,org.apache.kafka.clients.producer.internals.ProducerBatch)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void completeBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,org.apache.kafka.common.requests.ProduceResponse$PartitionResponse)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:org.apache.kafka.common.requests.CreateAclsRequest$AclCreation fromStruct(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.clients.admin.internals.AdminMetadataManager:org.apache.kafka.common.Node nodeById(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ConstantNodeIdProvider:org.apache.kafka.common.Node provide()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:void handleDisconnection(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:void disconnect(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void close(java.lang.String)",
            "org.apache.kafka.clients.NetworkClient:void processDisconnection(java.util.List,java.lang.String,long,org.apache.kafka.common.network.ChannelState)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.DefaultPartitioner:int partition(java.lang.String,java.lang.Object,byte[],java.lang.Object,byte[],org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,byte[],byte[],org.apache.kafka.common.Cluster)",
            "org.apache.kafka.clients.producer.MockProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.Cluster)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:java.util.List partitionsFor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:java.util.List partitionsFor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.producer.MockProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.MockProducer:java.util.concurrent.Future send(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:org.apache.kafka.clients.producer.KafkaProducer$ClusterAndWaitTime waitOnMetadata(java.lang.String,java.lang.Integer,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.List partitionsFor(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef$1:int compare(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void unmute(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.network.Selector:void attemptRead(java.nio.channels.SelectionKey,org.apache.kafka.common.network.KafkaChannel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void pollSelectionKeys(java.util.Set,boolean,long)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.requests.AddOffsetsToTxnResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.requests.AddPartitionsToTxnResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.requests.AlterReplicaLogDirsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.requests.ControlledShutdownResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.requests.DeleteGroupsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.requests.DeleteRecordsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.requests.DeleteTopicsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.requests.DescribeDelegationTokenResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.requests.DescribeLogDirsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.requests.EndTxnResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.requests.ExpireDelegationTokenResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.requests.FindCoordinatorResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.requests.HeartbeatResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.requests.InitProducerIdResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.requests.JoinGroupResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.requests.LeaderAndIsrResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.requests.LeaveGroupResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.requests.ListGroupsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.requests.ListOffsetResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.requests.OffsetCommitResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.requests.OffsetFetchResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.requests.ProduceResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.requests.RenewDelegationTokenResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.requests.SaslAuthenticateResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.requests.SaslHandshakeResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.requests.StopReplicaResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.requests.SyncGroupResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.requests.TxnOffsetCommitResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.requests.UpdateMetadataResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.requests.WriteTxnMarkersResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:org.apache.kafka.common.requests.ApiError fromThrowable(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void addError(java.lang.Throwable,org.apache.kafka.common.Node)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.ListGroupsResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ProduceRequest:java.util.Map errorCounts(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Object get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct getStruct(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:byte getByte(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.record.BaseRecords getRecords(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getShort(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getInt(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getUnsignedInt(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getLong(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getArray(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getString(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Boolean getBoolean(java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.nio.ByteBuffer getBytes(java.lang.String)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:boolean hasField(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getOrElse(org.apache.kafka.common.protocol.types.Field$Int64,long)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getOrElse(org.apache.kafka.common.protocol.types.Field$Int16,short)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte getOrElse(org.apache.kafka.common.protocol.types.Field$Int8,byte)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getOrElse(org.apache.kafka.common.protocol.types.Field$Int32,int)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:boolean hasField(org.apache.kafka.common.protocol.types.Field)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:void <clinit>()",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.nio.ByteBuffer serializeTopicPartitionAssignment(java.util.List)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int8,byte)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int32,int)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int64,long)",
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int16,short)",
            "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.protocol.types.Struct recordKey()",
            "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.protocol.types.Struct buildRecordValue()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(java.lang.String,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(org.apache.kafka.common.protocol.types.Field,java.lang.Object)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct instance(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.common.protocol.Protocol:java.lang.String toHtml()",
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.ResponseHeader toResponseHeader()",
            "org.apache.kafka.common.requests.ResponseHeader:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ResponseHeader:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ResponseHeader:org.apache.kafka.common.requests.ResponseHeader parse(java.nio.ByteBuffer)",
            "org.apache.kafka.common.requests.ResponseHeader:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.record.KafkaLZ4BlockInputStream:void <init>(java.nio.ByteBuffer,org.apache.kafka.common.record.BufferSupplier,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.CompressionType$4:java.io.InputStream wrapForInput(java.nio.ByteBuffer,byte,org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.record.KafkaLZ4BlockInputStream:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.ClientUtils:void closeQuietly(java.io.Closeable,java.lang.String,java.util.concurrent.atomic.AtomicReference)",
            "org.apache.kafka.common.utils.AppInfoParser:void <clinit>()",
            "org.apache.kafka.common.utils.Utils:void closeAll(java.io.Closeable[])",
            "org.apache.kafka.common.utils.Utils:void closeQuietly(java.lang.AutoCloseable,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:org.apache.kafka.common.requests.CreateAclsRequest$AclCreation fromStruct(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerRefreshingLogin:void configure(java.util.Map,java.lang.String,javax.security.auth.login.Configuration,org.apache.kafka.common.security.auth.AuthenticateCallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.LoginManager:void <init>(org.apache.kafka.common.security.JaasContext,java.lang.String,java.util.Map,org.apache.kafka.common.security.authenticator.LoginManager$LoginMetadata)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient$OAuthBearerSaslClientFactory:java.lang.String[] getMechanismNames(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient$OAuthBearerSaslClientFactory:javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer$OAuthBearerSaslServerFactory:java.lang.String[] getMechanismNames(java.util.Map)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer$OAuthBearerSaslServerFactory:javax.security.sasl.SaslServer createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:boolean isClaimType(java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Object claim(java.lang.String,java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Number expirationTime()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Number issuedAt()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.String subject()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Long calculateStartTimeMs()",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.util.Set calculateScope()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateClaimForExistenceAndType(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,boolean,java.lang.String,java.lang.Class[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String optionValue(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String optionValue(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String principalClaimName()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.lang.String scopeClaimName()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:java.util.List requiredScope()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:int allowableClockSkewMs()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslServer:java.lang.Object getNegotiatedProperty(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:org.apache.kafka.common.security.auth.KafkaPrincipal principal()"
        ]
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslClient$ScramSaslClientFactory:javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.internals.ScramSaslServer$ScramSaslServerFactory:javax.security.sasl.SaslServer createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.scram.internals.ScramServerCallbackHandler:void handle(javax.security.auth.callback.Callback[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer:byte[] process(java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule:boolean login()",
            "org.apache.kafka.common.security.plain.internals.PlainSaslServer:byte[] evaluateResponse(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslClient:byte[] evaluateChallenge(byte[])",
            "org.apache.kafka.common.security.scram.internals.ScramSaslServer:byte[] evaluateResponse(byte[])"
        ]
    },
    "org.apache.kafka.common.serialization.ExtendedDeserializer$Wrapper:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.common.serialization.ExtendedDeserializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.serialization.ExtendedSerializer$Wrapper:void configure(java.util.Map,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.common.serialization.ExtendedSerializer$Wrapper:void configure(java.util.Map,boolean)",
            "org.apache.kafka.common.serialization.Serdes$WrapperSerde:void configure(java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:void put(org.apache.kafka.common.Node,org.apache.kafka.clients.ClientRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.clients.consumer.internals.RequestFuture send(org.apache.kafka.common.Node,org.apache.kafka.common.requests.AbstractRequest$Builder,int)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:int requestCount(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:boolean hasRequests(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests(org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient$UnsentRequests:java.util.Iterator requestIterator(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.DefaultPartitioner:int nextValue(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.DefaultPartitioner:int partition(java.lang.String,java.lang.Object,byte[],java.lang.Object,byte[],org.apache.kafka.common.Cluster)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getDeque(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortBatches(java.lang.RuntimeException)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void abortUndrainedBatches(java.lang.RuntimeException)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getOrCreateDeque(org.apache.kafka.common.TopicPartition)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void reenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch,long)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor getSensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:org.apache.kafka.common.metrics.Sensor getSensor(java.lang.String)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesSent(java.lang.String,long)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void recordBytesReceived(java.lang.String,int)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.KafkaMetric metric(org.apache.kafka.common.MetricName)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:float[] getAndCreateEstimationIfAbsent(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.CompressionRatioEstimator:float updateEstimation(java.lang.String,org.apache.kafka.common.record.CompressionType,float)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:float estimation(java.lang.String,org.apache.kafka.common.record.CompressionType)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:void resetEstimation(java.lang.String)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:void setEstimation(java.lang.String,org.apache.kafka.common.record.CompressionType,float)"
        ]
    },
    "org.apache.kafka.common.utils.CopyOnWriteMap:java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.DefaultPartitioner:int nextValue(java.lang.String)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Deque getOrCreateDeque(org.apache.kafka.common.TopicPartition)",
            "org.apache.kafka.common.record.CompressionRatioEstimator:float[] getAndCreateEstimationIfAbsent(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.utils.CopyOnWriteMap:boolean remove(java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:void removeSensor(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.utils.CopyOnWriteMap:boolean replace(java.lang.Object,java.lang.Object,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor$RecordingLevel)",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])",
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,long,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.SslConfigs:void addClientSslSupport(org.apache.kafka.common.config.ConfigDef)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef withClientSslSupport()"
        ]
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef withClientSaslSupport()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.network.KafkaChannel:org.apache.kafka.common.network.NetworkReceive read()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector:void attemptRead(java.nio.channels.SelectionKey,org.apache.kafka.common.network.KafkaChannel)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$LeastLoadedNodeProvider:org.apache.kafka.common.Node provide()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$MetadataUpdateNodeIdProvider:org.apache.kafka.common.Node provide()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.common.Node leastLoadedNode()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture lookupCoordinator()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:long pollDelayMs(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:long sendEligibleCalls(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:long trySend(long)",
            "org.apache.kafka.clients.producer.internals.Sender:long sendProducerData(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean isUnavailable(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.common.Node checkAndGetCoordinator()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean isReady(org.apache.kafka.common.Node,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:boolean ready(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.Node leastLoadedNode(long)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean isReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.NetworkClientUtils:boolean awaitReady(org.apache.kafka.clients.KafkaClient,org.apache.kafka.common.Node,org.apache.kafka.common.utils.Time,long)"
        ]
    },
    "org.apache.kafka.clients.NetworkClient:boolean access$500(org.apache.kafka.clients.NetworkClient,java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient$DefaultMetadataUpdater:long maybeUpdate(long,org.apache.kafka.common.Node)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable$connectionFailed__1:boolean test(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:void unassignUnsentCalls(java.util.function.Predicate)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:void maybeThrowAuthFailure(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map groupListOffsetRequests(java.util.Map,java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.consumer.MockConsumer:long position(org.apache.kafka.common.TopicPartition,java.time.Duration)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:int pendingRequestCount(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(long)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean hasPendingRequests(org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:boolean awaitPendingRequests(org.apache.kafka.common.Node,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:java.util.Map prepareFetchRequests()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.RecordAccumulator:void reenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender:void reenqueueBatch(org.apache.kafka.clients.producer.internals.ProducerBatch,long)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:org.apache.kafka.common.requests.CreateAclsRequest$AclCreation fromStruct(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.requests.DeleteAclsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.DeleteAclsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.DescribeAclsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ConstantNodeIdProvider:org.apache.kafka.common.Node provide()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable:boolean maybeDrainPendingCall(org.apache.kafka.clients.admin.KafkaAdminClient$Call,long)"
        ]
    },
    "org.apache.kafka.clients.producer.KafkaProducer:int partition(org.apache.kafka.clients.producer.ProducerRecord,byte[],byte[],org.apache.kafka.common.Cluster)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.requests.AddOffsetsToTxnResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.requests.AddPartitionsToTxnResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.requests.AlterReplicaLogDirsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.requests.AlterConfigsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.requests.CreateAclsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.requests.CreatePartitionsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:org.apache.kafka.common.requests.AbstractResponse parseResponse(org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.requests.CreateTopicsResponse parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.requests.ControlledShutdownResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.requests.CreateDelegationTokenResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.requests.DeleteGroupsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.requests.DeleteRecordsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.requests.DeleteTopicsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.requests.DescribeDelegationTokenResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.requests.DescribeGroupsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.requests.DescribeLogDirsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.requests.EndTxnResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.requests.ExpireDelegationTokenResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.requests.FindCoordinatorResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.requests.HeartbeatResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.requests.InitProducerIdResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.requests.JoinGroupResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.requests.LeaderAndIsrResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.requests.LeaveGroupResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.requests.ListGroupsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.requests.ListOffsetResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.requests.OffsetCommitResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.requests.OffsetFetchResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.requests.ProduceResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.requests.RenewDelegationTokenResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.requests.SaslAuthenticateResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.requests.SaslHandshakeResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.requests.StopReplicaResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.requests.SyncGroupResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.requests.TxnOffsetCommitResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.requests.UpdateMetadataResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.requests.WriteTxnMarkersResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.clients.admin.KafkaAdminClient$ListConsumerGroupsResults:void addError(java.lang.Throwable,org.apache.kafka.common.Node)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.admin.KafkaAdminClient$22$1:void handleFailure(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.requests.ListGroupsRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(int,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractResponse getErrorResponse(java.lang.Throwable)",
            "org.apache.kafka.common.requests.AbstractRequest:java.util.Map errorCounts(java.lang.Throwable)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct getStruct(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:byte getByte(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte get(org.apache.kafka.common.protocol.types.Field$Int8)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte getOrElse(org.apache.kafka.common.protocol.types.Field$Int8,byte)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.record.BaseRecords getRecords(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addPartitionData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getShort(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Short get(org.apache.kafka.common.protocol.types.Field$Int16)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getOrElse(org.apache.kafka.common.protocol.types.Field$Int16,short)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getInt(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer get(org.apache.kafka.common.protocol.types.Field$Int32)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getOrElse(org.apache.kafka.common.protocol.types.Field$Int32,int)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getUnsignedInt(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getLong(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long get(org.apache.kafka.common.protocol.types.Field$Int64)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getOrElse(org.apache.kafka.common.protocol.types.Field$Int64,long)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Object[] getArray(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List deserializeTopicPartitionAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.StopReplicaResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String getString(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List deserializeTopicPartitionAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String get(org.apache.kafka.common.protocol.types.Field$Str)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String get(org.apache.kafka.common.protocol.types.Field$NullableStr)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)",
            "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Boolean getBoolean(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.nio.ByteBuffer getBytes(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Long getOrElse(org.apache.kafka.common.protocol.types.Field$Int64,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Short getOrElse(org.apache.kafka.common.protocol.types.Field$Int16,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte getOrElse(org.apache.kafka.common.protocol.types.Field$Int8,byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer getOrElse(org.apache.kafka.common.protocol.types.Field$Int32,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.HeartbeatResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String getOrElse(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.CreateTopicsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.FetchRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.FindCoordinatorRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.JoinGroupRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.ListOffsetRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.MetadataRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestHeader:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.RequestHeader parse(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.List metadata()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.List metadata()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeSubscription(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:java.nio.ByteBuffer serializeAssignment(org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment)",
            "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Str,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternSetStructFields(org.apache.kafka.common.resource.ResourcePattern,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceSetStructFields(org.apache.kafka.common.acl.AccessControlEntry,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$NullableStr,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternFilterSetStructFields(org.apache.kafka.common.resource.ResourcePatternFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceFilterSetStructFields(org.apache.kafka.common.acl.AccessControlEntryFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int8,byte)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternSetStructFields(org.apache.kafka.common.resource.ResourcePattern,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternFilterSetStructFields(org.apache.kafka.common.resource.ResourcePatternFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceSetStructFields(org.apache.kafka.common.acl.AccessControlEntry,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void aceFilterSetStructFields(org.apache.kafka.common.acl.AccessControlEntryFilter,org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int32,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.StopReplicaRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int64,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct set(org.apache.kafka.common.protocol.types.Field$Int16,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ApiError:void write(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.StopReplicaResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.record.ControlRecordType:org.apache.kafka.common.protocol.types.Struct recordKey()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendControlRecord(long,org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.record.EndTransactionMarker:org.apache.kafka.common.protocol.types.Struct buildRecordValue()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.EndTransactionMarker:java.nio.ByteBuffer serializeValue()"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:org.apache.kafka.common.protocol.types.Struct setIfExists(org.apache.kafka.common.protocol.types.Field,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ApiError:void write(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short,int,org.apache.kafka.common.protocol.Errors,java.util.Iterator,int)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.MetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.OffsetCommitResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.ProduceRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.ProduceResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternSetStructFields(org.apache.kafka.common.resource.ResourcePattern,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:void resourcePatternFilterSetStructFields(org.apache.kafka.common.resource.ResourcePatternFilter,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.ResponseHeader toResponseHeader()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestContext:org.apache.kafka.common.network.Send buildResponse(org.apache.kafka.common.requests.AbstractResponse)"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:void <init>(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.ResponseHeader:org.apache.kafka.common.requests.ResponseHeader parse(java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.network.Send toSend(java.lang.String,org.apache.kafka.common.requests.ResponseHeader,short)",
            "org.apache.kafka.common.requests.ResponseHeader:int sizeOf()"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:org.apache.kafka.common.requests.ResponseHeader parse(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)"
        ]
    },
    "org.apache.kafka.common.record.CompressionType$4:java.io.InputStream wrapForInput(java.nio.ByteBuffer,byte,org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.AbstractLegacyRecordBatch$DeepRecordsIterator:void <init>(org.apache.kafka.common.record.AbstractLegacyRecordBatch,boolean,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator compressedIterator(org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient:void <init>(org.apache.kafka.clients.admin.AdminClientConfig,java.lang.String,org.apache.kafka.common.utils.Time,org.apache.kafka.clients.admin.internals.AdminMetadataManager,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.KafkaClient,org.apache.kafka.clients.admin.KafkaAdminClient$TimeoutProcessorFactory,org.apache.kafka.common.utils.LogContext)",
            "org.apache.kafka.clients.admin.KafkaAdminClient:void close(long,java.util.concurrent.TimeUnit)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void <init>(org.apache.kafka.clients.consumer.ConsumerConfig,org.apache.kafka.common.serialization.Deserializer,org.apache.kafka.common.serialization.Deserializer)",
            "org.apache.kafka.clients.consumer.KafkaConsumer:void close(long,boolean)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.clients.producer.KafkaProducer:void close(long,java.util.concurrent.TimeUnit,boolean)",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>()",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getVersion()",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getCommitId()",
            "org.apache.kafka.common.utils.AppInfoParser:java.lang.String getVersion()",
            "org.apache.kafka.common.utils.AppInfoParser:java.lang.String getCommitId()",
            "org.apache.kafka.common.utils.AppInfoParser:void registerAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)",
            "org.apache.kafka.common.utils.AppInfoParser:void unregisterAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)",
            "org.apache.kafka.common.utils.AppInfoParser:void registerMetrics(org.apache.kafka.common.metrics.Metrics)",
            "org.apache.kafka.common.utils.AppInfoParser:void unregisterMetrics(org.apache.kafka.common.metrics.Metrics)",
            "org.apache.kafka.common.utils.AppInfoParser:org.slf4j.Logger access$000()",
            "org.apache.kafka.common.utils.AppInfoParser:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataRequest:org.apache.kafka.common.requests.UpdateMetadataRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClient$OAuthBearerSaslClientFactory:javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslServer$OAuthBearerSaslServerFactory:javax.security.sasl.SaslServer createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Number expirationTime()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateExpirationTime(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,long,int)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateTimeConsistency(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Number issuedAt()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateIssuedAt(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,boolean,long,int)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateTimeConsistency(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.String subject()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:java.lang.Long calculateStartTimeMs()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws:void <init>(java.lang.String,java.lang.String,java.lang.String)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String optionValue(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerTokenCallback)",
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler:java.lang.String commaPrependedStringNumberAndListClaimsJsonText()"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.clients.consumer.internals.RequestFuture send(org.apache.kafka.common.Node,org.apache.kafka.common.requests.AbstractRequest$Builder,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()",
            "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.clients.consumer.internals.RequestFuture send(org.apache.kafka.common.Node,org.apache.kafka.common.requests.AbstractRequest$Builder)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:org.apache.kafka.common.metrics.Sensor getSensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void updateProduceRequestMetrics(java.util.Map)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordRetries(java.lang.String,int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordErrors(java.lang.String,int)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void recordLatency(java.lang.String,long)"
        ]
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:float updateEstimation(java.lang.String,org.apache.kafka.common.record.CompressionType,float)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void close()"
        ]
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:float estimation(java.lang.String,org.apache.kafka.common.record.CompressionType)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecordsBuilder,long,boolean)"
        ]
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:void resetEstimation(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.CompressionRatioEstimator:void setEstimation(java.lang.String,org.apache.kafka.common.record.CompressionType,float)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:int splitAndReenqueue(org.apache.kafka.clients.producer.internals.ProducerBatch)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor$RecordingLevel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor$RecordingLevel,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.MetricConfig,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.config.ConfigDef:org.apache.kafka.common.config.ConfigDef withClientSslSupport()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.AdminClientConfig:void <clinit>()",
            "org.apache.kafka.clients.consumer.ConsumerConfig:void <clinit>()",
            "org.apache.kafka.clients.producer.ProducerConfig:void <clinit>()"
        ]
    },
    "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.common.Node checkAndGetCoordinator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean coordinatorUnknown()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void close(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.CreateAclsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.requests.DeleteAclsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.requests.DeleteAclsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.requests.DescribeAclsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.requests.AlterConfigsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.requests.CreateAclsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.requests.CreatePartitionsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.requests.CreateTopicsResponse parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.CreatePartitionsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Byte get(org.apache.kafka.common.protocol.types.Field$Int8)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AlterConfigsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Subscription deserializeSubscription(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:java.util.Map performAssignment(java.lang.String,java.lang.String,java.util.Map)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerProtocol:org.apache.kafka.clients.consumer.internals.PartitionAssignor$Assignment deserializeAssignment(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.admin.KafkaAdminClient$21$1:void handleResponse(org.apache.kafka.common.requests.AbstractResponse)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void onJoinComplete(int,java.lang.String,java.lang.String,java.nio.ByteBuffer)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Short get(org.apache.kafka.common.protocol.types.Field$Int16)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiError:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ApiVersionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.FindCoordinatorResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.HeartbeatResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaveGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RenewDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslHandshakeResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.UpdateMetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Integer get(org.apache.kafka.common.protocol.types.Field$Int32)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.NetworkClient:org.apache.kafka.common.protocol.types.Struct parseStructMaybeUpdateThrottleTimeMetrics(java.nio.ByteBuffer,org.apache.kafka.common.requests.RequestHeader,org.apache.kafka.common.metrics.Sensor,long)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addResponseData(org.apache.kafka.common.protocol.types.Struct,int,java.lang.String,java.util.Queue)",
            "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.StopReplicaResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.DeleteRecordsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.DeleteTopicsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.InitProducerIdRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.Long get(org.apache.kafka.common.protocol.types.Field$Int64)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.InitProducerIdResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.CreateDelegationTokenRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.ExpireDelegationTokenRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.RenewDelegationTokenRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.clients.consumer.StickyAssignor:java.util.List deserializeTopicPartitionAssignment(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.StickyAssignor:void prepopulateCurrentAssignments(java.util.Map,java.util.Map)"
        ]
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.DeleteGroupsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.requests.DescribeDelegationTokenRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.DescribeGroupsRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.SyncGroupRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String get(org.apache.kafka.common.protocol.types.Field$Str)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AddPartitionsToTxnResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.AlterReplicaLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ControlledShutdownResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreatePartitionsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.CreateTopicsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteRecordsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DeleteRecordsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteTopicsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeDelegationTokenResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DescribeLogDirsRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.DescribeLogDirsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.FetchResponse:org.apache.kafka.common.requests.FetchResponse parse(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FetchResponse:void addTopicData(java.lang.String,java.util.Queue,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.FindCoordinatorRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.JoinGroupResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaderAndIsrRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.LeaderAndIsrResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListGroupsResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ListOffsetRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ListOffsetResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.MetadataResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetFetchRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetFetchResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.ProduceRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.ProduceResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePattern resourcePatternromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntry aceFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.StopReplicaRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.StopReplicaResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SyncGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.TxnOffsetCommitResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.UpdateMetadataRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.WriteTxnMarkersResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.protocol.types.Struct:java.lang.String get(org.apache.kafka.common.protocol.types.Field$NullableStr)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.InitProducerIdRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.resource.ResourcePatternFilter resourcePatternFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.RequestUtils:org.apache.kafka.common.acl.AccessControlEntryFilter aceFilterFromStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslAuthenticateResponse:void <init>(org.apache.kafka.common.protocol.types.Struct)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.SaslHandshakeRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.SaslAuthenticateRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.CreateTopicsRequest:org.apache.kafka.common.requests.CreateTopicsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeConfigsRequest:org.apache.kafka.common.requests.DescribeConfigsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FetchRequest:org.apache.kafka.common.requests.FetchRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.FindCoordinatorRequest:org.apache.kafka.common.requests.FindCoordinatorRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.JoinGroupRequest:org.apache.kafka.common.requests.JoinGroupRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaderAndIsrRequest:org.apache.kafka.common.requests.LeaderAndIsrRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ListOffsetRequest:org.apache.kafka.common.requests.ListOffsetRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.MetadataRequest:org.apache.kafka.common.requests.MetadataRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetCommitRequest:org.apache.kafka.common.requests.OffsetCommitRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.RequestHeader:org.apache.kafka.common.requests.RequestHeader parse(java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:void handleSaslToken(byte[])",
            "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator:boolean handleKafkaRequest(byte[])"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:void resourcePatternSetStructFields(org.apache.kafka.common.resource.ResourcePattern,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:void setStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:void aceSetStructFields(org.apache.kafka.common.acl.AccessControlEntry,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:void setStructFields(org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:void resourcePatternFilterSetStructFields(org.apache.kafka.common.resource.ResourcePatternFilter,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.RequestUtils:void aceFilterSetStructFields(org.apache.kafka.common.acl.AccessControlEntryFilter,org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.DeleteAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()",
            "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.EndTxnResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.InitProducerIdResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.ApiError:void write(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AlterConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreatePartitionsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.CreateTopicsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DeleteAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeAclsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)",
            "org.apache.kafka.common.requests.DescribeConfigsResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)"
        ]
    },
    "org.apache.kafka.common.requests.HeartbeatResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.LeaveGroupResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.requests.UpdateMetadataResponse:org.apache.kafka.common.protocol.types.Struct toStruct(short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractResponse:java.nio.ByteBuffer serialize(short,org.apache.kafka.common.requests.ResponseHeader)",
            "org.apache.kafka.common.requests.AbstractResponse:java.lang.String toString(short)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendControlRecord(long,org.apache.kafka.common.record.ControlRecordType,java.nio.ByteBuffer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendEndTxnMarker(long,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.record.EndTransactionMarker:java.nio.ByteBuffer serializeValue()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendEndTxnMarker(long,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.requests.ResponseHeader:int sizeOf()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator compressedIterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.DefaultRecordBatch:java.util.Iterator iterator()",
            "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser:void registerAppInfo(java.lang.String,java.lang.String,org.apache.kafka.common.metrics.Metrics)"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getVersion()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getCommitId()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.utils.AppInfoParser:java.lang.String getVersion()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>()",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getVersion()"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:java.lang.String getCommitId()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>()",
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:java.lang.String getCommitId()"
        ]
    },
    "org.apache.kafka.common.utils.AppInfoParser:org.slf4j.Logger access$000()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.utils.AppInfoParser$AppInfo:void <init>()"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateExpirationTime(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,long,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateTimeConsistency(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils:org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult validateIssuedAt(org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws,boolean,long,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredValidatorCallbackHandler:void handleCallback(org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallback)"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient:org.apache.kafka.clients.consumer.internals.RequestFuture send(org.apache.kafka.common.Node,org.apache.kafka.common.requests.AbstractRequest$Builder)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendFindCoordinatorRequest(org.apache.kafka.common.Node)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void maybeLeaveGroup()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendHeartbeatRequest()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetCommitRequest(java.util.Map)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendOffsetFetchRequest(java.util.Set)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:int sendFetches()",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendMetadataRequest(org.apache.kafka.common.requests.MetadataRequest$Builder)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.clients.consumer.internals.RequestFuture sendListOffsetRequest(org.apache.kafka.common.Node,java.util.Map,boolean)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void close()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:java.util.Map drain(org.apache.kafka.common.Cluster,java.util.Set,int,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecordsBuilder,long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecordsBuilder,long)",
            "org.apache.kafka.clients.producer.internals.ProducerBatch:org.apache.kafka.clients.producer.internals.ProducerBatch createBatchOffAccumulatorForRecord(org.apache.kafka.common.record.Record,int)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$GroupCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.AbstractCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator$ConsumerCoordinatorMetrics:void <init>(org.apache.kafka.clients.consumer.internals.ConsumerCoordinator,org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void <init>(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordTopicFetchMetrics(java.lang.String,int,int)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLead(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher$FetchManagerMetrics:void recordPartitionLag(org.apache.kafka.common.TopicPartition,long)",
            "org.apache.kafka.clients.consumer.internals.Fetcher:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.common.metrics.Metrics,org.apache.kafka.clients.consumer.internals.FetcherMetricsRegistry)",
            "org.apache.kafka.clients.producer.internals.BufferPool:void <init>(long,int,org.apache.kafka.common.metrics.Metrics,org.apache.kafka.common.utils.Time,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:void registerMetrics(org.apache.kafka.common.metrics.Metrics,java.lang.String)",
            "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String)",
            "org.apache.kafka.clients.producer.KafkaProducer:void <init>(org.apache.kafka.clients.producer.ProducerConfig,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.common.serialization.Serializer,org.apache.kafka.clients.Metadata,org.apache.kafka.clients.KafkaClient)",
            "org.apache.kafka.clients.producer.KafkaProducer:java.util.concurrent.Future doSend(org.apache.kafka.clients.producer.ProducerRecord,org.apache.kafka.clients.producer.Callback)"
        ]
    },
    "org.apache.kafka.common.metrics.Metrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector$SelectorMetrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor[])"
        ]
    },
    "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean coordinatorUnknown()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread:void run()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:boolean ensureCoordinatorReady(long)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendJoinGroupRequest()",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:org.apache.kafka.clients.consumer.internals.RequestFuture sendSyncGroupRequest(org.apache.kafka.common.requests.SyncGroupRequest$Builder)",
            "org.apache.kafka.clients.consumer.internals.AbstractCoordinator:void maybeLeaveGroup()",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean poll(long)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:void commitOffsetsAsync(java.util.Map,org.apache.kafka.clients.consumer.OffsetCommitCallback)",
            "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator:boolean commitOffsetsSync(java.util.Map,long)"
        ]
    },
    "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.requests.CreateAclsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreatePartitionsRequest:org.apache.kafka.common.requests.CreatePartitionsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterConfigsRequest:org.apache.kafka.common.requests.AlterConfigsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.WriteTxnMarkersRequest:org.apache.kafka.common.requests.WriteTxnMarkersRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.HeartbeatRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.ControlledShutdownRequest:org.apache.kafka.common.requests.ControlledShutdownRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteRecordsRequest:org.apache.kafka.common.requests.DeleteRecordsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteTopicsRequest:org.apache.kafka.common.requests.DeleteTopicsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.InitProducerIdRequest:org.apache.kafka.common.requests.InitProducerIdRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest$Builder:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest:org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateDelegationTokenRequest:org.apache.kafka.common.requests.CreateDelegationTokenRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.ExpireDelegationTokenRequest:org.apache.kafka.common.requests.ExpireDelegationTokenRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.RenewDelegationTokenRequest:org.apache.kafka.common.requests.RenewDelegationTokenRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.TxnOffsetCommitRequest:org.apache.kafka.common.requests.TxnOffsetCommitRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AddPartitionsToTxnRequest:org.apache.kafka.common.requests.AddPartitionsToTxnRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.AlterReplicaLogDirsRequest:org.apache.kafka.common.requests.AlterReplicaLogDirsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DeleteGroupsRequest:org.apache.kafka.common.requests.DeleteGroupsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeDelegationTokenRequest:org.apache.kafka.common.requests.DescribeDelegationTokenRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.DescribeGroupsRequest:org.apache.kafka.common.requests.DescribeGroupsRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.OffsetFetchRequest:org.apache.kafka.common.requests.OffsetFetchRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SyncGroupRequest:org.apache.kafka.common.requests.SyncGroupRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:void <init>(org.apache.kafka.common.protocol.types.Struct,short)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:org.apache.kafka.common.requests.AbstractRequest parseRequest(org.apache.kafka.common.protocol.ApiKeys,short,org.apache.kafka.common.protocol.types.Struct)",
            "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.LeaveGroupRequest parse(java.nio.ByteBuffer,short)"
        ]
    },
    "org.apache.kafka.common.requests.SaslHandshakeRequest:org.apache.kafka.common.requests.SaslHandshakeRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.EndTxnRequest:org.apache.kafka.common.requests.EndTxnRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.SaslAuthenticateRequest:org.apache.kafka.common.requests.SaslAuthenticateRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.CreateAclsRequest$AclCreation:void setStructFields(org.apache.kafka.common.protocol.types.Struct)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.CreateAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()"
        ]
    },
    "org.apache.kafka.common.requests.DescribeAclsRequest:org.apache.kafka.common.protocol.types.Struct toStruct()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.requests.AbstractRequest:java.nio.ByteBuffer serialize(org.apache.kafka.common.requests.RequestHeader)",
            "org.apache.kafka.common.requests.AbstractRequest:java.lang.String toString(boolean)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecordsBuilder:java.lang.Long appendEndTxnMarker(long,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:void writeEndTransactionalMarker(java.nio.ByteBuffer,long,long,int,long,short,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.record.DefaultRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.consumer.internals.Fetcher$PartitionRecords:org.apache.kafka.common.record.Record nextFetchedRecord()",
            "org.apache.kafka.common.record.FileLogInputStream$FileChannelRecordBatch:org.apache.kafka.common.utils.CloseableIterator streamingIterator(org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords$FilterResult filterTo(org.apache.kafka.common.TopicPartition,java.lang.Iterable,org.apache.kafka.common.record.MemoryRecords$RecordFilter,java.nio.ByteBuffer,int,org.apache.kafka.common.record.BufferSupplier)",
            "org.apache.kafka.common.record.MemoryRecords:java.lang.String toString()"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:void <init>(org.apache.kafka.common.TopicPartition,org.apache.kafka.common.record.MemoryRecordsBuilder,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.RecordAccumulator:org.apache.kafka.clients.producer.internals.RecordAccumulator$RecordAppendResult append(org.apache.kafka.common.TopicPartition,long,byte[],byte[],org.apache.kafka.common.header.Header[],org.apache.kafka.clients.producer.Callback,long)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.ProducerBatch:org.apache.kafka.clients.producer.internals.ProducerBatch createBatchOffAccumulatorForRecord(org.apache.kafka.common.record.Record,int)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.ProducerBatch:java.util.Deque split(int)"
        ]
    },
    "org.apache.kafka.clients.producer.internals.SenderMetricsRegistry:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void <init>(org.apache.kafka.clients.producer.internals.Sender,org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)",
            "org.apache.kafka.clients.producer.internals.Sender$SenderMetrics:void maybeRegisterTopicMetrics(java.lang.String)",
            "org.apache.kafka.clients.producer.internals.Sender:org.apache.kafka.common.metrics.Sensor throttleTimeSensor(org.apache.kafka.clients.producer.internals.SenderMetricsRegistry)"
        ]
    },
    "org.apache.kafka.common.network.Selector$SelectorMetrics:org.apache.kafka.common.metrics.Sensor sensor(java.lang.String,org.apache.kafka.common.metrics.Sensor[])": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void <init>(org.apache.kafka.common.network.Selector,org.apache.kafka.common.metrics.Metrics,java.lang.String,java.util.Map,boolean)",
            "org.apache.kafka.common.network.Selector$SelectorMetrics:void maybeRegisterConnectionMetrics(java.lang.String)"
        ]
    },
    "org.apache.kafka.common.requests.AddOffsetsToTxnRequest:org.apache.kafka.common.requests.AddOffsetsToTxnRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.HeartbeatRequest:org.apache.kafka.common.requests.HeartbeatRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.requests.LeaveGroupRequest:org.apache.kafka.common.requests.LeaveGroupRequest parse(java.nio.ByteBuffer,short)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:void writeEndTransactionalMarker(java.nio.ByteBuffer,long,long,int,long,short,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,long,int,long,short,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,long,int,long,short,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,short,org.apache.kafka.common.record.EndTransactionMarker)",
            "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,long,short,org.apache.kafka.common.record.EndTransactionMarker)"
        ]
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,short,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.apache.kafka.common.record.MemoryRecords:org.apache.kafka.common.record.MemoryRecords withEndTransactionMarker(long,long,short,org.apache.kafka.common.record.EndTransactionMarker)": {
        "isVulRoot": false,
        "vulCaller": []
    }
}