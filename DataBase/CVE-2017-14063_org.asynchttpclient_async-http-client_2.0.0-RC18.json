{
    "org.asynchttpclient.uri.UriParser:void parseAuthority()": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.UriParser:void parse(org.asynchttpclient.uri.Uri,java.lang.String)"
        ]
    },
    "org.asynchttpclient.uri.UriParser:void handleRelativePath()": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.UriParser:void computeRegularPath()"
        ]
    },
    "org.asynchttpclient.uri.UriParser:void parse(org.asynchttpclient.uri.Uri,java.lang.String)": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.Uri:org.asynchttpclient.uri.Uri create(org.asynchttpclient.uri.Uri,java.lang.String)"
        ]
    },
    "org.asynchttpclient.uri.UriParser:void computeInitialScheme(java.lang.String)": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.UriParser:void parse(org.asynchttpclient.uri.Uri,java.lang.String)"
        ]
    },
    "org.asynchttpclient.uri.UriParser:boolean overrideWithContext(org.asynchttpclient.uri.Uri,java.lang.String)": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.UriParser:void parse(org.asynchttpclient.uri.Uri,java.lang.String)"
        ]
    },
    "org.asynchttpclient.uri.UriParser:void computeAuthority()": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.UriParser:void parseAuthority()"
        ]
    },
    "org.asynchttpclient.uri.UriParser:void computePath(boolean)": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.UriParser:void parse(org.asynchttpclient.uri.Uri,java.lang.String)"
        ]
    },
    "org.asynchttpclient.uri.UriParser:void trimLeft(java.lang.String)": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.UriParser:void parse(org.asynchttpclient.uri.Uri,java.lang.String)"
        ]
    },
    "org.asynchttpclient.uri.UriParser:void computeRegularPath()": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.UriParser:void computePath(boolean)"
        ]
    },
    "org.asynchttpclient.uri.UriParser:boolean splitUrlAndQuery(java.lang.String)": {
        "isVulRoot": true,
        "vulCaller": [
            "org.asynchttpclient.uri.UriParser:void parse(org.asynchttpclient.uri.Uri,java.lang.String)"
        ]
    },
    "org.asynchttpclient.uri.Uri:org.asynchttpclient.uri.Uri create(org.asynchttpclient.uri.Uri,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.intercept.Redirect30xInterceptor:boolean exitAfterHandlingRedirect(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm)",
            "org.asynchttpclient.uri.Uri:org.asynchttpclient.uri.Uri create(java.lang.String)"
        ]
    },
    "org.asynchttpclient.netty.handler.intercept.Redirect30xInterceptor:boolean exitAfterHandlingRedirect(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.intercept.Interceptors:boolean exitAfterIntercept(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.HttpResponseStatus,org.asynchttpclient.HttpResponseHeaders)"
        ]
    },
    "org.asynchttpclient.uri.Uri:org.asynchttpclient.uri.Uri create(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.RequestBuilderBase setUrl(java.lang.String)",
            "org.asynchttpclient.RequestBuilderBase:void <clinit>()"
        ]
    },
    "org.asynchttpclient.netty.handler.intercept.Interceptors:boolean exitAfterIntercept(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.HttpResponseStatus,org.asynchttpclient.HttpResponseHeaders)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.HttpHandler:void handleHttpResponse(io.netty.handler.codec.http.HttpResponse,io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler)",
            "org.asynchttpclient.netty.handler.WebSocketHandler:void handleRead(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Object)"
        ]
    },
    "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.RequestBuilderBase setUrl(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder requestBuilder(java.lang.String,java.lang.String)",
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder request(java.lang.String,java.lang.String)"
        ]
    },
    "org.asynchttpclient.RequestBuilderBase:void <clinit>()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.RequestBuilderBase:void <init>(java.lang.String,boolean,boolean)",
            "org.asynchttpclient.RequestBuilderBase:void <init>(org.asynchttpclient.Request,boolean,boolean)",
            "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.RequestBuilderBase addHeader(java.lang.CharSequence,java.lang.String)",
            "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.uri.Uri computeUri()",
            "org.asynchttpclient.RequestBuilderBase:void <clinit>()"
        ]
    },
    "org.asynchttpclient.netty.handler.HttpHandler:void handleHttpResponse(io.netty.handler.codec.http.HttpResponse,io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.HttpHandler:void handleRead(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Object)"
        ]
    },
    "org.asynchttpclient.netty.handler.WebSocketHandler:void handleRead(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder requestBuilder(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareGet(java.lang.String)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareConnect(java.lang.String)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareOptions(java.lang.String)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareHead(java.lang.String)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder preparePost(java.lang.String)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder preparePut(java.lang.String)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareDelete(java.lang.String)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder preparePatch(java.lang.String)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareTrace(java.lang.String)"
        ]
    },
    "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder request(java.lang.String,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder get(java.lang.String)",
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder put(java.lang.String)",
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder post(java.lang.String)",
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder delete(java.lang.String)",
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder head(java.lang.String)",
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder options(java.lang.String)",
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder path(java.lang.String)",
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder trace(java.lang.String)"
        ]
    },
    "org.asynchttpclient.RequestBuilderBase:void <init>(java.lang.String,boolean,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.BoundRequestBuilder:void <init>(org.asynchttpclient.AsyncHttpClient,java.lang.String,boolean,boolean)",
            "org.asynchttpclient.RequestBuilder:void <init>(java.lang.String,boolean,boolean)",
            "org.asynchttpclient.RequestBuilderBase:void <init>(java.lang.String,boolean)"
        ]
    },
    "org.asynchttpclient.RequestBuilderBase:void <init>(org.asynchttpclient.Request,boolean,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.RequestBuilder:void <init>(org.asynchttpclient.Request,boolean,boolean)",
            "org.asynchttpclient.RequestBuilderBase:void <init>(org.asynchttpclient.Request)"
        ]
    },
    "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.RequestBuilderBase addHeader(java.lang.CharSequence,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.uri.Uri computeUri()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.Request build()"
        ]
    },
    "org.asynchttpclient.netty.handler.HttpHandler:void handleRead(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareGet(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareConnect(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareOptions(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareHead(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder preparePost(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder preparePut(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareDelete(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder preparePatch(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareTrace(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder get(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder put(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder post(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder delete(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder head(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder options(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder path(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder trace(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.BoundRequestBuilder:void <init>(org.asynchttpclient.AsyncHttpClient,java.lang.String,boolean,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.RequestBuilder:void <init>(java.lang.String,boolean,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.RequestBuilderBase:void <init>(java.lang.String,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.BoundRequestBuilder:void <init>(org.asynchttpclient.AsyncHttpClient,java.lang.String,boolean)",
            "org.asynchttpclient.RequestBuilder:void <init>(java.lang.String,boolean)"
        ]
    },
    "org.asynchttpclient.RequestBuilder:void <init>(org.asynchttpclient.Request,boolean,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.RequestBuilderBase:void <init>(org.asynchttpclient.Request)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.BoundRequestBuilder:void <init>(org.asynchttpclient.AsyncHttpClient,org.asynchttpclient.Request)",
            "org.asynchttpclient.RequestBuilder:void <init>(org.asynchttpclient.Request)"
        ]
    },
    "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.Request build()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.BoundRequestBuilder:org.asynchttpclient.ListenableFuture execute(org.asynchttpclient.AsyncHandler)",
            "org.asynchttpclient.BoundRequestBuilder:org.asynchttpclient.ListenableFuture execute()",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareRequest(org.asynchttpclient.RequestBuilder)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.RequestBuilder,org.asynchttpclient.AsyncHandler)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.RequestBuilder)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.filter.FilterContext preProcessRequest(org.asynchttpclient.filter.FilterContext)",
            "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.RequestBuilderBase executeSignatureCalculator()",
            "org.asynchttpclient.handler.resumable.ResumableAsyncHandler:org.asynchttpclient.Request adjustRequestRange(org.asynchttpclient.Request)",
            "org.asynchttpclient.netty.handler.intercept.ConnectSuccessInterceptor:boolean exitAfterHandlingConnect(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.Request,org.asynchttpclient.proxy.ProxyServer,int,io.netty.handler.codec.http.HttpRequest)",
            "org.asynchttpclient.netty.handler.intercept.ProxyUnauthorized407Interceptor:boolean exitAfterHandling407(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)",
            "org.asynchttpclient.netty.handler.intercept.Redirect30xInterceptor:boolean exitAfterHandlingRedirect(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm)",
            "org.asynchttpclient.netty.handler.intercept.Unauthorized401Interceptor:boolean exitAfterHandling401(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "org.asynchttpclient.BoundRequestBuilder:void <init>(org.asynchttpclient.AsyncHttpClient,java.lang.String,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder requestBuilder(java.lang.String,java.lang.String)"
        ]
    },
    "org.asynchttpclient.RequestBuilder:void <init>(java.lang.String,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.RequestBuilder:void <init>(java.lang.String)"
        ]
    },
    "org.asynchttpclient.BoundRequestBuilder:void <init>(org.asynchttpclient.AsyncHttpClient,org.asynchttpclient.Request)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder requestBuilder(org.asynchttpclient.Request)"
        ]
    },
    "org.asynchttpclient.RequestBuilder:void <init>(org.asynchttpclient.Request)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.filter.FilterContext preProcessRequest(org.asynchttpclient.filter.FilterContext)",
            "org.asynchttpclient.handler.resumable.ResumableAsyncHandler:org.asynchttpclient.Request adjustRequestRange(org.asynchttpclient.Request)",
            "org.asynchttpclient.netty.handler.intercept.ConnectSuccessInterceptor:boolean exitAfterHandlingConnect(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.Request,org.asynchttpclient.proxy.ProxyServer,int,io.netty.handler.codec.http.HttpRequest)",
            "org.asynchttpclient.netty.handler.intercept.ProxyUnauthorized407Interceptor:boolean exitAfterHandling407(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)",
            "org.asynchttpclient.netty.handler.intercept.Unauthorized401Interceptor:boolean exitAfterHandling401(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)"
        ]
    },
    "org.asynchttpclient.BoundRequestBuilder:org.asynchttpclient.ListenableFuture execute(org.asynchttpclient.AsyncHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.BoundRequestBuilder:org.asynchttpclient.ListenableFuture execute()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareRequest(org.asynchttpclient.RequestBuilder)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.RequestBuilder,org.asynchttpclient.AsyncHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.RequestBuilder)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.filter.FilterContext preProcessRequest(org.asynchttpclient.filter.FilterContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler)"
        ]
    },
    "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.RequestBuilderBase executeSignatureCalculator()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.Request build()"
        ]
    },
    "org.asynchttpclient.handler.resumable.ResumableAsyncHandler:org.asynchttpclient.Request adjustRequestRange(org.asynchttpclient.Request)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.filter.FilterContext preProcessRequest(org.asynchttpclient.filter.FilterContext)",
            "org.asynchttpclient.handler.resumable.ResumableIOExceptionFilter:org.asynchttpclient.filter.FilterContext filter(org.asynchttpclient.filter.FilterContext)"
        ]
    },
    "org.asynchttpclient.netty.handler.intercept.ConnectSuccessInterceptor:boolean exitAfterHandlingConnect(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.Request,org.asynchttpclient.proxy.ProxyServer,int,io.netty.handler.codec.http.HttpRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.intercept.Interceptors:boolean exitAfterIntercept(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.HttpResponseStatus,org.asynchttpclient.HttpResponseHeaders)"
        ]
    },
    "org.asynchttpclient.netty.handler.intercept.ProxyUnauthorized407Interceptor:boolean exitAfterHandling407(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.intercept.Interceptors:boolean exitAfterIntercept(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.HttpResponseStatus,org.asynchttpclient.HttpResponseHeaders)"
        ]
    },
    "org.asynchttpclient.netty.handler.intercept.Unauthorized401Interceptor:boolean exitAfterHandling401(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.intercept.Interceptors:boolean exitAfterIntercept(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.HttpResponseStatus,org.asynchttpclient.HttpResponseHeaders)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)",
            "io.netty.channel.SimpleChannelInboundHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$7:void run()"
        ]
    },
    "org.asynchttpclient.RequestBuilder:void <init>(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.Dsl:org.asynchttpclient.RequestBuilder request(java.lang.String,java.lang.String)",
            "org.asynchttpclient.RequestBuilder:void <init>()",
            "org.asynchttpclient.RequestBuilderBase:org.asynchttpclient.RequestBuilderBase executeSignatureCalculator()",
            "org.asynchttpclient.netty.handler.intercept.Redirect30xInterceptor:boolean exitAfterHandlingRedirect(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm)"
        ]
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder requestBuilder(org.asynchttpclient.Request)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareRequest(org.asynchttpclient.Request)"
        ]
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.BoundRequestBuilder:org.asynchttpclient.ListenableFuture execute(org.asynchttpclient.AsyncHandler)",
            "org.asynchttpclient.BoundRequestBuilder:org.asynchttpclient.ListenableFuture execute()",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.RequestBuilder,org.asynchttpclient.AsyncHandler)",
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.Request)"
        ]
    },
    "org.asynchttpclient.handler.resumable.ResumableIOExceptionFilter:org.asynchttpclient.filter.FilterContext filter(org.asynchttpclient.filter.FilterContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.NettyRequestSender:boolean applyIoExceptionFiltersAndReplayRequest(org.asynchttpclient.netty.NettyResponseFuture,java.io.IOException,io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.SimpleChannelInboundHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.SimpleChannelInboundHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$7:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRead(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "org.asynchttpclient.RequestBuilder:void <init>()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareRequest(org.asynchttpclient.Request)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.BoundRequestBuilder prepareRequest(org.asynchttpclient.RequestBuilder)"
        ]
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.Request)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.RequestBuilder)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:boolean applyIoExceptionFiltersAndReplayRequest(org.asynchttpclient.netty.NettyResponseFuture,java.io.IOException,io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "org.asynchttpclient.netty.handler.HttpHandler:void handleRead(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$800(io.netty.channel.AbstractChannel$AbstractUnsafe,java.lang.Runnable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)",
            "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)",
            "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoop:void run()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.future.ExecutionList:void run()"
        ]
    },
    "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.future.AbstractListenableFuture:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)"
        ]
    },
    "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)"
        ]
    },
    "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.WebSocketHandler$UpgradeCallback:void invokeOnSucces(io.netty.channel.Channel,org.asynchttpclient.ws.WebSocketUpgradeHandler)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(java.lang.Object)"
        ]
    },
    "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$800(io.netty.channel.AbstractChannel$AbstractUnsafe,java.lang.Runnable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void run()"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelWritabilityChanged()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer$2:void run()",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)"
        ]
    },
    "io.netty.channel.ChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void read(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline read()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelReadComplete()"
        ]
    },
    "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)",
            "io.netty.channel.ChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()",
            "io.netty.channel.ChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()",
            "io.netty.channel.ChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()",
            "io.netty.channel.ChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void clearUserDefinedWritability(int)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setWritable(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUnwritable(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)"
        ]
    },
    "org.asynchttpclient.future.ExecutionList:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.AbstractListenableFuture:void runListeners()",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "org.asynchttpclient.future.AbstractListenableFuture:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.NettyResponseFuture:java.util.concurrent.CompletableFuture toCompletableFuture()"
        ]
    },
    "org.asynchttpclient.netty.handler.WebSocketHandler$UpgradeCallback:void invokeOnSucces(io.netty.channel.Channel,org.asynchttpclient.ws.WebSocketUpgradeHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.WebSocketHandler$UpgradeCallback:void call()"
        ]
    },
    "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$300(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void notifyHandlerException(java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$400(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void beginRead()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void fireChannelInactiveAndDeregister(boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$200(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$700(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelReadComplete(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$800(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelWritabilityChanged(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer$2:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1400(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.CombinedChannelDuplexHandler:void read(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel read()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$200(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.ChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.ChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.ChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.ChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()",
            "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()",
            "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void flush(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline flush()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.channel.ChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWrite()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void setUserDefinedWritability(int,boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long,boolean,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void addFlush()",
            "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)",
            "io.netty.channel.ChannelOutboundBuffer:boolean remove()",
            "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)"
        ]
    },
    "org.asynchttpclient.future.AbstractListenableFuture:void runListeners()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.NettyResponseFuture:boolean cancel(boolean)",
            "org.asynchttpclient.netty.NettyResponseFuture:void done()",
            "org.asynchttpclient.netty.NettyResponseFuture:void abort(java.lang.Throwable)"
        ]
    },
    "org.asynchttpclient.netty.NettyResponseFuture:java.util.concurrent.CompletableFuture toCompletableFuture()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.handler.WebSocketHandler$UpgradeCallback:void call()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$300(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$4:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void notifyHandlerException(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRead(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeRead()",
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$400(io.netty.channel.AbstractChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$5:void run()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$900(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeBind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void bind(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1200(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDisconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void disconnect(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void closeIfClosed()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void disconnect(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$700(io.netty.channel.AbstractChannel$AbstractUnsafe,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void access$200(io.netty.channel.AbstractChannel$AbstractUnsafe,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$700(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$8:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$800(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$9:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1400(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$15:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$200(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$3:void run()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1000(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeConnect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void connect(io.netty.channel.ChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1100(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeClose(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void close(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1300(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeDeregister(io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void deregister(io.netty.channel.ChannelHandlerContext,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister(io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext flush()",
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1500(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()",
            "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.Channel flush()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.ChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundHandlerAdapter:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.ChannelOutboundHandlerAdapter:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWrite()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWrite()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void addFlush()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void decrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()",
            "io.netty.channel.PendingWriteQueue:void recycle(io.netty.channel.PendingWriteQueue$PendingWrite,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove0(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)",
            "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void addMessage(java.lang.Object,int,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void incrementPendingOutboundBytes(long)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void init(io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask,io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.PendingWriteQueue:void add(java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "org.asynchttpclient.netty.NettyResponseFuture:boolean cancel(boolean)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.NettyResponseFuture:void done()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.HttpHandler:void finishUpdate(org.asynchttpclient.netty.NettyResponseFuture,io.netty.channel.Channel,boolean)",
            "org.asynchttpclient.netty.handler.StreamedResponsePublisher:void cancelled()",
            "org.asynchttpclient.netty.handler.WebSocketHandler$UpgradeCallback:void call()"
        ]
    },
    "org.asynchttpclient.netty.NettyResponseFuture:void abort(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.NettyConnectListener:void onFailure(io.netty.channel.Channel,java.lang.Throwable)",
            "org.asynchttpclient.netty.request.NettyRequestSender:void abort(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Throwable)",
            "org.asynchttpclient.netty.request.ProgressListener:boolean abortOnThrowable(java.lang.Throwable,io.netty.channel.Channel)",
            "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber:void error(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelInactive()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelInactive()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$4:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelInactive()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.ChannelInboundHandlerAdapter:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()",
            "io.netty.channel.CombinedChannelDuplexHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.CombinedChannelDuplexHandler$1:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireExceptionCaught(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()",
            "io.netty.channel.ChannelFutureListener$3:void operationComplete(io.netty.channel.ChannelFuture)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$000(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()",
            "io.netty.channel.AbstractChannelHandlerContext:void access$100(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$500(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$5:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireExceptionCaught(java.lang.Throwable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void access$400(io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$900(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$10:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1200(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$12:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void flush(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeFlush()",
            "io.netty.channel.CombinedChannelDuplexHandler:void flush(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$6:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$1:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register(io.netty.channel.EventLoop,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$8:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$9:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$15:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelActive()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelActive(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelActive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelActive()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$3:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelActive()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture bind(java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1000(io.netty.channel.AbstractChannelHandlerContext,java.net.SocketAddress,java.net.SocketAddress,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$11:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture disconnect()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture close()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1100(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$12:void run()",
            "io.netty.channel.AbstractChannelHandlerContext$13:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture deregister()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1300(io.netty.channel.AbstractChannelHandlerContext,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$14:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1500(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$16:void run()",
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext:void access$1800(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:void recycle(io.netty.channel.PendingWriteQueue$PendingWrite,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.PendingWriteQueue:void removeAndFailAll(java.lang.Throwable)",
            "io.netty.channel.PendingWriteQueue:void removeAndFail(java.lang.Throwable)",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWriteAll()",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelFuture removeAndWrite()",
            "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelPromise remove()"
        ]
    },
    "io.netty.channel.ChannelOutboundBuffer:void removeBytes(long)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:boolean remove(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.ChannelOutboundBuffer:void failFlushed(java.lang.Throwable,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$5$1:void run()",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void close(io.netty.channel.ChannelPromise,java.lang.Throwable,boolean)",
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void flush0()"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe:void write(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void init(io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask,io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.PendingWriteQueue:void add(java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.handler.HttpHandler:void finishUpdate(org.asynchttpclient.netty.NettyResponseFuture,io.netty.channel.Channel,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.HttpHandler:void notifyHandler(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseStatus,io.netty.handler.codec.http.HttpRequest,org.asynchttpclient.HttpResponseHeaders)",
            "org.asynchttpclient.netty.handler.HttpHandler:void handleChunk(io.netty.handler.codec.http.HttpContent,io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler)",
            "org.asynchttpclient.netty.handler.HttpHandler:void readFailed(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Throwable)"
        ]
    },
    "org.asynchttpclient.netty.handler.StreamedResponsePublisher:void cancelled()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.channel.NettyConnectListener:void onFailure(io.netty.channel.Channel,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.SimpleChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)",
            "org.asynchttpclient.netty.channel.NettyConnectListener$1:void onFailure(java.lang.Throwable)",
            "org.asynchttpclient.netty.request.NettyChannelConnector$1:void onFailure(io.netty.channel.Channel,java.lang.Throwable)",
            "org.asynchttpclient.netty.request.NettyChannelConnector:void connect(io.netty.bootstrap.Bootstrap,org.asynchttpclient.netty.channel.NettyConnectListener)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:void abort(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "org.asynchttpclient.netty.handler.HttpHandler:void readFailed(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Throwable)",
            "org.asynchttpclient.netty.handler.WebSocketHandler$UpgradeCallback:void call()",
            "org.asynchttpclient.netty.handler.intercept.ProxyUnauthorized407Interceptor:boolean exitAfterHandling407(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)",
            "org.asynchttpclient.netty.handler.intercept.ResponseFiltersInterceptor:boolean exitAfterProcessingFilters(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,org.asynchttpclient.HttpResponseStatus,org.asynchttpclient.HttpResponseHeaders)",
            "org.asynchttpclient.netty.handler.intercept.Unauthorized401Interceptor:boolean exitAfterHandling401(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)",
            "org.asynchttpclient.netty.request.NettyRequestSender$1:void onFailure(java.lang.Throwable)",
            "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestWithNewChannel(org.asynchttpclient.Request,org.asynchttpclient.proxy.ProxyServer,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,boolean)",
            "org.asynchttpclient.netty.request.NettyRequestSender:void writeRequest(org.asynchttpclient.netty.NettyResponseFuture,io.netty.channel.Channel)",
            "org.asynchttpclient.netty.request.NettyRequestSender:void handleUnexpectedClosedChannel(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture)",
            "org.asynchttpclient.netty.request.NettyRequestSender:boolean retry(org.asynchttpclient.netty.NettyResponseFuture)",
            "org.asynchttpclient.netty.request.NettyRequestSender:boolean applyIoExceptionFiltersAndReplayRequest(org.asynchttpclient.netty.NettyResponseFuture,java.io.IOException,io.netty.channel.Channel)",
            "org.asynchttpclient.netty.timeout.TimeoutTimerTask:void expire(java.lang.String,long)"
        ]
    },
    "org.asynchttpclient.netty.request.ProgressListener:boolean abortOnThrowable(java.lang.Throwable,io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.ProgressListener:void operationComplete(io.netty.channel.ChannelProgressiveFuture)"
        ]
    },
    "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber:void error(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$3:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$8:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$3:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelFutureListener$3:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void access$600(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.VoidChannelPromise:void fireException(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)",
            "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$000(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$100(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$2:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$500(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$6:void run()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler:void removeInboundHandler()",
            "io.netty.channel.CombinedChannelDuplexHandler:void removeOutboundHandler()",
            "io.netty.channel.CombinedChannelDuplexHandler:void handlerRemoved(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void access$400(io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext$1:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$10:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$12:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)",
            "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)",
            "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel$AbstractUnsafe$2:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture connect(java.net.SocketAddress)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$11:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$13:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$14:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$16:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture write(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext:void access$1800(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannel:io.netty.channel.ChannelFuture writeAndFlush(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.PendingWriteQueue:void removeAndFailAll(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.PendingWriteQueue:void removeAndFail(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.PendingWriteQueue:io.netty.channel.ChannelPromise remove()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$HeadContext:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeWrite(java.lang.Object,io.netty.channel.ChannelPromise)",
            "io.netty.channel.CombinedChannelDuplexHandler:void write(io.netty.channel.ChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask access$1600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask newInstance(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask access$1700(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "org.asynchttpclient.netty.handler.HttpHandler:void notifyHandler(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseStatus,io.netty.handler.codec.http.HttpRequest,org.asynchttpclient.HttpResponseHeaders)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.HttpHandler:void handleHttpResponse(io.netty.handler.codec.http.HttpResponse,io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler)"
        ]
    },
    "org.asynchttpclient.netty.handler.HttpHandler:void handleChunk(io.netty.handler.codec.http.HttpContent,io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.HttpHandler:void handleRead(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Object)"
        ]
    },
    "org.asynchttpclient.netty.handler.HttpHandler:void readFailed(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.HttpHandler:void handleRead(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,java.lang.Object)"
        ]
    },
    "org.asynchttpclient.netty.SimpleChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.SimpleChannelFutureListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "org.asynchttpclient.netty.channel.NettyConnectListener$1:void onFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.SimpleFutureListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyChannelConnector$1:void onFailure(io.netty.channel.Channel,java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.SimpleChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyChannelConnector:void connect(io.netty.bootstrap.Bootstrap,org.asynchttpclient.netty.channel.NettyConnectListener)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.NettyChannelConnector$1:void onFailure(io.netty.channel.Channel,java.lang.Throwable)",
            "org.asynchttpclient.netty.request.NettyRequestSender$1:void onSuccess(java.util.List)"
        ]
    },
    "org.asynchttpclient.netty.handler.intercept.ResponseFiltersInterceptor:boolean exitAfterProcessingFilters(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,org.asynchttpclient.HttpResponseStatus,org.asynchttpclient.HttpResponseHeaders)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.intercept.Interceptors:boolean exitAfterIntercept(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.HttpResponseStatus,org.asynchttpclient.HttpResponseHeaders)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender$1:void onFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.SimpleFutureListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestWithNewChannel(org.asynchttpclient.Request,org.asynchttpclient.proxy.ProxyServer,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestWithCertainForceConnect(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseFuture,boolean,org.asynchttpclient.proxy.ProxyServer,boolean)",
            "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestThroughSslProxy(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseFuture,boolean,org.asynchttpclient.proxy.ProxyServer)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:void writeRequest(org.asynchttpclient.netty.NettyResponseFuture,io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.NettyConnectListener:void writeRequest(io.netty.channel.Channel)",
            "org.asynchttpclient.netty.handler.intercept.Continue100Interceptor$1:void call()",
            "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestWithOpenChannel(org.asynchttpclient.Request,org.asynchttpclient.proxy.ProxyServer,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,io.netty.channel.Channel)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:void handleUnexpectedClosedChannel(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)",
            "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestWithOpenChannel(org.asynchttpclient.Request,org.asynchttpclient.proxy.ProxyServer,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,io.netty.channel.Channel)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:boolean retry(org.asynchttpclient.netty.NettyResponseFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.NettyConnectListener:void onFailure(io.netty.channel.Channel,java.lang.Throwable)",
            "org.asynchttpclient.netty.request.NettyRequestSender:void handleUnexpectedClosedChannel(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture)"
        ]
    },
    "org.asynchttpclient.netty.timeout.TimeoutTimerTask:void expire(java.lang.String,long)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.timeout.ReadTimeoutTimerTask:void run(io.netty.util.Timeout)",
            "org.asynchttpclient.netty.timeout.RequestTimeoutTimerTask:void run(io.netty.util.Timeout)"
        ]
    },
    "org.asynchttpclient.netty.request.ProgressListener:void operationComplete(io.netty.channel.ChannelProgressiveFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.ProgressListener:void operationComplete(io.netty.util.concurrent.Future)",
            "org.asynchttpclient.netty.request.body.NettyBodyBody$2:void operationComplete(io.netty.channel.ChannelProgressiveFuture)",
            "org.asynchttpclient.netty.request.body.NettyInputStreamBody$1:void operationComplete(io.netty.channel.ChannelProgressiveFuture)"
        ]
    },
    "io.netty.channel.ChannelFutureListener$3:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])",
            "org.asynchttpclient.netty.handler.HttpHandler:boolean exitAfterHandlingReactiveStreams(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.AsyncHandler,io.netty.handler.codec.http.HttpRequest)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(io.netty.util.concurrent.EventExecutorGroup,java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(io.netty.channel.AbstractChannelHandlerContext,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$100(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$2:void run()",
            "io.netty.channel.DefaultChannelPipeline$3:void run()",
            "io.netty.channel.DefaultChannelPipeline$4:void run()",
            "io.netty.channel.DefaultChannelPipeline$5:void run()",
            "io.netty.channel.DefaultChannelPipeline$7:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.AbstractChannelHandlerContext remove(io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()",
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.DefaultChannelPipeline:void access$900(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$600(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$6:void run()",
            "io.netty.channel.DefaultChannelPipeline$7:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void run()",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()"
        ]
    },
    "io.netty.channel.VoidChannelPromise:io.netty.channel.VoidChannelPromise setFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.VoidChannelPromise:boolean tryFailure(java.lang.Throwable)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelRegistered()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$1:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelRegistered()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void channelUnregistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe$7:void run()"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$2:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelUnregistered()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInboundHandlerAdapter:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireUserEventTriggered(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$6:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireUserEventTriggered(java.lang.Object)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void removeInboundHandler()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void removeOutboundHandler()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void handlerRemoved(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove0()",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAdded0(io.netty.channel.AbstractChannelHandlerContext)",
            "io.netty.channel.DefaultChannelPipeline:void callHandlerRemoved0(io.netty.channel.AbstractChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext$1:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext:void remove()",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.SingleThreadEventLoop:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.ThreadPerChannelEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask:void run()",
            "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:void write(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask:io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask access$1600(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "io.netty.channel.AbstractChannelHandlerContext$WriteTask:io.netty.channel.AbstractChannelHandlerContext$WriteTask access$1700(io.netty.channel.AbstractChannelHandlerContext,java.lang.Object,io.netty.channel.ChannelPromise)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void write(java.lang.Object,boolean,io.netty.channel.ChannelPromise)"
        ]
    },
    "org.asynchttpclient.netty.SimpleChannelFutureListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.SimpleFutureListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.request.NettyRequestSender$1:void onSuccess(java.util.List)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.NettyRequestSender$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestWithCertainForceConnect(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseFuture,boolean,org.asynchttpclient.proxy.ProxyServer,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequest(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseFuture,boolean)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestThroughSslProxy(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseFuture,boolean,org.asynchttpclient.proxy.ProxyServer)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequest(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseFuture,boolean)"
        ]
    },
    "org.asynchttpclient.netty.channel.NettyConnectListener:void writeRequest(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.NettyConnectListener:void onSuccess(io.netty.channel.Channel)",
            "org.asynchttpclient.netty.channel.NettyConnectListener:void access$000(org.asynchttpclient.netty.channel.NettyConnectListener,io.netty.channel.Channel)"
        ]
    },
    "org.asynchttpclient.netty.handler.intercept.Continue100Interceptor$1:void call()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestWithOpenChannel(org.asynchttpclient.Request,org.asynchttpclient.proxy.ProxyServer,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestWithCertainForceConnect(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseFuture,boolean,org.asynchttpclient.proxy.ProxyServer,boolean)",
            "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequestThroughSslProxy(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseFuture,boolean,org.asynchttpclient.proxy.ProxyServer)"
        ]
    },
    "org.asynchttpclient.netty.timeout.ReadTimeoutTimerTask:void run(io.netty.util.Timeout)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.timeout.RequestTimeoutTimerTask:void run(io.netty.util.Timeout)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.request.ProgressListener:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.request.body.NettyBodyBody$2:void operationComplete(io.netty.channel.ChannelProgressiveFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.ProgressListener:void operationComplete(io.netty.util.concurrent.Future)",
            "org.asynchttpclient.netty.request.body.NettyBodyBody$2:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "org.asynchttpclient.netty.request.body.NettyInputStreamBody$1:void operationComplete(io.netty.channel.ChannelProgressiveFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.ProgressListener:void operationComplete(io.netty.util.concurrent.Future)",
            "org.asynchttpclient.netty.request.body.NettyInputStreamBody$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.ChannelManager:io.netty.handler.ssl.SslHandler addSslHandler(io.netty.channel.ChannelPipeline,org.asynchttpclient.uri.Uri,java.lang.String)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.ChannelManager$2:void initChannel(io.netty.channel.Channel)",
            "org.asynchttpclient.netty.channel.ChannelManager$3:void initChannel(io.netty.channel.Channel)",
            "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody:void write(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.util.concurrent.EventExecutorGroup,io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])"
        ]
    },
    "org.asynchttpclient.netty.handler.HttpHandler:boolean exitAfterHandlingReactiveStreams(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.AsyncHandler,io.netty.handler.codec.http.HttpRequest)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.HttpHandler:void notifyHandler(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseStatus,io.netty.handler.codec.http.HttpRequest,org.asynchttpclient.HttpResponseHeaders)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addBefore(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.ChannelManager:void upgradePipelineForWebSockets(io.netty.channel.ChannelPipeline)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addAfter(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.ChannelManager$2:void initChannel(io.netty.channel.Channel)",
            "org.asynchttpclient.netty.channel.ChannelManager$3:void initChannel(io.netty.channel.Channel)",
            "org.asynchttpclient.netty.channel.ChannelManager:void upgradeProtocol(io.netty.channel.ChannelPipeline,org.asynchttpclient.uri.Uri)",
            "org.asynchttpclient.netty.channel.ChannelManager:void upgradePipelineForWebSockets(io.netty.channel.ChannelPipeline)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline replace(io.netty.channel.ChannelHandler,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.String,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler replace(java.lang.Class,java.lang.String,io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline$2:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$3:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$4:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$5:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$7:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask:void execute()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline remove(io.netty.channel.ChannelHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)",
            "io.netty.channel.ChannelInitializer:void exceptionCaught(io.netty.channel.ChannelHandlerContext,java.lang.Throwable)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber:void removeFromPipeline()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.ChannelManager:void upgradeProtocol(io.netty.channel.ChannelPipeline,org.asynchttpclient.uri.Uri)",
            "org.asynchttpclient.netty.channel.ChannelManager:void upgradePipelineForWebSockets(io.netty.channel.ChannelPipeline)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler remove(java.lang.Class)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.StreamedResponsePublisher:void cancelled()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeFirst()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelHandler removeLast()": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void destroy()",
            "io.netty.channel.DefaultChannelPipeline:void access$800(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$900(io.netty.channel.DefaultChannelPipeline,java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$9:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$6:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$PendingHandlerRemovedTask:void execute()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelRegistered()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeChannelUnregistered()",
            "io.netty.channel.CombinedChannelDuplexHandler:void channelUnregistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannelHandlerContext:void invokeUserEventTriggered(java.lang.Object)",
            "io.netty.channel.CombinedChannelDuplexHandler:void userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object)"
        ]
    },
    "io.netty.channel.MultithreadEventLoopGroup:io.netty.channel.ChannelFuture register(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.request.NettyRequestSender$1:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.SimpleFutureListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:org.asynchttpclient.ListenableFuture sendRequest(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler,org.asynchttpclient.netty.NettyResponseFuture,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture execute(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler)",
            "org.asynchttpclient.netty.request.NettyRequestSender:void sendNextRequest(org.asynchttpclient.Request,org.asynchttpclient.netty.NettyResponseFuture)"
        ]
    },
    "org.asynchttpclient.netty.channel.NettyConnectListener:void onSuccess(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.SimpleChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)",
            "org.asynchttpclient.netty.request.NettyChannelConnector$1:void onSuccess(io.netty.channel.Channel)"
        ]
    },
    "org.asynchttpclient.netty.channel.NettyConnectListener:void access$000(org.asynchttpclient.netty.channel.NettyConnectListener,io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.NettyConnectListener$1:void onSuccess(io.netty.channel.Channel)"
        ]
    },
    "org.asynchttpclient.netty.request.body.NettyBodyBody$2:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.request.body.NettyInputStreamBody$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.channel.ChannelManager:io.netty.handler.ssl.SslHandler addSslHandler(io.netty.channel.ChannelPipeline,org.asynchttpclient.uri.Uri,java.lang.String)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.NettyConnectListener:void onSuccess(io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addFirst(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.channel.ChannelManager$2:void initChannel(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "org.asynchttpclient.netty.channel.ChannelManager$3:void initChannel(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.ChannelInitializer:void channelRegistered(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody:void write(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.NettyRequestSender:void writeRequest(org.asynchttpclient.netty.NettyResponseFuture,io.netty.channel.Channel)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])": {
        "isVulRoot": false,
        "vulCaller": []
    },
    "org.asynchttpclient.netty.channel.ChannelManager:void upgradePipelineForWebSockets(io.netty.channel.ChannelPipeline)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.WebSocketHandler$UpgradeCallback:void call()"
        ]
    },
    "org.asynchttpclient.netty.channel.ChannelManager:void upgradeProtocol(io.netty.channel.ChannelPipeline,org.asynchttpclient.uri.Uri)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.intercept.ConnectSuccessInterceptor:boolean exitAfterHandlingConnect(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.Request,org.asynchttpclient.proxy.ProxyServer,int,io.netty.handler.codec.http.HttpRequest)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void callHandlerAddedForAllHandlers()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void register0(io.netty.channel.ChannelPromise)"
        ]
    },
    "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber:void removeFromPipeline()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber:void error(java.lang.Throwable)",
            "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber:void access$000(org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void destroy()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline:io.netty.channel.ChannelPipeline fireChannelUnregistered()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline:void access$800(io.netty.channel.DefaultChannelPipeline,io.netty.channel.AbstractChannelHandlerContext,boolean)": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.DefaultChannelPipeline$8:void run()"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$9:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.DefaultChannelPipeline:void destroyDown(java.lang.Thread,io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture execute(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.DefaultAsyncHttpClient:org.asynchttpclient.ListenableFuture executeRequest(org.asynchttpclient.Request,org.asynchttpclient.AsyncHandler)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:void sendNextRequest(org.asynchttpclient.Request,org.asynchttpclient.netty.NettyResponseFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.intercept.ProxyUnauthorized407Interceptor:boolean exitAfterHandling407(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)",
            "org.asynchttpclient.netty.handler.intercept.Redirect30xInterceptor:boolean exitAfterHandlingRedirect(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm)",
            "org.asynchttpclient.netty.handler.intercept.Unauthorized401Interceptor:boolean exitAfterHandling401(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,io.netty.handler.codec.http.HttpResponse,org.asynchttpclient.Request,int,org.asynchttpclient.Realm,org.asynchttpclient.proxy.ProxyServer,io.netty.handler.codec.http.HttpRequest)",
            "org.asynchttpclient.netty.request.NettyRequestSender$2:void call()",
            "org.asynchttpclient.netty.request.NettyRequestSender:boolean retry(org.asynchttpclient.netty.NettyResponseFuture)",
            "org.asynchttpclient.netty.request.NettyRequestSender:void replayRequest(org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.filter.FilterContext,io.netty.channel.Channel)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyChannelConnector$1:void onSuccess(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.SimpleChannelFutureListener:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "org.asynchttpclient.netty.channel.NettyConnectListener$1:void onSuccess(io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.channel.NettyConnectListener$1:void onSuccess(java.lang.Object)"
        ]
    },
    "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber:void access$000(org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber$1$1:void operationComplete(io.netty.channel.ChannelFuture)"
        ]
    },
    "io.netty.channel.DefaultChannelPipeline$8:void run()": {
        "isVulRoot": false,
        "vulCaller": [
            "io.netty.channel.AbstractChannel$AbstractUnsafe:void invokeLater(java.lang.Runnable)",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelReadComplete()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext fireChannelWritabilityChanged()",
            "io.netty.channel.AbstractChannelHandlerContext:io.netty.channel.ChannelHandlerContext read()",
            "io.netty.channel.AbstractChannelHandlerContext:void safeExecute(io.netty.util.concurrent.EventExecutor,java.lang.Runnable,io.netty.channel.ChannelPromise,java.lang.Object)",
            "io.netty.channel.ChannelOutboundBuffer:void fireChannelWritabilityChanged(boolean)",
            "io.netty.channel.DefaultChannelPipeline:void destroyUp(io.netty.channel.AbstractChannelHandlerContext,boolean)",
            "io.netty.channel.ThreadPerChannelEventLoop:void run()",
            "org.asynchttpclient.ListenableFuture$CompletedFailure:org.asynchttpclient.ListenableFuture addListener(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.future.ExecutionList$RunnableExecutorPair:void execute()",
            "org.asynchttpclient.future.ExecutionList:void add(java.lang.Runnable,java.util.concurrent.Executor)",
            "org.asynchttpclient.netty.NettyResponseFuture$2:void execute(java.lang.Runnable)",
            "org.asynchttpclient.ws.WebSocketUpgradeHandler:void onSuccess(org.asynchttpclient.ws.WebSocket)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender$2:void call()": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelRead(io.netty.channel.ChannelHandlerContext,java.lang.Object)",
            "org.asynchttpclient.netty.handler.AsyncHttpClientHandler:void channelInactive(io.netty.channel.ChannelHandlerContext)"
        ]
    },
    "org.asynchttpclient.netty.request.NettyRequestSender:void replayRequest(org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.filter.FilterContext,io.netty.channel.Channel)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.handler.intercept.ResponseFiltersInterceptor:boolean exitAfterProcessingFilters(io.netty.channel.Channel,org.asynchttpclient.netty.NettyResponseFuture,org.asynchttpclient.AsyncHandler,org.asynchttpclient.HttpResponseStatus,org.asynchttpclient.HttpResponseHeaders)",
            "org.asynchttpclient.netty.request.NettyRequestSender:boolean applyIoExceptionFiltersAndReplayRequest(org.asynchttpclient.netty.NettyResponseFuture,java.io.IOException,io.netty.channel.Channel)"
        ]
    },
    "org.asynchttpclient.netty.channel.NettyConnectListener$1:void onSuccess(java.lang.Object)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.SimpleFutureListener:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber$1$1:void operationComplete(io.netty.channel.ChannelFuture)": {
        "isVulRoot": false,
        "vulCaller": [
            "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber$1$1:void operationComplete(io.netty.util.concurrent.Future)"
        ]
    },
    "org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody$NettySubscriber$1$1:void operationComplete(io.netty.util.concurrent.Future)": {
        "isVulRoot": false,
        "vulCaller": []
    }
}